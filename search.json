[{"title":"「JSOI2007」合金 - 计算几何，Floyd","url":"%2Fbzoj-1027%2F","content":"\n某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 现在，用户给出了 $ n $ 种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。\n\n<!--more-->\n\n# 题解\n\n像我这种菜鸡看了题目描述就开始往网络流和DP上去考虑。。结果发现好像网络流很难这样做，然后DP我死活设计不出状态，打开题解以后发现这题原来是十分巧妙的计算几何。。\n\n首先，由于 $ a + b + c = 1 $，所以我们只需要知道其中两个值就可以，并不需要准确了解第三个值，体现在算法中就是只记录 $ a, b $。这样我们就可以把一种材料或者合金抽象成一个平面上的点，每个点的坐标为 $ (a, b) $。\n\n对于两个点 $ (x_1, y_1), (x_2, y_2) $ 所代表的原料，他们能够合成的合金一定在这两点之间的线段上，其坐标为 $ (ax_1 + bx_2, ay_1 + by_2) $，其中 $ a + b = 1 $。\n\n而对于三个点即以上代表的原料，他们能够合成的合金一定在这些点的凸包上。\n\n记代表原料的点集为 $ A $，代表合金的点集 $ B $，问题实际上就是求出 $ A $ 的一个子集，使得其中点的凸包能够完全覆盖 $ B $ 中的所有点。\n\n讲实话这个东西我不会求。。我不知道用传统的方法该怎么做，所以就学了人家巧妙的转化成最短路的方法。\n\n首先，我们 $ O(n ^ 2) $ 枚举 $ A $ 中的两个点 $ N, M $，对于 $ \\overrightarrow{NM} $，如果 $ B $ 中所有点都在 $ \\overrightarrow{NM} $ 的同侧（左侧或右侧，按下文判断方法应该是右侧顺时针）或是在 $ \\overrightarrow{NM} $ 上，则连接一条 $ N \\rightarrow M $ 的边。\n\n判断方法如下：\n对于枚举到的点 $ N, M $，枚举 $ B $ 中的点 $ K $，若所有 $ K $ 满足\n$$\n(\\overrightarrow{KN} \\times \\overrightarrow{KM} > 0) \\vee ((\\overrightarrow{KN} \\times \\overrightarrow{KM} \\leq 0) \\wedge (\\overrightarrow{KN} \\cdot \\overrightarrow{KM} = 0 ))\n$$\n\n则连接一条 $ N \\rightarrow M $ 的边，最后用 Floyd 求最小环即可。\n\n注：程序中的 $ K $ 为小写，$ N, M $ 分别为 $ i, j $，这里是为了表述美观而更改。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cfloat>\n#include <algorithm>\n\nconst int MAX_N = 500;\nconst int MAX_M = 500;\nconst double EPS = 1e-7;\nconst int INF = 0x3f3f3f3f;\n\nstruct Point {\n\tdouble x, y;\n\n\tPoint() {}\n\tPoint(double x, double y) : x(x), y(y) {}\n\n\tfriend inline Point operator-(const Point &a, const Point &b) {\n\t\treturn Point(a.x - b.x, a.y - b.y);\n\t}\n\n\tfriend inline double operator*(const Point &a, const Point &b) {\n\t\treturn a.x * b.y - a.y * b.x;\n\t}\n\n\tfriend inline double dot(const Point &a, const Point &b) {\n\t\treturn a.x * b.x + a.y * b.y;\n\t}\n} a[MAX_M + 1], b[MAX_N + 1];\n\nint m, n, map[MAX_N + 1][MAX_N + 1], f[MAX_N + 1][MAX_N + 1];\n\ninline int floyd() {\n\tint res = INF;\n\tmemcpy(f, map, sizeof(f));\n\n\tfor (int k = 1; k <= m; k++) {\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (f[i][k] < INF) {\n\t\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\t\tf[i][j] = std::min(f[i][j], f[i][k] + f[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= m; i++) res = std::min(res, f[i][i]);\n\treturn res;\n}\n\nint main() {\n\tmemset(map, 0x3f, sizeof(map));\n\n\tscanf(\"%d %d\", &m, &n);\n\tfor (int i = 1; i <= m; i++) scanf(\"%lf%lf%*lf\", &a[i].x, &a[i].y);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lf%lf%*lf\", &b[i].x, &b[i].y);\n\t\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= m; j++) { \n\t\t\tint k;\n\t\t\tfor (k = 1; k <= n; k++) {\n\t\t\t\tdouble det = (a[i] - b[k]) * (a[j] - b[k]);\n\t\t\t\tif (det > EPS) break;\n\t\t\t\tif (fabs(det) < EPS && dot(a[i] - b[k], a[j] - b[k]) > EPS) break;\n\t\t\t}\n\t\t\tif (k == n + 1) map[i][j] = 1;\n\t\t}\n\t}\n\n\n\tint ans = floyd();\n\tif (ans == INF) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","tags":["计算几何"],"categories":["OI"]},{"title":"「SCOI2009」游戏 - DP，线性筛，置换","url":"%2Fbzoj-1025%2F","content":"\n\n对于一个长度为 $ n $ 的序列 $ A $，记其置换集合为 $ G $，对于 $ f \\in G $，记使得 $ f(f(f (\\dots (f(A)))) = A $ 的嵌套次数为其排数，求对于所有 $ f \\in \nG $ 共有多少种不同的排数。\n\n<!--more-->\n\n# 题解\n将置换改写成轮换，一个很显然的结论是：对于一个置换，所求排数为改写成轮换后所有环的点数的最小公倍数 + $ 1 $。\n\n所以问题变为，把 $ n $ 分成 $ k $ 个数 $ a_1, a_2, \\dots, a_k $ 满足 $ \\sum a_i = n $，求 $ \\text{lcm}(a_i) $ 的不同取值个数。\n\n首先要说明一个性质，就是若干个数的最小公倍数一定可以改写成若干个素数的幂的最小公倍数。\n\n以两个数的情况为例：设 $ k_1 = a_1 ^ {p_1} a_2 ^ {p_2} a_3 ^ {p_3} $，$ k_2 = a_1 ^ {p_4} a_2 ^ {p_5} a_3 ^ {p_6} $，并且 $ p_1 > p_4, p_2 < p_5, p_3 > p_6 $，那么 $ \\text{lcm}(k_1, k_2) = a_1 ^ {p_1} a_2 ^ {p_5} a_3 ^ {p_3} = \\text{lcm}(a_1 ^ {p_1}, a_2 ^ {p_5}, a_3 ^ {p_3}) $。\n\n当然这个证明不是很严谨啦我也知道不要喷我啦。。这不算是证明只是个说明啦。。其他情况和这种情况也都差不多，所以我们知道，只考虑素数的幂就可以取得所有的不同取值。\n\n考虑DP，以使用不同的素数为阶段，可以满足无后效性，设 $ f(i, j) $ 表示目前使用了前 $ i $ 个素数，这些素数的幂的和为 $ j $ 时的不同最小公倍数个数，用类似背包的形式转移，具体转移见代码。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAX_N = 1000;\nconst int MAX_CNT = 168;\n\nbool isNotPrime[MAX_N + 1];\nint primes[MAX_N + 1], cnt;\ninline void sieve(int n) {\n\tisNotPrime[1] = true;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (!isNotPrime[i]) primes[++cnt] = i;\n\n\t\tfor (int j = 1; j <= cnt && primes[j] * i <= n; j++) {\n\t\t\tint p = primes[j];\n\t\t\tisNotPrime[i * p] = true;\n\t\t\tif (i % p == 0) break;\n\t\t}\n\t}\n}\n\nunsigned long long f[MAX_CNT + 1][MAX_N + 1];\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tsieve(n);\n\n\tfor (int i = 0; i <= cnt; i++) f[i][0] = 1;\n\tfor (int j = 0; j <= n; j++) f[0][j] = 1;\n\n\tfor (int i = 1; i <= cnt; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tf[i][j] = f[i - 1][j];\n\t\t\tfor (int k = primes[i]; k <= j; k *= primes[i]) {\n\t\t\t\tf[i][j] += f[i - 1][j - k];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%llu\\n\", f[cnt][n]);\n\treturn 0;\n}\n```","tags":["置换"],"categories":["OI"]},{"title":"「SCOI2009」生日快乐","url":"%2Fbzoj-1024%2F","content":"\n现有一块长为 $ X $，宽为 $ Y $ 的蛋糕，切 $ N - 1 $ 刀，分成 $ N $ 块，在保证每块蛋糕面积相等的前提下使得 $ N $ 块切好的蛋糕长边比短边的最大值最小，求这个最小值。\n\n<!--more-->\n\n# 题解\n乍一看感觉除了搜好像没有什么更好的做法，但是想了想感觉 $ X, Y $ 的范围看起来让人发虚。。\n\n于是就咸鱼的看了题解。。才注意到 $ N \\leq 10 $ 这个可爱的条件。\n\n首先，对于需要被等分成 $ N $ 块的长为 $ X $，宽为 $ Y $ 的蛋糕，若横切，则分成的两块的宽度必须为 $ \\lfloor \\frac Y N \\rfloor $ 的整数倍，否则一定无法满足等分，纵切情况类似。\n\n由于 $ N $ 很小，可以直接暴搜，设当前状态为面对一块长为 $ x $，宽为 $ y $，需要被分成 $ d $ 块的蛋糕，分横切纵切枚举分成的两块的长或宽，搜出来最大的长宽比更新答案即可。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\ndouble dfs(double x, double y, int d) {\n\tdouble res = 100000.0;\n\tif (d == 1) {\n\t\tif (x < y) std::swap(x, y);\n\t\treturn x / y;\n\t}\n\n\tdouble xx = x / d;\n\tfor (int i = 1; i <= d / 2; i++) {\n\t\tdouble temp = std::max(dfs(xx * i, y, i), dfs(x - xx * i, y, d - i));\n\t \tres = std::min(res, temp);\n\t}\n\n\tdouble yy = y / d;\n\tfor (int i = 1; i <= d / 2; i++) {\n\t\tdouble temp = std::max(dfs(x, yy * i, i), dfs(x, y - yy * i, d - i));\n\t\tres = std::min(res, temp);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tint x, y, n;\n\tscanf(\"%d %d %d\", &x, &y, &n);\n\tprintf(\"%.6lf\\n\", dfs(x, y, n));\n\treturn 0;\n}\n```","tags":["搜索"],"categories":["OI"]},{"title":"「SHOI2008」仙人掌图 - 仙人掌DP，单调队列","url":"%2Fbzoj-1023%2F","content":"\n给定一个仙人掌图，求其直径。\n\n<!--more-->\n\n# 题解\n仙人掌什么的好难呀，看了好长时间的题解才理解究竟要怎么做，不过感觉还是蛮有趣的，处理树上和环上的方式也很巧妙，那么我就简单口胡一下。。\n\n选一个点为根，DFS 整棵树，设 $ f(i) $ 表示DFS树中以节点 $ i $ 为根的子树的点集在原图中的诱导子图中以 $ i $ 开始的最长路径。\n\n若不考虑环，记 $ S_i $ 为节点 $ i $ 的儿子集合，则有 $ f(i) = \\max\\limits_{j \\in S_i}(f(j) + 1) $。\n\n然而由于环的存在，会使得某些点之间的距离变小，从而影响维护到的 $ f $ 值的正确性，所以我们在转移 $ f(i) $ 时需要满足转移到他的节点 $ j $ 不和 $ i $ 处在同一个环上，即不在同一个环上转移 $ f $。\n\n判断环的问题，只需要在 DFS 的时候按照 Tarjan 算法的流程记录每个点的 $ \\text{low} $ 和 $ \\text{dfn} $ 即可。\n\n由于仙人掌的特性，以及 DFS 的过程，对于每个环都可以找到一个深度最小的点，我们称这个点为 **最高点**，显然的，这个环的祖先的 $ f $ 值的更新需要且仅需要用到最高点的 $ f $ 值，所以对于整个环，在用环上的节点的不在环上的子节点更新过自身的 $ f $ 后，只需要再更新最高点的 $ f $ 值即可。\n\n设最高点为 $ u $，则 $ f(u) $ 由环上节点转移的方式为 $ f(u) = f(v) + \\text{dist}(u, v) $ ，其中 $ v $ 和 $ u $ 在同一环上，\n\n以上内容全部是关于 $ f $ 值的更新，接下来要说的是更新答案的方式。\n\n对于桥上的答案，我们在 DFS 过程中更新 $ f $ 值的同时更新答案，设答案为 $ \\text{ans} $，目前正在更新 $ f $ 值的节点为 $ i $，则此时有 $ \\text{ans} =  f(i) + f(j) + 1, j \\in S_i $。注意要在尝试从节点 $ j $ 转移 $ f $ 值之前更新答案，否则不能涵盖所有情况，还可能导致状态出现错误。\n\n显然地，环上的节点也可以用来更新答案。对于环上的节点 $ i, j $ 来说，其导致的答案的形式应该是 $ f(i) + f(j) + \\text{dist}(i, j) $。设 $ s(i) $ 为节点 $ i $ 在环上的编号（编号按照 DFS树 上的深度为顺序），则原式可以改写成为 $ f(i) + f(j) + |s(i) - s(j)| $。如果按照深度为顺序转移答案，并且保证在枚举到节点 $ i $ 时转移区间连续并且长度不超过环长度的一半，就可以使用单调队列维护 $ f(j) - s(j) $ 的值来优化转移。\n\n具体细节详见代码。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <stack>\n#include <algorithm>\n\nconst int MAX_N = 50000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tNode *fa;\n\tint dfn, low;\n\tint len;\n\tbool vis;\n} N[MAX_N + 1];\n\nstruct Edge {\n\tNode *fr, *to;\n\tEdge *ne;\n\n\tEdge(Node *fr, Node *to) : fr(fr), to(to), ne(fr->e) {}\n};\n\ninline void addEdge(int fr, int to) {\n\tN[fr].e = new Edge(&N[fr], &N[to]);\n\tN[to].e = new Edge(&N[to], &N[fr]);\n}\n\ninline void circle(Node *top, Node *u, int &ans) {\n\tstatic Node *v[MAX_N * 2];\n\tint cnt = 0;\n\n\twhile (true) {\n\t\tv[cnt++] = u;\n\t\tif (u == top) break;\n\t\tu = u->fa;\n\t}\n\n\tstd::reverse(v, v + cnt);\n\tstd::copy(v, v + cnt, v + cnt);\n\n\tint half = cnt / 2;\n\n\tstatic int q[MAX_N * 2];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\tfor (int i = 1; i < cnt * 2; i++) {\n\t\twhile (i - *l > half) l++;\n\n\t\tans = std::max(ans, v[*l]->len + v[i]->len + i - *l);\n\t\twhile (l <= r && v[i]->len - i > v[*r]->len - *r) r--;\n\t\t*++r = i;\n\t}\n\n\tint res = 0;\n\tfor (int i = 1; i < cnt; i++) {\n\t\tres = std::max(res, v[i]->len + std::min(i, cnt - i));\n\t}\n\n\ttop->len = std::max(top->len, res);\n}\n\nint ans = 0;\n\nvoid tarjan(Node *v) {\n\tstatic int ts = 0;\n\tv->dfn = v->low = ++ts;\n\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\tif (e->to != v->fa) {\n\t\t\tif (!e->to->dfn) {\n\t\t\t\te->to->fa = v;\n\t\t\t\ttarjan(e->to);\n\t\t\t\tv->low = std::min(v->low, e->to->low);\n\t\t\t} else v->low = std::min(v->low, e->to->dfn);\n\n\t\t\tif (v->dfn < e->to->low) {\n\t\t\t\tans = std::max(ans, v->len + e->to->len + 1);\n\t\t\t\tv->len = std::max(v->len, e->to->len + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\tif (e->to->fa != v && e->to->dfn > v->dfn) {\n\t\t\tcircle(v, e->to, ans);\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint k, u;\n\t\tscanf(\"%d %d\", &k, &u);\n\t\tfor (int j = 2; j <= k; j++) {\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v);\n\t\t\taddEdge(u, v);\n\t\t\tu = v;\n\t\t}\n\t}\n\n\ttarjan(&N[1]);\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","tags":["仙人掌DP"],"categories":["OI"]},{"title":"「SHOI2008」循环的债务 - DP","url":"%2Fbzoj-1021%2F","content":"\nA，B，C 三个人之间互相有一些债务，每个人有面值为 $ 1, 5, 10, 20, 50, 100 $ 的钞票若干，求出他们之间钞票交换次数最少的交换方式。\n\n<!--more-->\n\n# 题解\n最开始看到这道题的时候，我还以为这题是网络流。。现在看看我还是 too young..\n\n好吧可以说团长的DP是真的好差。。\n\n这道题的初始状态就像题目描述中说的那样，终止状态应该是 A，B，C 各自还清债务又收回欠款，由于欠款可以用一个 DAG 来描述（若成环则去掉环中权值最小的边），所以终止状态下 A，B，C 拥有的钱的数目是一定的，所以尝试使用钱数作为状态。\n\n设 $ f(i, a, b) $ 为使用前 $ i $ 种面值的钞票，使得 $ A $ 有 $ a $ 元，$ B $ 有 $ b $ 元的最小交换次数。\n\n枚举交换方式，有如下几种交换：\n\n$\na \\rightarrow b, c \\\\\\\\\nb \\rightarrow a, c \\\\\\\\\nc \\rightarrow a, c \\\\\\\\\na, b \\rightarrow c \\\\\\\\\na, c \\rightarrow b \\\\\\\\\nb, c \\rightarrow a\n$\n\n其中 $ a \\rightarrow b $ 意为 $ a $ 把钱给 $ b $。\n\n# 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAX_M = 1000;\nconst int VAL[] = { -1, 1, 5, 10, 20, 50, 100 };\n\nint sum[3], own[3][6 + 1];\nint tot;\n\nint f[6 + 1][MAX_M + 1][MAX_M + 1];\n\nint main() {\n\tint a, b, c;\n\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\tif (a > 0 && b > 0 && c > 0) {\n\t\tint min = std::min(std::min(a, b), c);\n\t\ta -= min, b -= min, c -= min;\n\t} else if (a < 0 && b < 0 && c > 0) {\n\t\tint max = std::max(std::max(a, b), c);\n\t\ta -= max, b -= max, c -= max;\n\t}\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tscanf(\"%d\", &own[i][6 - j]);\n\t\t\tsum[i] += own[i][6 - j] * VAL[6 - j];\n\t\t}\n\t\ttot += sum[i];\n\t}\n\n\tfor (int i = 0; i <= 6; i++)\n\t\tfor (int j = 0; j <= MAX_M; j++)\n\t\t\tfor (int k = 0; k <= MAX_M; k++)\n\t\t\t\tf[i][j][k] = INT_MAX;\n\n\tf[0][sum[0]][sum[1]] = 0;\n\n\tfor (int i = 0; i < 6; i++) {\n\t\tfor (int a = 0; a <= tot; a++) {\n\t\t\tfor (int b = 0; b <= tot - a; b++) {\n\t\t\t\tint c = tot - a - b;\n\t\t\t\tif (f[i][a][b] == INT_MAX) continue;\n\n\t\t\t\t// a -> b, c\n\t\t\t\tfor (int tb = 0; tb <= own[0][i + 1]; tb++) {\n\t\t\t\t\tfor (int tc = 0; tc <= own[0][i + 1] - tb; tc++) {\n\t\t\t\t\t\tif (tb + tc == 0) continue;\n\t\t\t\t\t\tint _a = a - VAL[i + 1] * (tb + tc);\n\t\t\t\t\t\tint _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tint _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + tb + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b -> a, c\n\t\t\t\tfor (int ta = 0; ta <= own[1][i + 1]; ta++) {\n\t\t\t\t\tfor (int tc = 0; tc <= own[1][i + 1] - ta; tc++) {\n\t\t\t\t\t\tif (ta + tc == 0) continue;\n\t\t\t\t\t\tint _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tint _b = b - VAL[i + 1] * (ta + tc);\n\t\t\t\t\t\tint _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// c -> a, b\n\t\t\t\tfor (int ta = 0; ta <= own[2][i + 1]; ta++) {\n\t\t\t\t\tfor (int tb = 0; tb <= own[2][i + 1] - ta; tb++) {\n\t\t\t\t\t\tif (ta + tb == 0) continue;\n\t\t\t\t\t\tint _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tint _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tint _c = c - VAL[i + 1] * (ta + tb);\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, b -> c\n\t\t\t\tfor (int fa = 0; fa <= own[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fb = 0; fb <= own[1][i + 1]; fb++) {\n\t\t\t\t\t\tif (fa + fb == 0) continue;\n\t\t\t\t\t\tint _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tint _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tint _c = c + VAL[i + 1] * (fa + fb);\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, c -> b\n\t\t\t\tfor (int fa = 0; fa <= own[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fc = 0; fc <= own[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fa + fc == 0) continue;\n\t\t\t\t\t\tint _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tint _b = b + VAL[i + 1] * (fa + fc);\n\t\t\t\t\t\tint _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b, c -> a\n\t\t\t\tfor (int fb = 0; fb <= own[1][i + 1]; fb++) {\n\t\t\t\t\tfor (int fc = 0; fc <= own[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fb + fc == 0) continue;\n\t\t\t\t\t\tint _a = a + VAL[i + 1] * (fb + fc);\n\t\t\t\t\t\tint _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tint _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fb + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tf[i + 1][a][b] = std::min(f[i + 1][a][b], f[i][a][b]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint resA = sum[0] - a + c, resB = sum[1] - b + a, resC = sum[2] - c + b;\n\tif (resA < 0 || resB < 0 || resC < 0 || f[6][resA][resB] == INT_MAX) puts(\"impossible\");\n\telse printf(\"%d\\n\", f[6][resA][resB]);\n\n\treturn 0;\n}\n```","tags":["DP"],"categories":["OI"]},{"title":"「SHOI2008」汉诺塔 - DP","url":"%2Fbzoj-1019%2F","content":"\n用 $ A, B, C $ 分别表示汉诺塔问题中的三根柱子。\n\n用两个字母描述一个操作，例如 ` AB ` 就是把柱子 $ A $ 最上面圆盘挪动到柱子 $ B $ 上。\n\n我们为所有的 $ 6 $ 种操作赋予一个优先级，并且利用以下规则进行游戏：\n1. 选择一种操作，这种操作是所有合法操作中优先级最高的。\n2. 本次操作需要移动的圆盘不是上一次操作移动的圆盘。\n\n可以证明，上述策略一定能完成汉诺塔游戏。\n计算给定操作优先级时将 $ A $ 柱子上的 $ n $ 个圆盘全部移动到另一根上所需的操作数。\n\n<!--more-->\n\n# 题解\n\n由于优先级的限制，不能像传统的汉诺塔问题一样解决，考虑DP。\n\n设 $ f(j, i) $ 表示将 $ i $ 号柱子最上面的 $ j $ 个盘子（不考虑下面的盘子），移动到编号为 $ g(j, i) $ 的柱子上所需要的最小移动次数。\n\n显然的，当 $ j = 1 $ 时，$ g(j, i) $ 由题目给定的优先级确定。按照 $ j $ 从小到大划分阶段，则 $ j > 1 $ 时 $ g(j, i) $ 的值由前一阶段确定。\n\n转移 $ f(j, i) $ 时，考虑 $ f(j - 1, i) $ 和 $ g(j - 1, i) $。\n\n记 $ g(j - 1, i) = a $，则按照传统的汉诺塔问题的思路应该移动到除了柱子 $ i $ 和柱子 $ a $ 的另一根柱子，记作 $ b $，而且有 $ b = 3 - a - i $。\n\n若 $ g(j - 1, a) = b $，则我们需要做的只有将柱子 $ i $ 上的第 $ j $ 个盘子移动到 $ b $ 上，然后把柱子 $ a $ 上的 $ j - 1 $ 个柱子移动到柱子 $ b $ 上。\n\n此时对于 $ f(j, i) $ 有：\n$$\nf(j, i) = f(j - 1, i) + 1 + f(j - 1, a)\n$$\n\n而对于 $ g(j, i) $ 有：\n$$\ng(j, i) = b\n$$\n\n若 $ g(j - 1, a) = i $，则此时的最优解决方案是先将第 $ j $ 个盘子移动到 $ b $ 上，再将柱子 $ a $ 上的 $ j $ 个盘子移动到第 $ i $ 根柱子上，再将盘子 $ j $ 移动到柱子 $ a $ 上，最后将柱子 $ i $ 上的 $ j - 1 $ 个盘子移动到柱子 $ a $ 上。\n\n此时对于 $ f(j, i) $ 有：\n$$\nf(j, i) = f(j - 1, i) + 1 + f(j - 1, a) + 1 + f(j - 1, i)\n$$\n\n对于 $ g(j, i) $ 有：\n$$\ng(j, i) = a\n$$\n\n对于这种奇怪的转移可以通过对于只移动一根柱子的特殊情况的思考来理解。\n\n# 代码\n```c++\n#include <cstdio>\n\nconst int MAX_N = 30;\n\nint g[MAX_N + 1][3];\nlong long f[MAX_N + 1][3];\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tg[1][0] = g[1][1] = g[1][2] = -1;\n\tfor (int i = 0; i < 6; i++) {\n\t\tchar rule[4];\n\t\tscanf(\"%s\", rule);\n\n\t\tint fr = rule[0] - 'A', to = rule[1] - 'A';\n\t\tif (g[1][fr] == -1) g[1][fr] = to; // Good to own a BRAIN..\n\t}\n\n\tf[1][0] = f[1][1] = f[1][2] = 1;\n\n\tfor (int j = 2; j <= n; j++) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tconst int a = g[j - 1][i], b = 3 - a - i;\n\t\t\tif (g[j - 1][a] == b) {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a];\n\t\t\t\tg[j][i] = b;\n\t\t\t} else {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a] + 1 + f[j - 1][i];\n\t\t\t\tg[j][i] = a;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", f[n][0]);\n\treturn 0;\n}\n```","tags":["DP"],"categories":["OI"]},{"title":"「SHOI2008」堵塞的交通 - 线段树","url":"%2Fbzoj-1018%2F","content":"\n在一个有 $ 2C $ 个点，$ 3C - 2 $ 条边的 $ 2 $ 行 $ C $ 列的网格图中，相邻两个节点有连边，给定以下三种操作。\n\n1. `Open r1 c1 r2 c2` 连接节点 ` (r1, c1), (r2, c2) ` 的边连通。\n2. `Close r1 c1 r2 c2` 连接节点 ` (r1, c1), (r2, c2) ` 的边断开。\n3. `Ask r1 c1 r2 c2` 查询节点 `(r1, c1), (r2, c2)` 之间的连通性。\n\n开始时每条边都是断开的状态。\n\n<!--more-->\n\n# 题解\n\n为什么这种特殊的要死的图我第一时间想到的是 LCT，怕不是我失了智。。\n\n但是看了题解的线段树做法，我感觉我整个人都没有智商了。。怕不是我变成了大傻子。。\n \n原图中有上下两行，这里用 $ (i, 0) $ 表示第 $ i $ 列上面的城市，用 $ (i, 1) $ 表示第 $ i $ 列下面的城市。\n\n对于线段树中的一个代表区间 $ [l, r] $ 的节点，其中维护的是 $ (l, 0), (l, 1) $ 分别与 $ (r, 0), (r, 1) $ 的连通性。\n\n对于某个区间 $ [l = i, r = i] $，我们认为这个区间中的 $ (l, 0), (r, 0) $ 是连通的，同样的 $ (l, 1), (r, 1) $ 也是连通的。\n\n若该位置上下连通，则认为 $ (l, 0), (r, 1) $ 连通，同时 $ (r, 0), (l, 1) $ 连通。\n\n合并两个区间 $ [l, m], [m + 1, r] $，枚举 $ m \\leftrightarrow m + 1 $ 经过的是上面的还是下面的路径。\n\n回答询问时，假设 $ c1 $ 在 $ c2 $ 左边，二分 $ c1 $ 能够达到的最左位置以及 $ c2 $ 能够达到的最右位置，枚举回答。假如 `(r1, c1)` 不和 `(r2, c2)` 直接连通，那么这样做可以包含到 `(r1, c1)` 先向左走以及 `(r2, c2)` 先向右走的情况。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAX_C = 100000;\n\nint n;\nbool right[MAX_C][2], uad[MAX_C + 1];\n\nstruct Connectivity {\n\tbool a[2][2];\n\n\tConnectivity(bool init) {\n\t\ta[0][0] = a[0][1] = a[1][0] = a[1][1] = init;\n\t}\n\n\tbool &operator()(const int i, const int j) { return a[i][j]; }\n\tbool operator()(const int i, const int j) const { return a[i][j]; }\n\n\toperator bool() const { return a[0][0] || a[0][1] || a[1][0] || a[1][1]; }\n};\n\ninline Connectivity merge(Connectivity a, Connectivity b, int mid) {\n\tConnectivity res(false);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tres(i, j) |= a(i, k) && right[mid][k] && b(k, j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct Segt {\n\tint l, r, mid;\n\tSegt *lc, *rc;\n\n\t// con(0, 0) : (l, 0) <-> (r, 0)\n\t// con(0, 1) : (l, 0) <-> (r, 1)\n\t// con(1, 0) : (l, 1) <-> (r, 0)\n\t// con(1, 1) : (l, 1) <-> (r, 1)\n\tConnectivity con;\n\n\tSegt(int l, int r, Segt *lc, Segt *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), con(l == r) {}\n\n\tvoid modify(int l, int r) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (this->l == this->r) {\n\t\t\tcon(0, 0) = con(1, 1) = true;\n\t\t\tcon(0, 1) = con(1, 0) = uad[mid];\n\t\t\treturn;\n\t\t} else lc->modify(l, r), rc->modify(l, r);\n\t\tcon = merge(lc->con, rc->con, mid);\n\t}\n\n\tConnectivity query(int l, int r) {\n\t\tif (l <= this->l && r >= this->r) return this->con;\n\t\telse if (r <= mid) return lc->query(l, r);\n\t\telse if (l > mid) return rc->query(l, r);\n\t\telse return merge(lc->query(l, r), rc->query(l, r), mid);\n\t}\n\n\tstatic Segt *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\tif (l == r) return new Segt(l, r, NULL, NULL);\n\t\telse {\n\t\t\tint mid = l + (r - l) / 2;\n\t\t\treturn new Segt(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segt;\n\ninline void modify(int r1, int c1, int r2, int c2, bool state) {\n\tif (r1 == r2) {\n\t\tright[std::min(c1, c2)][r1] = state;\n\t} else if (c1 == c2) {\n\t\tuad[c1] = state;\n\t}\n\tsegt->modify(std::min(c1, c2), std::max(c1, c2));\n}\n\ninline bool query(int r1, int c1, int r2, int c2) {\n\tint l, r;\n\n\tl = 1, r = c1;\n\twhile (l < r) {\n\t\t int mid = l + (r - l) / 2;\n\t\t Connectivity res = segt->query(mid, c1);\n\t\t if (res(0, r1) || res(1, r1)) r = mid;\n\t\t else l = mid + 1;\n\t}\n\tconst int lpos = l;\n\tConnectivity lcon = segt->query(lpos, c1);\n\n\tl = c2, r = n;\n\twhile (l < r) {\n\t\tint mid = l + (r - l) / 2 + 1;\n\t\tConnectivity res = segt->query(c2, mid);\n\t\tif (res(r2, 0) || res(r2, 1)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\tconst int rpos = l;\n\tConnectivity rcon = segt->query(c2, rpos);\n\n\tConnectivity con = segt->query(lpos, rpos);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (lcon(i, r1) && rcon(r2, j) && con(i, j)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsegt = Segt::build(1, n);\n\tchar cmd[5];\n\twhile (scanf(\"%s\", cmd) != EOF) {\n\t\tif (cmd[0] == 'E') break;\n\t\telse {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tr1--, r2--;\n\t\t\tif (cmd[0] == 'O') modify(r1, c1, r2, c2, true);\n\t\t\telse if (cmd[0] == 'C') modify(r1, c1, r2, c2, false);\n\t\t\telse {\n\t\t\t\tif (c1 > c2) std::swap(r1, r2), std::swap(c1, c2);\n\t\t\t\tputs(query(r1, c1, r2, c2) ? \"Y\" : \"N\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","tags":["线段树"],"categories":["OI"]},{"title":"「JSOI2008」魔兽地图 - 树形DP，多重背包","url":"%2Fbzoj-1017%2F","content":"\n给定 $ n $ 件物品，$ m $ 个金币，每个物品有自己的价值。低级物品可以直接购买，高级物品需要若干件较低级的物品来合成，并且具有合成的数量限制，求能够获得的最大价值。\n\n<!--more-->\n\n# 题解\n很不错的树形DP，反正我一开始是没想出来。\n\n设 $ p_i, c_i, w_i $ 分别表示物品 $ i $ 的价值，合成数量限制和价格。\n\n高级装备的 $ w, c $ 用子树的信息合并一下就好。\n\n设 $ f(i, j, k) $ 为合成 $ j $ 件物品 $ i $ 贡献给父节点，花费了 $ k $ 个金币所能获得的最大价值。记 $ son_i $ 为节点 $ i $ 的子节点集合。\n\n枚举合成 $ a $ 件 $ i $ 物品，余下的钱用来购买一些子树中的物品来获得价值。\n\n对于枚举到的合成数目 $ a $，设 $ g(t, j) $ 表示在某个节点的前 $ t $ 棵子树花费 $ j $ 个金币所能获得的最大收益，$ q_i(k) $ 表示合成物品 $ i $ 所需物品 $ k $ 的数量。\n\n$$\ng(t, j) = \\max\\limits_{k = 0}^{j}\\{g(t, j), g(t - 1, j - k) + f(son_i(t), a \\times q_i(son_i(t)), j)\\}\n$$\n\n从合成的 $ a $ 件中挑选 $ j $ 件贡献给父节点，由此转移 $ f(i, j, k) $。\n\n$$\nf(i, j, k) = \\max\\{ g(|son_i|, k) + p_i \\times (a - j) \\}\n$$\n\n这道题最巧妙的决策点在确定合成一件物品时用来获得价值的数目和拿来合成更高级物品的数目。\n\n然后，如果没有任何高级装备的话，需要另写一个多重背包来特判。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAX_N = 51;\nconst int MAX_M = 2000;\nconst int MAX_K = 100;\n\nint n, m;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint cnt, cost, p, d;\n\tint f[MAX_K + 1][MAX_M + 1];\n\tbool basic;\n} N[MAX_N + 1];\n\nstruct Edge {\n\tNode *fr, *to;\n\tEdge *ne;\n\tint w;\n\n\tEdge(Node *fr, Node *to, int w) : fr(fr), to(to), ne(fr->e), w(w) {}\n};\n\ninline void addEdge(int fr, int to, int w) {\n\tN[to].d++;\n\tN[fr].e = new Edge(&N[fr], &N[to], w);\n}\n\nint g[MAX_N + 1][MAX_M + 1], h[MAX_N + 1][MAX_M + 1];\n\ninline void dp(Node *v) {\n\tint (&f)[MAX_K + 1][MAX_M + 1] = v->f;\n\t\n\tif (v->basic) {\n\t\tv->cnt = std::min(v->cnt, m / v->cost);\n\t\tfor (int i = 0; i <= v->cnt; i++)\n\t\t\tfor (int j = i; j <= v->cnt; j++)\n\t\t\t\tf[i][j * v->cost] = (j - i) * v->p;\n\t\treturn;\n\t} else {\n\t\tv->cnt = INT_MAX;\n\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\tdp(e->to);\n\t\t\tv->cnt = std::min(v->cnt, e->to->cnt / e->w);\n\t\t\tv->cost += e->w * e->to->cost;\n\t\t}\n\t\tv->cnt = std::min(v->cnt, m / v->cost);\n\n\t\tmemset(g, -0x3f3f3f3f, sizeof(g));\n\n\t\tg[0][0] = 0;\n\t\tfor (int a = v->cnt; a >= 0; a--) {\n\t\t\tint id = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\t\tid++;\n\t\t\t\tfor (int j = 0; j <= m; j++)\n\t\t\t\t\tfor (int k = 0; k <= j; k++)\n\t\t\t\t\t\tg[id][j] = std::max(g[id][j], g[id - 1][j - k] + e->to->f[e->w * a][k]);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i <= a; i++)\n\t\t\t\tfor (int k = 0; k <= m; k++)\n\t\t\t\t\tf[i][k] = std::max(f[i][k], g[id][k] + v->p * (a - i));\n\t\t}\n\t}\n}\n\ninline void solveTree() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j <= MAX_K; j++)\n\t\t\tfor (int k = 0; k <= MAX_M; k++)\n\t\t\t\tN[i].f[j][k] = -100000000;\n\t}\n\tint tot = 0;\n\tfor (int x = 1; x <= n; x++) {\n\t\tNode *v = &N[x];\n\t\tif (!v->d) {\n\t\t\tdp(v);\n\t\t\ttot++;\n\t\t\tfor (int i = 0; i <= m; i++)\n\t\t\t\tfor (int j = 0; j <= i; j++)\n\t\t\t\t\tfor (int k = 0; k <= v->cnt; k++)\n\t\t\t\t\t\th[tot][i] = std::max(h[tot][i], h[tot - 1][j] + v->f[k][i - j]);\n\t\t}\n\t}\n\tint ans = INT_MIN;\n\tfor (int j = 0; j <= m; j++) ans = std::max(ans, h[tot][j]);\n\tprintf(\"%d\\n\", ans);\n}\n\ntemplate<class T>\nstruct MonoQueue {\n\tstd::deque<T> data, aux;\n\n\tvoid push(const T &x) {\n\t\tdata.push_back(x);\n\t\twhile (!aux.empty() && aux.back() < x) aux.pop_back();\n\t\taux.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tif (data.front() == aux.front()) aux.pop_front();\n\t\tdata.pop_front();\n\t}\n\n\tint size() {\n\t\treturn data.size();\n\t}\n\n\tT max() {\n\t\treturn aux.front();\n\t}\n};\n\nint f[MAX_M + 1];\n\ninline void multiplePack(int cost, int w, int cnt) {\n\tcnt = std::min(cnt, m / cost);\n\tfor (int d = 0; d < cost; d++) {\n\t\tMonoQueue<int> q;\n\t\tfor (int k = 0; k * cost + d <= m; k++) {\n\t\t\tq.push(f[k * cost + d] - k * w);\n\t\t\tif (q.size() == cnt + 2) q.pop();\n\t\t\tf[k * cost + d] = q.max() + k * w;\n\t\t}\n\t}\n}\n\ninline void solveMultiplePack() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tmultiplePack(N[i].cost, N[i].p, N[i].cnt);\n\t}\n\tint ans = INT_MIN;\n\tfor (int i = 0; i <= m; i++) {\n\t\tans = std::max(ans, f[i]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &N[i].p);\n\t\tchar ch[5];\n\t\tscanf(\"%s\", ch);\n\t\tif (ch[0] == 'B') {\n\t\t\tscanf(\"%d %d\", &N[i].cost, &N[i].cnt);\n\t\t\tN[i].basic = true;\n\t\t} else {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\twhile (c--) {\n\t\t\t\tint v, w;\n\t\t\t\tscanf(\"%d %d\", &v, &w);\n\t\t\t\taddEdge(i, v, w);\n\t\t\t}\n\t\t}\n\t}\n\n\tbool flag = false;\n\tfor (int i = 1; i <= n; i++) if (N[i].d) flag = true;\n\n\tif (flag) solveTree();\n\telse solveMultiplePack();\n\n\treturn 0;\n}\n```","tags":["多重背包"],"categories":["OI"]},{"title":"「JSOI2008」最小生成树计数 - 状压，kruskal","url":"%2Fbzoj-1016%2F","content":"\n给定一个无向图，求其最小生成树个数。\n\n<!--more-->\n\n# 题解\n尝试证明一个奇奇怪怪的定理：一个无向图的所有最小生成树中某种权值的边的数目相同。\n\n按照 `kruskal` 算法的流程，我们会在对边排序之后尝试从小到大尝试加入某种权值的所有边，我们设权值最小的边的权值为 $ w $，原图中权值为 $ w $ 的边有 $ c $ 条，出现在最小生成树中的权值为 $ w $ 的边有 $ a $ 条。那么任何一个加入 $ a $ 条边权为 $ w $ 的边而不使图成环的方案都可以使原图到达相同的连通性。\n\n假设加入能够加入的 $ a $ 条边以后得到若干个连通块，记其中一个连通块为 $ G $，其余连通块同理，那么去掉 $ G $ 中一条边，得到两个连通块 $ A, B $，现在尝试添加一条不同于原来在 $ G $ 中任意一条边的边，那么此时这条边 $ (u, v) $ 有两种情况：\n1. $ u \\in A, v \\in B $，那么添加这条边后仍然得到连通块 $ G $。\n2. $ (u \\in A, v \\in A) \\wedge (u \\in B, v \\in B) $ 那么添加这条边势必成环，此时不允许添加这条边。\n\n在添加第二小的边的时候，将添加最小的边之后得到的若干个连通块缩点，这时已经没有可以加进最小生成树的权值最小的边，所以权值最第二小的边变成新的权值最小的边，此时尝试加边之后得到的图的连通性的性质同上述情况。\n\n以添加进最小生成树的边的权值划分阶段，那么每个阶段中添加的边的数量是固定的，这也就意味着某种权值的边的数目是完全相同的。\n\n以上内容借鉴如下博客。。\n[BZOJ1016 [JSOI2008]最小生成树计数](http://blog.csdn.net/wyfcyx_forever/article/details/40182739)\n\n贴上 sengxian 更加严谨的证明：\n[BZOJ 1016 - [JSOI2008]最小生成树计数](https://blog.sengxian.com/solutions/bzoj-1016)\n\n得到了这个结论以后，就可以枚举选择每种边权的边了，如果在节点间连上枚举到的边不成环，那么这就是一种可行的最小生成树方案。利用状压枚举，统计每种边权的方案数，最后乘法原理即可。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <map>\n#include <vector>\n#include <algorithm>\n\nconst int MAX_N = 100;\nconst int MAX_M = 1000;\nconst int MOD = 31011;\n\nstruct Edge {\n\tint u, v, w;\n\tbool vis;\n\n\tbool operator<(const Edge &other) const {\n\t\treturn w < other.w;\n\t}\n} E[MAX_M + 1];\n\nstruct UFS {\n\tint fa[MAX_N + 1];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i <= n; i++) fa[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn x == fa[x] ? fa[x] : fa[x] = find(fa[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tint f1 = find(x), f2 = find(y);\n\t\tfa[f1] = f2;\n\t}\n\n\tbool check(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n} ufs;\n\nstruct EdgeGroup {\n\tint cnt;\n\tstd::vector<Edge> e;\n};\n\nint n, m;\nbool g[MAX_N + 1][MAX_N + 1];\nstd::map<int, EdgeGroup> groups;\n\ninline bool kruskal() {\n\tstd::sort(E, E + m);\n\tufs.init(n);\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!ufs.check(E[i].u, E[i].v)) {\n\t\t\tE[i].vis = true;\n\t\t\tufs.merge(E[i].u, E[i].v);\n\t\t\tgroups[E[i].w].cnt++;\n\t\t\tcnt++;\n\t\t}\n\t\tgroups[E[i].w].e.push_back(E[i]);\n\t}\n\treturn cnt == n - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].u, &E[i].v, &E[i].w);\n\t}\n\n\tif (!kruskal()) {\n\t\tputs(\"0\");\n\t} else {\n\t\tlong long ans = 1;\n\t\tfor (int i = 0; i < m; i++) if (E[i].vis) g[E[i].u][E[i].v] = g[E[i].v][E[i].u] = true;\n\t\tfor (std::map<int, EdgeGroup>::const_iterator it = groups.begin(); it != groups.end(); it++) {\n\t\t\tif (it->second.cnt == 0) continue;\n\t\t\tint t = 0;\n\t\t\tfor (unsigned int s = 1; s < (1 << it->second.e.size()); s++) {\n\t\t\t\tint tot = 0;\n\t\t\t\tfor (unsigned int i = 0; i < it->second.e.size(); i++) if (s & (1 << i)) tot++;\n\t\t\t\tif (tot != it->second.cnt) continue;\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.e.begin(); e != it->second.e.end(); e++) {\n\t\t\t\t\tg[e->u][e->v] = g[e->v][e->u] = false;\n\t\t\t\t}\n\n\t\t\t\tfor (unsigned int i = 0; i < it->second.e.size(); i++) {\n\t\t\t\t\tif (s & (1 << i)) g[it->second.e[i].u][it->second.e[i].v] = g[it->second.e[i].v][it->second.e[i].u] = true;\n\t\t\t\t}\n\n\t\t\t\tufs.init(n);\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\t\t\t\tif (g[i][j]) {\n\t\t\t\t\t\t\tif (ufs.check(i, j)) goto Continue;\n\t\t\t\t\t\t\tufs.merge(i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\n\nContinue:;\n\t\t\t}\n\n//\t\t\tprintf(\"t = %d\\n\", t);\n\t\t\t(ans *= t) %= MOD;\n\n\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.e.begin(); e != it->second.e.end(); e++) {\n\t\t\t\tg[e->u][e->v] = g[e->v][e->u] = e->vis;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","tags":["搜索"],"categories":["OI"]},{"title":"「Codeforces Round 416 (Div. 2)」 C - DP","url":"%2Fcf811c%2F","content":"\n给定一个序列，每个位置上有一种颜色，要求把这个序列分成可以不连续的若干段，所有颜色相同的要么全部不选要么全部分到一段中，最终选取出的每一段的价值等于段中不同颜色编号的异或和，求最大价值。\n\n<!--more-->\n\n# 题解\n一开始我想处理区间之间的嵌套关系和交集关系，然后根据最终区间的嵌套关系来做树形DP，但是处理着处理着我发现区间的嵌套盒交集有一万种关系。\n\n绝望的我选择去翻AC代码，发现了一种新奇的DP思路。\n\n记原序列为 $ a $，设 $ f(i) $ 为处理到前 $ i $ 位的最大价值。 \n\n$ f(i) $ 可以从两种方式转移来，一种是 $ f(i) = f(i - 1) $，表示 $ a_i $ 所在的段目前不可选，或不选 $ a_i $ 颜色所在的段，另一种是考虑合并后的 $ a_i $ 所在的区间，记其左端点为 $ j $，有 $ f(i) = f(j - 1) + \\texttt{XORsum}(j, i) $。\n\n区间的合并可以在转移 $ f(i) $ 时，从 $ i $ 到 $ 1 $ 枚举 $ j $ 的过程中动态转移。注意一种颜色只需要被异或一次。\n\n# 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAX_N = 5000;\n\nint a[MAX_N + 1], l[MAX_N + 1], r[MAX_N + 1], dp[MAX_N + 1], vis[MAX_N + 1];\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i <= MAX_N; i++) {\n\t\tl[i] = n + 1;\n\t\tr[i] = -1;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ta[i] = x;\n\t\tl[x] = std::min(l[x], i);\n\t\tr[x] = std::max(r[x], i);\n\t}\n\n\tdp[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint sum = 0, lb = n;\n\t\tdp[i] = dp[i - 1];\n\t\tfor (int j = i; j >= 1; j--) {\n\t\t\tlb = std::min(lb, j);\n\t\t\tint x = a[j];\n\t\t\tif (r[x] > i) break;\n\t\t\tlb = std::min(lb, l[x]);\n\n\t\t\tif (vis[x] != i) {\n\t\t\t\tvis[x] = i;\n\t\t\t\tsum ^= x;\n\t\t\t}\n\n\t\t\tif (lb == j) {\n\t\t\t\tdp[i] = std::max(dp[i], dp[j - 1] + sum);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n]);\n\treturn 0;\n}\n```","tags":["DP"],"categories":["OI"]},{"title":"「JSOI2008」火星人Prefix - Splay，Hash","url":"%2Fbzoj1014%2F","content":"\n给定一个字符串，要求支持修改串中某个字符，在指定位置添加字符，以及求指定两个后缀的 $ LCP $ 长度。\n\n<!--more-->\n\n# 题解\n提到LCP当然会想到后缀家族，不过我才疏学浅，并不知道后缀家族怎么支持修改和插入。\n\n所以，Hash 大法好！\n\n话说回来当时在长乐的时候写字符串哈希的暴力，可能是我姿势不太对？模数一直取不对。。这道题没有卡自然溢出，感觉还是很良心的。\n\n好啦言归正传，对这个字符串建立一棵Splay，保证其中序遍历结果为原字符串。这样每一个Splay的节点都可以代表一个字串。如果要获得某个指定字串的哈希值，用Splay提区间就可以了。。\n\n合并左右子树信息的时候，不知诸君喜欢以左为高位还是右为高位啊。。这里就不引战啦哈哈。\n\n提示一个细节，这里为了Splay操作方便引入的左右端点节点会对某些节点的哈希值产生影响，但是由于Splay提取区间以后提取出来的区间对应的子树不会包括左右端点节点，而且这道题只需要用到提取区间，所以这样写没有错误。如果要让它的哈希值是正确的特判一下就好啦。\n\n还有讲实话哈希那一套理论我真的是不怎么懂啊 T^T\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAX_N = 100000;\nconst int MAX_M = 150000;\nconst unsigned long long BASE = 233;\n\nunsigned long long base[MAX_N + 1];\n\nstruct Splay {\n\tstruct Node {\n\t\tNode *fa, *c[2], **root;\n\t\tint size;\n\t\tchar val;\n\t\tunsigned long long hash;\n\n\t\tNode(Node *fa, Node **root, char val) : fa(fa), root(root), size(1), val(val), hash(val) {\n\t\t\tc[0] = c[1] = NULL;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (c[0] ? c[0]->size : 0) + (c[1] ? c[1]->size : 0) + 1;\n\n\t\t\thash = val;\n\t\t\tif (c[1]) hash += c[1]->hash * BASE;\n\t\t\tif (c[0]) hash = hash * base[c[0]->size] + c[0]->hash;\n\t\t}\n\n\t\tint lsize() {\n\t\t\treturn c[0] ? c[0]->size : 0;\n\t\t}\n\n\t\tint relation() {\n\t\t\treturn this == fa->c[1];\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tNode *old = fa;\n\t\t\tint x = relation();\n\n\t\t\tfa = old->fa;\n\t\t\tif (old->fa) old->fa->c[old->relation()] = this;\n\n\t\t\told->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->fa = old;\n\n\t\t\tc[x ^ 1] = old;\n\t\t\told->fa = this;\n\n\t\t\told->maintain(), maintain();\n\t\t\tif (!fa) *root = this;\n\t\t}\n\n\t\tNode *splay(Node *target = NULL) {\n\t\t\twhile (fa != target) {\n\t\t\t\tif (fa->fa == target) rotate();\n\t\t\t\telse if (fa->relation() == relation()) fa->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {}\n\n\tNode *build(const char *begin, const char *end, Node *par) {\n\t\tif (begin > end) return NULL;\n\t\telse if (begin == end) return new Node(par, &root, *begin);\n\t\telse {\n\t\t\tconst char *mid = begin + (end - begin) / 2;\n\t\t\tNode *v = new Node(par, &root, *mid);\n\t\t\tv->c[0] = build(begin, mid - 1, v);\n\t\t\tv->c[1] = build(mid + 1, end, v);\n\t\t\tv->maintain();\n\t\t\treturn v;\n\t\t}\n\t}\n\n\tvoid buildBound(int x) {\n\t\tNode *v = root;\n\t\twhile (v->c[x]) v = v->c[x];\n\t\tv->c[x] = new Node(v, &root, 0);\n\t\tNode *u = v;\n\t\tdo {\n\t\t\tu->maintain();\n\t\t\tu = u->fa;\n\t\t} while (u);\n\t\tv->c[x]->splay();\n\t}\n\n\tvoid build(const char *begin, const char *end) {\n\t\troot = build(begin, end, NULL);\n\t\tbuildBound(0);\n\t\tbuildBound(1);\n\t}\n\n\tNode *select(int k) {\n\t\tint x = k + 1;\n\t\tNode *v = root;\n\t\twhile (x != v->lsize() + 1) {\n\t\t\tif (x <= v->lsize()) v = v->c[0];\n\t\t\telse x -= v->lsize() + 1, v = v->c[1];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *u = select(l - 1), *v = select(r + 1);\n\t\tu->splay();\n\t\tv->splay(u);\n\t\treturn v->c[0];\n\t}\n\n\tNode *insert(int pos, char val) {\n\t\tNode *u = select(pos), *v = select(pos + 1);\n\t\tu->splay();\n\t\tv->splay(u);\n\t\tv->c[0] = new Node(v, &root, val);\n\t\tNode *q = v->c[0];\n\t\tdo {\n\t\t\tq->maintain();\n\t\t\tq = q->fa;\n\t\t} while (q);\n\t\treturn v->c[0]->splay();\n\t}\n\n\tvoid modify(int pos, char val) {\n\t\tNode *v = select(pos);\n\t\tv->val = val;\n\t\tv->maintain();\n\t}\n\n\tunsigned long long query(int l, int r) {\n\t\treturn select(l, r)->hash;\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n} splay;\n\ninline int lcp(int a, int b) {\n\tint l = 0, r = std::min(splay.size() - a + 1, splay.size() - b + 1);\n\twhile (l != r) {\n\t\tint mid = l + (r - l) / 2 + 1;\n\t\tif (splay.query(a, a + mid - 1) == splay.query(b, b + mid - 1))\n\t\t\tl = mid;\n\t\telse\n\t\t\tr = mid - 1;\n\t}\n\treturn l;\n}\n\nchar s[MAX_N + 1];\n\nint main() {\n\tbase[0] = 1;\n\tfor (int i = 1; i <= MAX_N; i++) base[i] = base[i - 1] * BASE;\n\n\tscanf(\"%s\", s);\n\tint n = strlen(s);\n\tsplay.build(s, s + n - 1);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tchar cmd[2];\n\t\tscanf(\"%s\", cmd);\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tprintf(\"%d\\n\", lcp(a, b));\n\t\t} else if (cmd[0] == 'R') {\n\t\t\tint pos;\n\t\t\tchar val[2];\n\t\t\tscanf(\"%d %s\", &pos, val);\n\t\t\tsplay.modify(pos, val[0]);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tint pos;\n\t\t\tchar val[2];\n\t\t\tscanf(\"%d %s\", &pos, val);\n\t\t\tsplay.insert(pos, val[0]);\n\t\t}\n\t}\n\treturn 0;\n}\n```","tags":["Hash"],"categories":["OI"]},{"title":"「HNOI2008」GT考试 - DP，矩阵乘法，KMP","url":"%2Fbzoj1009%2F","content":"\n阿申准备报名参加GT考试，准考证号为 $ N $ 位数 $ X_1X_2 \\dots X_n (0 \\leq X_i \\leq 9) $，他不希望准考证号上出现不吉利的数字。他的不吉利数字 $ A_1A_2 \\dots A_m(0 \\leq A_i \\leq 9) $ 有 $ M $ 位，不出现是指 $ X_1X_2 \\dots X_n $ 中没有恰好一段等于 $ A_1 A_2 \\dots Am.  $， 特别地 $ A_1 $ 和 $ x_1 $ 可以为 $ 0 $\n\n<!--more-->\n\n# 题解\n\n首先这题数据范围非常可爱， $ 1 \\leq N \\leq 10 ^ 9, 1 \\leq m \\leq 20 $，这个数据范围会让人不自觉的想起矩乘。\n\n设 $ f(i, j) $ 表示已经确定了准考证号的前 $ i $ 位，在这 $ i $ 位的末尾出现了不吉利数字的 $ j $ 个。\n\n枚举 $ 0 \\sim 9 $ 转移，考虑在第 $ i + 1 $ 位上添上某一个数字，可能转移到 $ f(i + 1, j + 1), f(i + 1, \\text{next}[j] + 1), f(i + 1, \\text{next[next}[j]]) \\dots $。\n\n用语言来描述的话，就是新添加的这个数字可能会让最后的不吉利数字延长，或者让末位的某几位变为原来出现的连续不吉利数字的前缀。\n\n其实这个东西随便暴力啦，毕竟 $ m $ 只有 $ 20 $。。\n\n剩下的事情就是构造转移矩阵了，由于每次转移只和 $ j $ 有关，所以可以轻松预处理转移矩阵。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAX_N = 1e9;\nconst int MAX_M = 20;\n\nstruct Matrix {\n\tint a[MAX_M + 5][MAX_M + 5];\n\tint n, m;\n\n\tMatrix(int n, int m, bool unit = false) {\n\t\tthis->n = n;\n\t\tthis->m = m;\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) {\n\t\t\tfor (int i = 0; i <= n; i++) a[i][i] = 1;\n\t\t}\n\t}\n};\n\nint n, m, mod;\nchar s[MAX_M + 1];\nint next[MAX_M + 1];\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(a.n, b.m, false);\n\tfor (int i = 0; i < a.n; i++) {\n\t\tfor (int j = 0; j < b.m; j++) {\n\t\t\tfor (int k = 0; k < a.m; k++) {\n\t\t\t\t(res.a[i][j] += a.a[i][k] * b.a[k][j]) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(a.n, a.n, true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\ninline void getNext() {\n\tint j = 0;\n\tfor (int i = 2; i <= m; i++) {\n\t\twhile (j > 0 && s[j + 1] != s[i]) j = next[j];\n\t\tif (s[j + 1] == s[i]) j++;\n\t\tnext[i] = j;\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &mod);\n\tscanf(\"%s\", s + 1);\n\tgetNext();\n\n\tMatrix shift(m, m, false);\n\tMatrix origin(m, 1, false);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j <= 9; j++) {\n\t\t\tint k = i;\n\t\t\twhile (k > 0 && s[k + 1] - '0' != j) k = next[k];\n\t\t\tif (s[k + 1] - '0' == j) k++;\n\t\t\t(shift.a[k][i] += 1) %= mod;\n\t\t}\n\t}\n\n\torigin.a[0][0] = 1;\n\tMatrix res = pow(shift, n) * origin;\n\n\tint ans = 0;\n\tfor (int i = 0; i < m; i++) (ans += res.a[i][0]) %= mod;\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","tags":["矩阵乘法"],"categories":["OI"]},{"title":"英雄难度「卡拉赞之夜」通关记","url":"%2FHearthStone-Karazhan%2F","content":"\n团长通关卡拉赞辣！\n\n![Over](/img/Karazhan/Over.PNG)\n\n<!--more-->\n\n# 宴会厅\n\n## 镀银魔像&魔镜\n\n![镀银魔像&魔镜](/img/Karazhan/镀银魔像&魔镜.png)\n\n第一关镀银魔像，起手要找AOE，保证二费的时候能够清掉四个盘子，这里推荐前期AOE用复仇打击（如果带的话），因为对面抢血飞快，等到养奴隶主的时候如果复仇打击黄了就GG了。\n起手最好有小斧子，手里有解有过牌就很舒服。\n\n尽量能够尽早上奴隶主，奴隶主上去以后镀银魔像不怎么会主动来解，生一场奴隶主跟他耗就是。不过暴乱狂现在已经不能斩杀了，所以他对我来说是一个极高攻击力的嘲讽，哈哈。\n\n第二关能用奴隶战的原因主要是BOSS复制出来的随从全部是 $ 1/1 $，这套奴隶战一血的AOE能够很好的解决那些复制的小杂毛。\n\n魔镜手里还有不少法术的，他召出来的随从一般都是带法强的。BOSS的奥秘我记得有法反镜像和复制，复制不怕，复制进去的东西，像科学家哀绿和狗头一般我们都解的掉，注意不要复制到什么大法师就好了。我记得BOSS还有个安东尼达斯，要留解牌。镜像的话，这套卡组里面的随从好像没有什么复制到就崩盘的。。不过能试还是尽量试一下，毕竟对面场上多个暴乱狂你也不舒服。最讨厌的应该是法反，可能也和我过牌量不足有关，手里没有合适的能够破法反的法术，有好几次AOE或者斩杀这样的关键法术被反掉导致我重开。。\n\n这里要做一个补充说明，这套卡组并不是当时我用来通关的卡组，当时的卡组和现在的卡组的区别在于两张战斗怒火被我换成了一张凶暴猿猴一张腐肉食尸鬼，因为因为缺少过牌，所以我有几个回合只能靠右手第一张。。\n\n## 国际象棋\n\n象棋应该是我打的时间最长的一关，一开始看攻略，想不清楚就瞎打，卡关卡了几个小时。。那天真的是打吐了。说说我的体会吧。\n\n其实这关并不是很难，找一个比较好的起手，想清楚一点打得贪一点肯定能赢。\n\n我是用的网上说的那种「一费不下子，二费下一个，三费接城堡」的套路，然后四费下骑士，配合城堡吃掉主教，后面的就以清掉黑棋的场然后等皇后来为主。核心思想在于皇后在场的时候尽量多的让皇后抢血，因为后面你没有子了，而对面还有，还可以作弊。打不到脸的时候就输了。想的细一点，一回合想两回合的东西，别瞎打，就能过。\n\n# 歌剧院\n歌剧院，确实是非常戏剧性的一层。。\n\n## 朱丽叶\n\n![朱丽叶](/img/Karazhan/朱丽叶.png)\n\n这关其实我利用了一个AI上的缺陷，就是在朱丽叶场功比你高时一般不会主动解你的随从，所以两只复活的铠甲帮我把对面的几十点场功降到七点，带烈焰喷涌其实是因为我玩的比较晚没有奥冲，我们的任务就是要解决掉罗密欧这只两血随从。。\n\n## 大灰狼\n\n![大灰狼](/img/Karazhan/大灰狼.png)\n\n这一关赢得惊心动魄，我一开始就把三个慈祥的外婆破了，如果不是伊瑟拉给了我张苏醒那一局就打不过去了。总之这一关的BOSS的特点就是只有你手牌中的随从才是 $ 1/1/1 $，所有召唤出的东西，或者是从牌库中直接召唤的随从（比如亚煞极拉出来），都是原身材，所以我才有了用青玉的想法，不过前期BOSS铺的场到底怎么解决我也没想好。\n\n## 巫婆\n\n![巫婆](/img/Karazhan/巫婆.png)\n\n几乎是最简单的一关。。这一套是我上个月组起来在天梯上玩的猎人，本来想去看看战场是什么样子结果就打过了。一费雄斑虎二费土狼，很开心的是对面解不了土狼，然后被我土狼一脚一脚踢死了。。\n\n其实最简单的打法是用心火牧，起手翻倍心火，对面是怎么死的都不知道。。\n\n# 展览馆\n\n## 馆长\n\n![馆长](/img/Karazhan/馆长.png)\n\n这一关主要是馆长的嘲讽使得他的随从能够躲在后面输出。单说一费的尘魔就有很多职业解起来很麻烦，这个时候就要挑解场能力比较强的职业了。我比较推荐法师，这一关火冲的补刀真的特别特别好用。\n\n## 夜之魇\n\n没什么好说的，自动星界。全带大哥，跟他拼大哥就是了。我的牌表不是很壕就不放上来丢人了qwq。\n\n不过如果他第一个回合上大螺丝解了你的怪或者拍大表哥你还解不掉可能就GG了。。\n\n## 邪蹄\n\n![邪蹄](/img/Karazhan/邪蹄.png)\n\n我是加基森出了挺长时间以后才开始玩的。那个时候已经有可以摩擦邪蹄的「疯狂药水」了。\n\n起手找两张疯狂药水，你拉过来的粗鄙小鬼死了给你生小鬼还掉邪蹄的血。暗影狂乱白富美都可以带，反正是一个随随便便过的BOSS。\n\n# 上层塔\n\n## 埃兰之影\n\n![埃兰之影](/img/Karazhan/埃兰之影.png)\n\n多带点法术砸死他，好像也没什么可说的。享受蓝龙加成的快感吧！\n\n注意埃兰的那个全场打 $ 10 $ 的奥秘就好，不用随从打他，用法术轰他。\n\n而且这个BOSS有法反，注意一下就好。\n\n## 虚空幽龙\n\n![虚空幽龙](/img/Karazhan/虚空幽龙.png)\n\n把大屁股嘲讽放在右边，高攻击冲锋放在左边。可能是AI有问题，一费我在右边放了一个虚空行者，然后BOSS就和失了智一样，前四个回合什么都没干。。然后就被我碾压了。。\n\n## 营救麦迪文\n\n![营救麦迪文](/img/Karazhan/营救麦迪文.png)\n\n常见的思路，要么是王子出来接着斩了他，要么是法反掉扭曲虚空，还有就是克总转生城墙萨。这里我选择了这一套克苏恩牧。\n\n能赢的契机在于，我发现如果一费北婊，那么BOSS有很大的概率会上监工，这样二费奶一口前期就没有压力了，后期两个兜帽侍僧两个目光尊者两个奶泉足够把克苏恩叠到 $ 72 $ 攻了。\n\n不要控BOSS血，把她打到一血，让她的斧子不敢砍你的墙。\n\n贴一下当时斩杀王子的图，哈哈。\n\n![Kthun](/img/Karazhan/Kthun.PNG)\n\n![DeathOfPrinces](/img/Karazhan/DeathOfPrinces.PNG)","tags":["冒险模式"],"categories":["日常生活"]},{"title":"「HNOI2008」水平可见直线 - 计算几何，单调栈","url":"%2Fbzoj1007%2F","content":"\n有 $ n $ 条直线，在正无穷处往下看，如果一条直线的某一部分没有被其他任何直线覆盖，则我们认为这条直线是可见的，输出所有可见直线的编号。\n\n<!--more-->\n\n# 题解\n\n我先描述一下算法。\n\n首先对所有直线按照斜率从小到大，截距从大到小排序。然后把最小的两条斜率不想等的直线放到一个栈里，每次向栈中加入一条直线时检查即将加入的直线和栈顶直线的交点和栈顶直线和栈第二位直线的交点的位置关系，若新直线与栈顶直线的交点在栈顶直线和栈第二位直线的交点左边，则将栈顶元素弹出，若在右边，则将新直线入栈。最后栈中的直线就是答案。\n\n下面形象的解释一下它的正确性。\n\n首先，我们要维护的应该是一个下凸壳（就是说起来形象一点）。。\n\n假设这是栈中的两条直线，则 $ F $ 为栈顶直线，$ G $ 为栈第二位直线。绿色部分就是目前合法的下凸壳。\n\n![Original](/img/BZOJ1007/Original.png)\n\n现在插入直线 $ L $，交点在右侧，此时凸壳变成了蓝色部分，此时栈顶直线 $ F $ 已经变为不可见的，就把它出栈。\n\n![Left](/img/BZOJ1007/Left.png)\n\n若直线 $ L $ 和栈顶直线的交点在左侧，凸壳就变成下图状态，此时原栈顶直线仍然可见，则直接将直线 $ L $ 入栈。\n\n![Right](/img/BZOJ1007/Right.png)\n\n其实用语言来描述就是，排序以后保证栈顶元素下面的元素一定可以覆盖住它的一半，而只有一条斜率更大的直线才能覆盖住它的另一半，所以只需要检查新加入的斜率更大的直线是否能够完全覆盖未被覆盖的部分就可以了。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cfloat>\n#include <algorithm>\n\nconst int MAX_N = 50000;\nconst double EPS = 1e-8;\n\nstruct Line {\n\tdouble k, b;\n\tint id;\n\n\tbool operator<(const Line &other) const {\n\t\tif (fabs(k - other.k) < EPS) return b > other.b;\n\t\treturn k < other.k;\n\t}\n} l[MAX_N + 1];\n\nint n;\n\nint s[MAX_N + 1], top = 1;\nbool ans[MAX_N + 1];\n\ninline double calc(Line a, Line b) {\n\treturn (b.b - a.b) / (a.k - b.k);\n}\n\ninline void solve() {\n\tmemset(ans, 0, sizeof(ans));\n\tstd::sort(l + 1, l + n + 1);\n\ts[top] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (fabs(l[i].k - l[i - 1].k) < EPS) continue;\n\t\twhile (top > 1 && calc(l[i], l[s[top]]) <= calc(l[s[top]], l[s[top - 1]])) top--;\n\t\ts[++top] = i;\n\t}\n\tfor (int i = 1; i <= top; i++) {\n\t\tans[l[s[i]].id] = true;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (ans[i]) printf(\"%d \", i);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lf %lf\", &l[i].k, &l[i].b);\n\t\tl[i].id = i;\n\t}\n\tsolve();\n\treturn 0;\n}\n```\n","tags":["单调栈"],"categories":["OI"]},{"title":"「HNOI2008」神奇的国度 - 弦图染色","url":"%2Fbzoj1006%2F","content":"\n给定一个弦图，求其最小染色数。\n\n<!--more-->\n\n# 题解\n用最大势算法求出弦图的完美消除序列。由于弦图的团数等于其染色数，直接求出其团数即可。\n\n最大势算法详见代码。。\n\n具体的证明可以看 cdq 冬令营的讲课稿。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAX_N = 10000;\nconst int MAX_M = 1000000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint pos, label;\n\tbool vis;\n\n\tNode() : e(NULL), pos(-1), label(0), vis(false) {}\n} N[MAX_N + 1];\n\nstruct Edge {\n\tNode *fr, *to;\n\tEdge *ne;\n\n\tEdge(Node *fr, Node *to) : fr(fr), to(to), ne(fr->e) {}\n};\n\ninline void addEdge(int fr, int to) {\n\tN[fr].e = new Edge(&N[fr], &N[to]);\n\tN[to].e = new Edge(&N[to], &N[fr]);\n}\n\nstd::priority_queue< std::pair<int, Node *> > q;\n\nint n, m;\n\ninline int mcs() {\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tq.push(std::make_pair(0, &N[i]));\n\t}\n\n\tfor (int i = n; i >= 1; i--) {\n#ifdef DBG\n\t\tNode *u = q.top().second;\n#endif\n\n\t\twhile (q.top().second->vis) q.pop();\n\t\tNode *v = q.top().second;\n\t\tv->pos = i;\n\t\tv->vis = true;\n\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\tif (!e->to->vis) {\n\t\t\t\tq.push(std::make_pair(++e->to->label, e->to));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint sum = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->ne) {\n\t\t\tif (e->to->pos > N[i].pos) sum++;\n\t\t}\n\t\tans = std::max(ans, sum + 1);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\tprintf(\"%d\\n\", mcs());\n\treturn 0;\n}\n```","tags":["弦图染色"],"categories":["OI"]},{"title":"「HNOI2008」明明的烦恼 - prufer序列","url":"%2Fbzoj1005%2F","content":"\n给出标号为 $ 1 $ 到 $ N $ 的点，以及某些点最终的度数，允许在任意两点间连线，可产生多少棵度数满足要求的树？\n\n<!--more-->\n\n# 题解\n首先要知道一个叫「prufer序列」的东西。\n\n首先，从有标号无根树生成「prufer序列」的方法我就不瞎逼逼了。\n其次，一个「prufer序列」唯一对应一棵有标号无根树。\n再次，一棵 $ n $ 个节点的有标号无根树的「prufer序列」的长度为 $ n - 2 $，树中度为 $ d $ 的点在「prufer序列」中的出现次数是 $ d - 1 $。\n\n设一共有 $ k $个被限制度的点，$ d_i $ 为第 $ i $ 个节点的度，$ s = \\sum\\limits_{d_i \\neq -1} d_i $，表示被限制度的点在序列中出现了 $ s $ 次。\n\n考虑这些点的位置：\n$$\nC(n - 2, s)\\frac { s! } {\\prod\\limits_{d_i \\neq -1} (d_i - 1)!}\n$$\n\n对于序列中剩下的 $ n - 2 - s $ 个点，就可以随便放了，所以整体上就是\n\n$$\n\\frac {s!C(n - 2, s)(n - k) ^ {n - 2 - s}} {\\prod\\limits_{d_i \\neq -1}(d_i - 1)!}\n$$\n\n上式化简得:\n$$\n\\frac {(n - 2)!(n - k) ^ {n - 2 - s}} {(n - 2 - s)!\\prod\\limits_{d_i \\neq -1} (d_i - 1)!}\n$$\n\n代码不想贴了。。我羞耻的没有写高精度。。","tags":["prufer序列"],"categories":["OI"]},{"title":"「HNOI2008」Card - Burnside引理","url":"%2Fbzoj1004%2F","content":"\n把 $ n $ 张卡牌染成 $ a $ 张红色，$ b $ 张蓝色，$ c $ 张绿色。同时给定 $ m $ 种洗牌方法，求有多少种不同染色的方案数。两种染色方法相同当且仅当一种染色方法可以同过任意洗牌方式变成另一种。\n\n<!--more-->\n\n# 题解\n使用 Burnside 引理。\n\n染色集中的非等价染色数等于在置换群的每个置换作用下保持不变的着色之和的平均数。。懒得证了，组合数学上讲的还是很好的嘛。蛤蛤蛤团长就是这样的无耻。\n\n至于统计在每个置换群作用下保持不变的着色数，可以用一个 DP 解决。\n\n首先找出置换的循环节，这里这里只需要保证置换的循环节全部都是一种颜色就可以保证在这种置换的作用下染色保持不变了。不证明，YY一下发现它就是对的。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nconst int MAX_X = 20;\nconst int MAX_N = 60;\nconst int MAX_M = 60;\n\nint a, b, c, n, m, mod;\n\ninline int calc(int *map) {\n\tbool flag[MAX_M + 1] = { false };\n\tstd::vector<int> v;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x = 0;\n\t\tfor (int j = i; !flag[j]; j = map[j]) {\n\t\t\tflag[j] = true;\n\t\t\tx++;\n\t\t}\n\t\tif (x) v.push_back(x);\n\t}\n\n\tstatic int f[MAX_X + 1][MAX_X + 1][MAX_X + 1];\n\tmemset(f, 0, sizeof(f));\n\n\tf[0][0][0] = 1;\n\tfor (std::vector<int>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tfor (int i = a; i >= 0; i--) {\n\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\tfor (int k = c; k >= 0; k--) {\n\t\t\t\t\tif (i >= *it) (f[i][j][k] += f[i - *it][j][k]) %= mod;\n\t\t\t\t\tif (j >= *it) (f[i][j][k] += f[i][j - *it][k]) %= mod;\n\t\t\t\t\tif (k >= *it) (f[i][j][k] += f[i][j][k - *it]) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[a][b][c];\n}\n\ninline void exgcd(int a, int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(int x) {\n\tint g, r, y;\n\texgcd(x, mod, g, r, y);\n\treturn (r % mod + mod) % mod;\n}\n\nint main() {\n\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &m, &mod);\n\tn = a + b + c;\n\n\tstatic int map[MAX_N + 1];\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) scanf(\"%d\", &map[j]);\n\t\t(sum += calc(map)) %= mod;;\n\t}\n\tfor (int i = 1; i <= n; i++) map[i] = i;\n\t(sum += calc(map)) %= mod;\n\n\tint ans = sum * inv(m + 1) % mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n```","tags":["Burnside引理"],"categories":["OI"]},{"title":"「ZJOI2006」物流运输 - 最短路，DP","url":"%2Fbzoj1003%2F","content":"\n物流公司要把一批货物从码头A运到码头B。由于货物量比较大，需要 $ n $ 天才能运完。货物输过程中一般要转停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是修改路线是一件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个 $ n $ 天的运输计划，使得总成本尽可能地小。\n\n<!--more-->\n\n# 题解\n\n团长神智不清的时候盯着这题看了一节课。。结果发现自己看错题了。。\n\n缓过神来以后感觉还是很简单的。。\n\n首先预处理出 $ c_{i, j} $，意义是保证所有码头在第 $ i $ 天到第 $ j $ 天都可以运输货物的情况下不更换运输计划的最小运输费用，这个可以用最短路算法处理出来。\n\n设 $ f(i) $ 为第 $ i $ 天时的最小费用，那么有显然的转移：\n$$\nf(i) = \\min\\limits_{j = 1}^{i - 1} (f(i), f(j) + c_{j + 1, i} + k)\n$$\n\n其中 $ k $ 是改变一次运输计划带来的额外代价。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAX_N = 100 + 10;\nconst int MAX_M = 20 + 10;\nconst int MAX_E = MAX_M * MAX_M;\nconst int INF = 2e9;\n\nstruct Edge {\n\tint x, y, w;\n\tint ne;\n} e[MAX_E + 10];\nint v[MAX_M + 1], num;\n\ninline void put(int x, int y, int z) {\n\tnum++;\n\te[num].x = x, e[num].y = y, e[num].w = z;\n\te[num].ne = v[x], v[x] = num;\n}\n\nint n, m, k, tot;\nbool del[MAX_M + 1][MAX_N + 1], invalid[MAX_M + 1];\nint f[MAX_N + 1], cost[MAX_N + 1][MAX_N + 1];\n\nint dist[MAX_M + 1];\nbool inq[MAX_M + 1];\n\ninline int spfa() {\n\tstd::queue<int> q;\n\tmemset(inq, 0, sizeof(inq));\n//\tfor (int i = 1; i <= m; i++) dist[i] = INT_MAX;\n\tmemset(dist, 0x7f, sizeof(dist));\n\tdist[1] = 0;\n\tinq[1] = true;\n\n\twhile (!q.empty()) q.pop();\n\tq.push(1);\n\n\twhile (!q.empty()) {\n\t\tint x = q.front();\n\t\tq.pop();\n\t\tinq[x] = false;\n\n\t\tfor (int i = v[x]; i; i = e[i].ne) {\n\t\t\tint y = e[i].y;\n\t\t\tif (!invalid[y] && dist[y] > dist[x] + e[i].w) {\n\t\t\t\tdist[y] = dist[x] + e[i].w;\n\t\t\t\tif (!inq[y]) {\n\t\t\t\t\tinq[y] = true;\n\t\t\t\t\tq.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dist[m];\n}\n\nint main() {\n\tscanf(\"%d %d %d %d\", &n, &m, &k, &tot);\n\tfor (int i = 1; i <= tot; i++) {\n\t\tint x, y, z;\n\t\tscanf(\"%d %d %d\", &x, &y, &z);\n\t\tput(x, y, z);\n\t\tput(y, x, z);\n\t}\n\n\tint d;\n\tscanf(\"%d\", &d);\n\tfor (int i = 1; i <= d; i++) {\n\t\tint p, a, b;\n\t\tscanf(\"%d %d %d\", &p, &a, &b);\n\t\tfor (int j = a; j <= b; j++) {\n\t\t\tdel[p][j] = true;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i; j <= n; j++) {\n\t\t\tmemset(invalid, 0, sizeof(invalid));\n\t\t\tfor (int k = 1; k <= m; k++)\n\t\t\t\tfor (int a = i; a <= j; a++)\n\t\t\t\t\tinvalid[k] |= del[k][a];\n\t\t\tcost[i][j] = spfa();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i; j <= n; j++) {\n\t\t\tif (cost[i][j] < INF) cost[i][j] *= (j - i + 1);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) f[i] = cost[1][i];\n\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tf[i] = std::min(f[i], f[j] + cost[j + 1][i] + k);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[n]);\n\treturn 0;\n}\n```","tags":["最短路"],"categories":["OI"]},{"title":"「HNOI2017」单旋 - LCT","url":"%2Fhnoi2017-spaly%2F","content":"\n题目要求你维护一棵 `Spaly`，也就是单旋 `splay`。\n\n并支持:\n\n1. 单旋最大值\n2. 单旋最小值\n3. 删除最大值\n4. 删除最小值\n5. 插入一个值\n\n对于前四种操作，输出最大或最小值所在的深度，对于最后一种操作，输出插入后该节点的深度。\n\n关于单旋的定义详见题目描述。\n\n<!--more-->\n\n# 题解\n\n首先，写一棵 `spaly` 显然不符合题目要求。\n\n我们发现，由于本题只会单旋最大值或者最小值，结合单旋的优秀（暴力）性质，可以发现这棵树的形态只会发生非常少的变化。\n\n对于插入操作，可以证明对于一个值，如果它在 `spaly` 中同时具有前驱和后继，那么前驱和后继对应书中的节点一定是父子关系，这时候只需要插入到深度较大的点的下面就可以了。这个新插入的节点一定会变成前驱的右儿子或者后继的左儿子。没有前驱或者没有后继的话就有哪个往哪个插。\n\n单旋操作，这里以单旋最小值为例。在树中只会使得最小值的右子树变成其父节点的左子树，并让原来的根节点变成它的右子树。单旋最大值类似，总之 YY 一下就好了。\n\n这样想的话直接用 LCT 维护一下就好了，还有一种维护 dfs序 和 深度 的做法，我太弱了只会 LCT。\n\n# 代码\n\n好蠢的代码，只是懒得重构了。\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <set>\n#include <algorithm>\n\nconst int MAX_N = 100000;\nconst int MAX_VAL = 1e9;\n\nstruct Spaly {\n\tstruct Node {\n\t\tNode *fa, *c[2], *pathFa;\n\t\tNode *lc, *rc, *par;\n\t\tint size;\n\n\t\tNode() : fa(NULL), pathFa(NULL), lc(NULL), rc(NULL), par(NULL), size(1) { c[0] = c[1] = NULL; }\n\n\t\tvoid maintain() {\n\t\t\tsize = (c[0] ? c[0]->size : 0) + (c[1] ? c[1]->size : 0) + 1;\n\t\t}\n\n\t\tint relation() {\n\t\t\treturn this == fa->c[1];\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tNode *old = fa;\n\t\t\tint x = relation();\n\n\t\t\tstd::swap(fa->pathFa, pathFa);\n\n\t\t\tfa = old->fa;\n\t\t\tif (old->fa) old->fa->c[old->relation()] = this;\n\n\t\t\told->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->fa = old;\n\n\t\t\tc[x ^ 1] = old;\n\t\t\told->fa = this;\n\n\t\t\told->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (fa) {\n\t\t\t\tif (!fa->fa) rotate();\n\t\t\t\telse if (fa->relation() == relation()) fa->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\n\t\t\tif (c[1]) {\n\t\t\t\tstd::swap(c[1]->fa, c[1]->pathFa);\n\t\t\t\tc[1] = NULL;\n\t\t\t}\n\n\t\t\tmaintain();\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\n\t\t\tif (!pathFa) return false;\n\n\t\t\tpathFa->expose();\n\t\t\tpathFa->c[1] = this;\n\t\t\tstd::swap(fa, pathFa);\n\t\t\tfa->maintain();\n\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tint depth() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn size;\n\t\t}\n\t} N[MAX_N], *root;\n\n\tvoid link(Node *u, Node *par) {\n\t\tu->access();\n\t\tu->splay();\n\t\tu->pathFa = par;\n\t}\n\n\tvoid cut(Node *u) {\n\t\tu->access();\n\t\tu->splay();\n\t\tif (u->c[0]) u->c[0]->fa = NULL;\n\t\tu->c[0] = NULL;\n\t}\n\n/*\tNode *findRoot(Node *v) {\n\t\tv->access();\n\t\tv->splay();\n\t\twhile (v->c[0]) v = v->c[0];\n\t\treturn v;\n\t} */\n} spaly;\n\nint _end = 0;\n\nstruct SetNode {\n\tint val;\n\tSpaly::Node *v;\n\n\tSetNode(int val, Spaly::Node *v) : val(val), v(v) {}\n\n\tbool operator<(const SetNode &other) const {\n\t\treturn val < other.val;\n\t}\n};\n\nstd::set<SetNode> set;\n\ninline int spalyMax() {\n\tstd::set<SetNode>::const_iterator it = set.end();\n\tit--;\n\tint ans = it->v->depth();\n\tif (ans == 1) return ans;\n\tif (it->v->lc && it->v->par) {\n//\t\tSpaly::Node *spaly.root = spaly.findRoot(it->v);\n\t\tspaly.cut(it->v->lc);\n\t\tspaly.cut(it->v);\n\t\tspaly.link(it->v->lc, it->v->par);\n\n\t\tit->v->par->rc = it->v->lc;\n\t\tit->v->lc->par = it->v->par;\n\t\tit->v->lc = NULL;\n\t\tit->v->par = NULL;\n\n\t\tspaly.link(spaly.root, it->v);\n\t\tit->v->lc = spaly.root;\n\t\tspaly.root->par = it->v;\n\t} else if (it->v->par) {\n//\t\tSpaly::Node *spaly.root = spaly.findRoot(it->v);\n\t\tspaly.cut(it->v);\n\t\tit->v->par->rc = NULL;\n\t\tit->v->par = NULL;\n\n\t\tspaly.link(spaly.root, it->v);\n\t\tspaly.root->par = it->v;\n\t\tit->v->lc = spaly.root;\n\t}\n\tspaly.root = it->v;\n\treturn ans;\n}\n\ninline int spalyMin() {\n\tstd::set<SetNode>::const_iterator it = set.begin();\n\tint ans = it->v->depth();\n\tif (ans == 1) return ans;\n\tif (it->v->rc && it->v->par) {\n//\t\tSpaly::Node *spaly.root = spaly.findRoot(it->v);\n\t\tspaly.cut(it->v->rc);\n\t\tspaly.cut(it->v);\n\t\tspaly.link(it->v->rc, it->v->par);\n\n\t\tit->v->rc->par = it->v->par;\n\t\tit->v->par->lc = it->v->rc;\n\t\tit->v->rc = NULL;\n\t\tit->v->par = NULL;\n\n\t\tspaly.link(spaly.root, it->v);\n\t\tspaly.root->par = it->v;\n\t\tit->v->rc = spaly.root;\n\t} else if (it->v->par) {\n//\t\tSpaly::Node *spaly.root = spaly.findRoot(it->v);\n\t\tspaly.cut(it->v);\n\t\tit->v->par->lc = NULL;\n\t\tit->v->par = NULL;\n\n\t\tspaly.link(spaly.root, it->v);\n\t\tspaly.root->par = it->v;\n\t\tit->v->rc = spaly.root;\n\t}\n\tspaly.root = it->v;\n\treturn ans;\n}\n\ninline int delMax() {\n\tstd::set<SetNode>::const_iterator it = set.end();\n\tit--;\n\tint ans = spalyMax();\n\tif (it->v->lc) spaly.cut(it->v->lc), it->v->lc->par = NULL, spaly.root = it->v->lc;\n\tset.erase(it);\n\treturn ans;\n}\n\ninline int delMin() {\n\tstd::set<SetNode>::const_iterator it = set.begin();\n\tint ans = spalyMin();\n\tif (it->v->rc) spaly.cut(it->v->rc), it->v->rc->par = NULL, spaly.root = it->v->rc;\n\tset.erase(it);\n\treturn ans;\n}\n\ninline int insert(int val) {\n\tSetNode v(val, &spaly.N[_end++]);\n\tif (set.empty()) return set.insert(v), spaly.root = v.v, 1;\n\tstd::set<SetNode>::const_iterator suc = set.lower_bound(v), pre = suc;\n\tif (suc == set.end()) {\n\t\tpre--;\n\t\tspaly.link(v.v, pre->v);\n\t\tv.v->par = pre->v;\n\t\tpre->v->rc = v.v;\n\t} else if (suc == set.begin()) {\n\t\tspaly.link(v.v, suc->v);\n\t\tv.v->par = suc->v;\n\t\tsuc->v->lc = v.v;\n\t} else {\n\t\tpre--;\n\t\tif (pre->v->depth() > suc->v->depth()) {\n\t\t\tspaly.link(v.v, pre->v);\n\t\t\tv.v->par = pre->v;\n\t\t\tpre->v->rc = v.v;\n\t\t} else {\n\t\t\tspaly.link(v.v, suc->v);\n\t\t\tv.v->par = suc->v;\n\t\t\tsuc->v->lc = v.v;\n\t\t}\n\t}\n\tset.insert(v);\n\treturn v.v->depth();\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint key;\n\t\t\tscanf(\"%d\", &key);\n\t\t\tprintf(\"%d\\n\", insert(key));\n\t\t} else if (cmd == 2) {\n\t\t\tprintf(\"%d\\n\", spalyMin());\n\t\t} else if (cmd == 3) {\n\t\t\tprintf(\"%d\\n\", spalyMax());\n\t\t} else if (cmd == 4) {\n\t\t\tprintf(\"%d\\n\", delMin());\n\t\t} else if (cmd == 5) {\n\t\t\tprintf(\"%d\\n\", delMax());\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","tags":["LCT"],"categories":["OI"]},{"title":"「BeiJing2006」狼爪兔子 - 平面图最小割","url":"%2Frabbit%2F","content":"\n![](http://www.lydsy.com/JudgeOnline/images/1001.jpg)\n给定这种形式的一个图，求其最大流。\n\n<!--more-->\n\n# 题解\n据 Hellc 说，直接 `dinic` 就可以了，但是我没写，认真学习了一下正解，「平面图最大流」。\n\n论文东西太多了，我转述也转述不清，详情见 [《两极相通 —— 浅析最大最小定理在信息学竞赛中的应用》](https://wenku.baidu.com/view/5a7df375a417866fb84a8e54.html)，写的很好很形象。\n\n# 代码\n\n注意只有一行或者只有一列时的特判。\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <queue>\n#include <algorithm>\n#include <functional>\n\nconst int MAX_N = 1000;\nconst int MAX_M = 1000;\nconst int MAX_NODE = MAX_N * MAX_M * 2 + 2;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint dist;\n\tbool vis;\n} N[MAX_NODE];\n\nstruct Edge {\n\tNode *fr, *to;\n\tEdge *ne;\n\tint w;\n\n\tEdge(Node *fr, Node *to, int w) : fr(fr), to(to), ne(fr->e), w(w) {}\n};\n\ninline void addEdge(int fr, int to, int w) {\n\tN[fr].e = new Edge(&N[fr], &N[to], w);\n\tN[to].e = new Edge(&N[to], &N[fr], w);\n}\n\ninline int djk(int begin, int end, int n) {\n\tNode *s = &N[begin], *t = &N[end];\n\tstd::priority_queue< std::pair<int, Node *>, std::vector< std::pair<int, Node *> >, std::greater< std::pair<int, Node *> > > q;\n\tfor (int i = 0; i < n; i++) N[i].dist = INT_MAX, N[i].vis = false;\n\n\ts->dist = 0;\n\tq.push(std::make_pair(s->dist, s));\n\twhile (!q.empty()) {\n\t\tNode *v = q.top().second;\n\t\tq.pop();\n\n\t\tif (v->vis) continue;\n\t\tv->vis = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\tif (e->to->dist > v->dist + e->w) {\n\t\t\t\te->to->dist = v->dist + e->w;\n\t\t\t\tq.push(std::make_pair(e->to->dist, e->to));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t->dist;\n}\n\nint n, m;\n\ninline int id(int i, int j) {\n\treturn (i - 1) * 2 * (m - 1) + j;\n}\n\ninline int solve() {\n\tif (n == 1 && m == 1) return 0;\n\telse if (n == 1) {\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 0; i < m - 1; i++) {\n\t\t\tint w;\n\t\t\tscanf(\"%d\", &w);\n\t\t\tans = std::min(ans, w);\n\t\t}\n\t\treturn ans;\n\t} else if (m == 1) {\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint w;\n\t\t\tscanf(\"%d\", &w);\n\t\t\tans = std::min(ans, w);\n\t\t}\n\t\treturn ans;\n\t}\n\n\tint s = 2 * (m - 1) * (n - 1), t = s + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < m - 1; j++) {\n\t\t\tint w;\n\t\t\tscanf(\"%d\", &w);\n\t\t\tif (i == 1) {\n\t\t\t\taddEdge(id(i, (j * 2) ^ 1), t, w);\n\t\t\t} else if (i == n) {\n\t\t\t\taddEdge(s, id(i - 1, j * 2), w);\n\t\t\t} else {\n\t\t\t\taddEdge(id(i, (j * 2) ^ 1), id(i - 1, j * 2), w);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint w;\n\t\t\tscanf(\"%d\", &w);\n\t\t\tif (j == 0) {\n\t\t\t\taddEdge(s, id(i, j * 2), w);\n\t\t\t} else if (j == m - 1) {\n\t\t\t\taddEdge(id(i, ((j - 1) * 2) ^ 1), t, w);\n\t\t\t} else {\n\t\t\t\taddEdge(id(i, ((j - 1) * 2) ^ 1), id(i, (j * 2)), w);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j < m - 1; j++) {\n\t\t\tint w;\n\t\t\tscanf(\"%d\", &w);\n\t\t\taddEdge(id(i, j * 2), id(i, (j * 2) ^ 1), w);\n\t\t}\n\t}\n\n\treturn djk(s, t, t + 1);\n}\n\nint main() {\n//\tfreopen(\"bjrabbit.in\", \"r\", stdin), freopen(\"bjrabbit.out\", \"w\", stdout);\n\tscanf(\"%d %d\", &n, &m);\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}\n```","tags":["最段路"]},{"title":"「SDOI2017」相关分析 - 线段树","url":"%2FSDOI2017Round1Day2T3%2F","content":"\n# 题目描述\nFrank 对天文学非常感兴趣，他经常用望远镜看星星， 同时记录下它们的信息，比如亮度、颜色等等，进而估算出星星的距离、半径等等。\n\nFrank 不仅喜欢观测，还喜欢分析观测到的数据。他经常分析两个参数之间 （比如亮度和半径） 是否存在某种关系。\n\n现在 Frank 要分析参数 $ X $ 与 $ Y $ 之间的关系。他有 $ n $ 组观测数据，第 $ i $ 组观测数据记录了 $ x_i $ 和 $ y_i $。他需耍进行以下几种操作：\n\n* $ \\texttt{1 L R} $  \n    用直线拟合第 $ L $ 组到第 $ R $ 组观测数据。用 $ \\bar x $ 表示这些观测数据中 $ x $ 的平均数，用 $ \\bar y $ 表示这些观测数据中 $ y $ 的平均数，即\n\n    $$\n    \\begin{aligned}\n    \\bar{x} &= \\frac{1}{R - L + 1} \\sum\\limits_{i = L} ^ R x_i \\\\\n    \\bar{y} &= \\frac{1}{R - L + 1} \\sum\\limits_{i = L} ^ R y_i\n    \\end{aligned}\n    $$\n\n    如果直线方程是 $ y = ax + b $，那么 $ a $、$ b $ 应该这样计算：\n\n    $$\n    \\begin{aligned}\n    a &= \\frac{\\sum\\limits_{i = L} ^ R (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum\\limits_{i = L} ^ R (x_i - \\bar{x}) ^ 2} \\\\\n    b &= \\bar{y} - a \\bar{x}\n    \\end{aligned}\n    $$\n\n    你需要帮助 Frank 计算 $ a $。\n* $ \\texttt{2 L R S T} $  \n    Frank 发现测量第 $ L $ 组到第 $ R $ 组数据时有误差，对于每个 $ i $ 满足 $ L \\leq i \\leq R $，$ x_i $ 需要加上 $ S $，$ y_i $ 需要加上 $ T $。\n* $ \\texttt{3 L R S T} $  \n    Frank 发现第 $ L $ 组到第 $ R $ 组数据需要修改，对于每个 $ i $ 满足 $ L \\leq i \\leq R $，$ x_i $ 需要修改为 $ (S + i) $，$ y_i $ 需要修改为 $ (T + i) $。\n    \n<!--more-->\n    \n    \n# 题解\n展开上式，发现只需维护区间 $ x_i, y_i, x_iy_i, x_i^2 $，就可以回答上述问题。\n\n对于修改操作 $ 2 $，线段树区间修改随便搞，对于操作 $ 3 $ 由于给定的 $ S $ 和 $ T $ 可能为 $ 0 $，所以需要一定奇技淫巧来标记该区间有无被复制。\n\n线段树节点切勿忘记开 `double`。。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#define double long double\n\ntypedef long long ll;\n\nconst int MAX_N = 100000;\n\ndouble x[MAX_N + 1], y[MAX_N + 1];\ndouble sum[MAX_N + 1], sum2[MAX_N + 1];\n\ninline void prepare() {\n\tsum[0] = 0, sum2[0] = 0;\n\tfor (int i = 1; i <= MAX_N; i++) {\n\t\tsum[i] = sum[i - 1] + i;\n\t\tsum2[i] = sum2[i - 1] + (double)i * i;\n\t}\n}\n\ninline double calc(int l, int r) {\n\treturn sum[r] - sum[l - 1];\n}\n\ninline double calc2(int l, int r) {\n\treturn sum2[r] - sum2[l - 1];\n}\n\nstruct Segt {\n\tint l, r;\n\tSegt *lc, *rc;\n\tdouble sx, sy, sxy, sxx;\n\tdouble tags, tagt;\n\tdouble cs, ct;\n\tbool changed;\n\t\n\tSegt(int l, int r, Segt *lc, Segt *rc) : l(l), r(r), lc(lc), rc(rc), \n\t\tsx(lc->sx + rc->sx), sy(lc->sy + rc->sy),\n\t\t\tsxy(lc->sxy + rc->sxy), sxx(lc->sxx + rc->sxx), tags(0), tagt(0), \n\t\t\t\tcs(0), ct(0), changed(false) {}\n\tSegt(int l, int r, Segt *lc, Segt *rc, double sx, double sy) : \n\t\tl(l), r(r), lc(lc), rc(rc), sx(sx), sy(sy), sxy(sx * sy), sxx(sx * sx), \n\t\t\ttags(0), tagt(0), cs(0), ct(0), changed(false) {}\n\t\n\tdouble querysx(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sx;\n\t\telse return pushDown(), lc->querysx(l, r) + rc->querysx(l, r);\n\t}\n\t\n\tdouble querysy(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sy;\n\t\telse return pushDown(), lc->querysy(l, r) + rc->querysy(l, r);\n\t}\n\t\n\tdouble querysxy(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sxy;\n\t\telse return pushDown(), lc->querysxy(l, r) + rc->querysxy(l, r);\n\t}\n\t\n\tdouble querysxx(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sxx;\n\t\telse return pushDown(), lc->querysxx(l, r) + rc->querysxx(l, r);\n\t}\n\n\tvoid validate() {\n\t\tdouble sx, sy, sxy, sxx;\n\t\tsx = this->sx;\n\t\tsy = this->sy;\n\t\tsxy = this->sxy;\n\t\tsxx = this->sxx;\n\n\t\tprintf(\"Segt, sx : %lld, sy : %lld, sxy : %lld, sxx : %lld\\n\", (long long)sx, (long long)sy, (long long)sxy, (long long)sxx);\n\n\t\tsx = 0, sy = 0, sxy = 0, sxx = 0;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tsx += x[i];\n\t\t\tsy += y[i];\n\t\t\tsxy += (long long)x[i] * y[i];\n\t\t\tsxx += (long long)x[i] * x[i];\n\t\t}\n\n\t\tprintf(\"Force, sx : %lld, sy : %lld, sxy : %lld, sxx : %lld\\n\", (long long)sx, (long long)sy, (long long)sxy, (long long)sxx);\n\t}\n\t\n\tvoid add(double s, double t) {\n\t\tsxy = sxy + sx * t + sy * s + s * t * (this->r - this->l + 1);\n\t\tsxx = sxx + s * s * (this->r - this->l + 1) + 2 * sx * s;\n\t\tsx += s * (this->r - this->l + 1);\n\t\tsy += t * (this->r - this->l + 1);\n\t\ttags += s;\n\t\ttagt += t;\n\n//\t\tvalidate();\n\t}\n\n\tvoid change(double s, double t) {\n\t\tdouble sump = calc(l, r), sumq = calc2(l, r);\n\t\ttags = 0, tagt = 0;\n\t\tint len = r - l + 1;\n\t\tsx = len * s + sump;\n\t\tsy = len * t + sump;\n\t\tsxy = len * s * t + sump * (s + t) + sumq;\n\t\tsxx = s * s * len + sumq + 2 * s * sump;\n\t\tcs = s, ct = t;\n\t\tchanged = true;\n\n//\t\tvalidate();\n\t}\n\t\n\tvoid maintain() {\n\t\tsx = lc->sx + rc->sx;\n\t\tsy = lc->sy + rc->sy;\n\t\tsxy = lc->sxy + rc->sxy;\n\t\tsxx = lc->sxx + rc->sxx;\n\t}\n\t\n\tvoid pushDown() {\n\t\tif (changed) {\n\t\t\tlc->change(cs, ct);\n\t\t\trc->change(cs, ct);\n\t\t\t\n\t\t\tchanged = false;\n\t\t}\n\t\tif (tags != 0 || tagt != 0) {\n\t\t\tlc->add(tags, tagt);\n\t\t\trc->add(tags, tagt);\n\t\t\t\n\t\t\ttags = 0, tagt = 0;\n\t\t}\n\t}\n\t\n\tvoid modify2(int l, int r, int s, int t) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) add(s, t);\n\t\telse pushDown(), lc->modify2(l, r, s, t), rc->modify2(l, r, s, t), maintain();\n\t}\n\t\n\tvoid change(int l, int r, int s, int t) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) change(s, t);\n\t\telse pushDown(), lc->change(l, r, s, t), rc->change(l, r, s, t), maintain();\n\t}\n\t\n\tstatic Segt *build(int l, int r) {\n\t\tif (l == r) {\n\t\t\treturn new Segt(l, r, NULL, NULL, x[l], y[l]);\n\t\t} else {\n\t\t\tint mid = l + (r - l) / 2;\n\t\t\treturn new Segt(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segt;\n\ninline void query(int l, int r) {\n\tdouble sxy = segt->querysxy(l, r);\n\tdouble sx = segt->querysx(l, r);\n\tdouble sy = segt->querysy(l, r);\n\tdouble sxx = segt->querysxx(l, r);\n\tdouble xa = (double)sx / (double)(r - l + 1);\n\tdouble ya = (double)sy / (double)(r - l + 1);\n\tdouble up = sxy - (double)sx * ya - (double)sy * xa + xa * ya * (double)(r - l + 1);\n\tdouble down = sxx + xa * xa * (double)(r - l + 1) - 2 * sx * xa;\n\tdouble ans = up / down;\n\tprintf(\"%.10Lf\\n\", ans);\n}\n\ninline void modify2(int l, int r, double s, double t) {\n\tfor (int i = l; i <= r; i++) {\n\t\tx[i] += s, y[i] += t;\n\t}\n}\n\ninline void change(int l, int r, double s, double t) {\n\tfor (int i = l; i <= r; i++) {\n\t\tx[i] = s + i, y[i] = t + i;\n\t}\n}\n\nint main() {\n\tfreopen(\"relative.in\", \"r\", stdin);\n\tfreopen(\"relative.out\", \"w\", stdout);\n\tint n, m;\n\tprepare();\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%Lf\", &x[i]);\n\tfor (int i = 1; i <= n; i++) scanf(\"%Lf\", &y[i]);\n\t\n\tsegt = Segt::build(1, n);\n\t\n\tfor (int i = 1; i <= m; i++) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tquery(l, r);\n\t\t} else if (cmd == 2) {\n\t\t\tint l, r, s, t;\n\t\t\tscanf(\"%d %d %d %d\", &l, &r, &s, &t);\n//\t\t\tmodify2(l, r, s, t);\n\t\t\tsegt->modify2(l, r, s, t);\n\t\t} else if (cmd == 3) {\n\t\t\tint l, r, s, t;\n\t\t\tscanf(\"%d %d %d %d\", &l, &r, &s, &t);\n//\t\t\tchange(l, r, s, t);\n\t\t\tsegt->change(l, r, s, t);\n\t\t}\n\t}\n\t\n\tfclose(stdin), fclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n","tags":["线段树"],"categories":["OI"]},{"title":"「SDOI2017」硬币游戏 - KMP，高斯消元","url":"%2Fsdoi2017-game%2F","content":"\n周末同学们非常无聊，有人提议，咱们扔硬币玩吧，谁扔的硬币正面次数多谁胜利。\n\n大家纷纷觉得这个游戏非常符合同学们的特色，但只是扔硬币实在是太单调了。\n\n同学们觉得要加强趣味性，所以要找一个同学扔很多很多次硬币，其他同学记录下正反面情况。\n\n用 $ \\texttt{H} $ 表示正面朝上， 用 $ \\texttt{T} $ 表示反面朝上，扔很多次硬币后，会得到一个硬币序列。比如 $ \\texttt{HTT} $ 表示第一次正面朝上，后两次反面朝上。\n\n但扔到什么时候停止呢？大家提议，选出 $ n $ 个同学， 每个同学猜一个长度为 $ m $ 的序列，当某一个同学猜的序列在硬币序列中出现时，就不再扔硬币了，并且这个同学胜利。为了保证只有一个同学胜利，同学们猜的 $ n $ 个序列两两不同。\n\n很快，$ n $个同学猜好序列，然后进入了紧张而又刺激的扔硬币环节。你想知道，如果硬币正反面朝上的概率相同，每个同学胜利的概率是多少。\n\n<!--more-->\n\n# 题解\n哎呀好气呀，又到了团长看着就恶心的概率题辣。。\n\nmmp，我在场上的时候真的是连样例都没有看懂啊。但是概率的题能看懂样例就有鬼啦。。\n\n当时感觉可能是AC自动机上dp什么的。。但是最后这个部分分也没有想出来。。\n\n好吧团长要正儿八经地写题解了。。\n\n设 $ P(S) $ 为到达一个可能的硬币序列 $ S $ 的概率，特别的，若某位同学为 $ A $，或者你乐意叫他张三李四王五都可以，那么 $ P(A) $ 为同学 $ A $ 胜利的概率。\n\n设一个状态 $ N $ 为一个硬币序列，这个硬币序列中的任意子串不会使得任意玩家胜利，那么现在若在 $ N $ 后面接上玩家 $ A $ 的硬币序列，玩家 $ A $ 就可能胜利。\n\n为什么是可能胜利呢？考虑一个玩家 $ A $ 的硬币序列为 `TTH`，玩家 $ B $ 的硬币序列为 `HTT` 这样如果状态 $ N $ 的末尾为 `H` 那么在后面加上 `TT` 后玩家 $ B $ 胜利，在这种情况下再加上 `H` 得到 $ N $ 后面接 $ A $ 硬币序列的情况，若 $ N $ 末尾为 `HT` 那么加上 `T` 后玩家 $ B $ 胜利，再接上 `TH` 后得到要求的合法情况。\n\n这种情况只会出现在玩家 $ A $ 的硬币序列的某个前缀是玩家 $ B $ 硬币序列的某个后缀的情况。\n\n假设只有这两个玩家，那么一个方程是显然的：\n$$\nP(N + A) = P(A) + 0.75P(B)\n$$\n\n尝试把这种情况拓展一下，对于两个任意的玩家 $ A, B $，计算出所有 $ A $ 的硬币序列的前缀是 $ B $ 的硬币序列的后缀的长度 $ k $，那么由 $ P(B) $ 达到到 $ P(N + A) $ 的概率应该是：\n$$\n\\sum\\limits_{k} \\frac {1} {2 ^ {m - k}}\n$$\n\n这个式子可以用 KMP 处理出来。\n\n对于第 $ i $ 个玩家和第 $ j $ 个玩家，我们记上面的式子为 $ Q_{i, j} $\n\n设 $ P(N) $ 为 $ x_0 $，某个玩家 $ i $ 胜利的概率为 $ x_i $，那么这样可以列出 $ n $ 个方程，第 $ i $ 个方程的形式如下：\n$$\nx_i + \\sum\\limits_{j = 1}^{n} Q_{i, j} = \\frac {1} {2 ^ m}x_0\n$$\n\n但是这样有一个问题，现在已经列出 $ n $ 个方程，但是加上变量 $ x_0 $ 一共有 $ n + 1 $ 变量，所以我们需要第 $ n + 1 $ 个方程。\n\n由于所有玩家胜利的概率之和是 $ 1 $，所以第 $ n + 1 $ 个方程是显然的：\n$$\n\\sum\\limits_{i = 1}^{n} x_i = 1\n$$\n\n# 代码\n\n咸鱼团长第 $ n $ 次学习高斯消元。。\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <cstdlib>\n#include <cmath>\n#include <cfloat>\n#include <algorithm>\n\nconst int MAX_N = 300 + 5;\nconst int MAX_M = 300 + 5;\nconst long double EPS = 1e-10;\n\nint n, m, fail[MAX_N][MAX_M];\nlong double pows[MAX_M], a[MAX_N][MAX_M];\nchar s[MAX_N][MAX_N];\n\ninline long double check(int x, int y) {\n\tlong double res = 0;\n\tint max = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\twhile (max && s[x][max + 1] != s[y][i]) max = fail[x][max];\n\t\tif (s[x][max + 1] == s[y][i]) max++;\n\t}\n\twhile (max) res += pows[m - max], max = fail[x][max];\n\treturn res;\n}\n\ninline void gaussJordan(int n) {\n\tfor (int i = 1; i < n; i++) {\n\t\tint id = i;\n\t\tfor (int j = i + 1; j < n; j++) if (fabs(a[j][i]) > fabs(a[id][i])) id = j;\n\n\t\tif (id != i) for (int j = i; j <= n; j++) std::swap(a[i][j], a[id][j]);\n\n\t\tfor (int j = 1; j < n; j++) {\n\t\t\tif (i != j) {\n\t\t\t\tfor (int k = n; k >= i; k--) {\n\t\t\t\t\ta[j][k] -= a[i][k] / a[i][i] * a[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < n; ++i) a[i][n] /= a[i][i], a[i][i] = 1;\n}\n\ninline void prepare() {\n\t// KMP prepare\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j < m; j++) {\n\t\t\tint k = fail[i][j];\n\t\t\twhile (k && s[i][k + 1] != s[i][j + 1]) k = fail[i][k];\n\t\t\tfail[i][j + 1] = s[i][k + 1] == s[i][j + 1] ? k + 1 : 0;\n\t\t}\n\t}\n\n\tpows[1] = 0.5;\n\tfor (int i = 2; i <= m; i++) pows[i] = pows[i - 1] * 0.5;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\ta[i][j] = check(i, j) + (i == j ? 1.00 : 0.00);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) a[n + 1][i] = 1, a[i][n + 1] = -1;\n\ta[n + 1][n + 2] = 1;\n#ifdef DBG\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tfor (int j = 1; j <= n + 2; j++) {\n\t\t\tprintf(\"%.10Lf \", a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n#endif\n}\n\nint main() {\n\tfreopen(\"game.in\", \"r\", stdin);\n\tfreopen(\"game.out\", \"w\", stdout);\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%s\", s[i] + 1);\n\t}\n\n\tprepare();\n\n\tgaussJordan(n + 2);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tprintf(\"%.10lf\\n\", (double)a[i][n + 2]);\n\t}\n\n\treturn 0;\n}\n```\n\n","tags":["高斯消元"],"categories":["OI"]},{"title":"「SDOI2017」新生舞会 - 01分数规划，二分图最大权匹配","url":"%2Fsdoi2017-ball%2F","content":"\n\n学校组织了一次新生舞会，Cathy 作为经验丰富的老学姐，负责为同学们安排舞伴。\n\n有 $ n $ 个男生和 $ n $ 个女生参加舞会，一个男生和一个女生一起跳舞，互为舞伴。  \nCathy 收集了这些同学之间的关系，比如两个人之前是否认识，计算得出 $ a_{i, j} $，表示第 $ i $ 个男生和第 $ j $ 个女生一起跳舞时他们喜悦程度。  \nCathy 还需要考虑两个人一起跳舞是否方便，比如身高体重差别会不会太大，计算得出 $ b_{i, j} $ 表示第 $ i $ 个男生和第 $ j $ 个女生一起跳舞时的不协调裎度。\n\n当然，还需要考虑很多其他间题。\n\nCathy 想先用一个程序通过 $ a_{i, j} $ 和 $ b_{i, j} $ 求出一种方案，再手动对方案进行微调。  \nCathy 找到你，希望你帮她写那个程序。\n\n一个方案中有 $ n $ 对舞伴，假设每对舞伴的喜悦程度分别是 $ a'_1, a'_2, \\ldots, a'_n $，假设每对舞伴不协调程度分别是 $ b'_1, b'_2, \\ldots, b'_n $。令\n\n$$ C = \\frac{a'_1 + a'_2 + \\cdots + a'_n}{b'_1 + b'_2 + \\cdots + b'_n} $$\n\nCathy 希望 C 值最大。\n\n<!--more-->\n\n# 题解\n题目要求最大化 $ \\frac {\\sum a_i} {\\sum b_i} $，考虑 $ 01 $ 分数规划。\n\n二分一个答案 $ x $，假设原式等于 $ x $，则有：\n$$\n\\frac {\\sum a_i} {\\sum b_i} = x\n$$\n\n移项，得：\n$$\n\\sum a_i - x\\sum b_i = 0\n$$\n\n同样的，可以得到若原式大于 $ x $ 或原式小于 $ x $ 的情况。我们求上式最大值以后和 $ x $ 比较即可。\n\n最大化移项后的这个式子其实是一个二分图最大权匹配，这里我选择用费用流做法（其实就是不会什么 KM 辣。。）。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <cfloat>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\nconst double EPS = 1e-8;\n\ninline int dcmp(double x) {\n\tif (fabs(x) <= EPS) return 0;\n\telse return x > 0 ? 1 : -1;\n}\n\ninline bool equal(double a, double b) {\n\treturn !dcmp(a - b);\n}\n\nconst int MAX_N = 100;\nconst int MAX_NODE_NUM = 2 * MAX_N + 2;\nconst int MAX_EDGE_NUM = 2 * (MAX_N * MAX_N + 2 * MAX_N);\nconst double NEG_INF = -1e18;\n\nnamespace EK {\n\tstruct Node;\n\tstruct Edge;\n\n\tstruct Edge {\n\t\tNode *fr, *to;\n\t\tint cap, flow;\n\t\tdouble cost;\n\n\t\tint rev;\n\n\t\tEdge(Node *fr, Node *to, int cap, double cost, int rev) : fr(fr), to(to), cap(cap), flow(0), cost(cost), rev(rev) {}\n\t};\n\n\tstruct Node {\n\t\tint flow;\n\t\tdouble dist;\n\t\tbool inq;\n\t\tstd::vector<Edge> edges;\n\n\t\tNode *inNode;\n\t\tint inEdge;\n\t} N[MAX_NODE_NUM];\n\n\tinline void addEdge(int fr, int to, int cap, double cost) {\n\t\tN[fr].edges.push_back(Edge(&N[fr], &N[to], cap, cost, N[to].edges.size()));\n\t\tN[to].edges.push_back(Edge(&N[to], &N[fr], 0, -cost, N[fr].edges.size() - 1));\n\t}\n\n\tint n;\n\tNode *s, *t;\n\n\tint maxFlow;\n\tdouble minCost;\n\n\tinline bool spfa() {\n\t\tfor (int i = 0; i < n; i++) N[i].dist = NEG_INF;\n\n\t\tstd::deque<Node *> q;\n\n\t\tq.push_back(s), s->dist = 0, s->inq = true, s->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop_front();\n\t\t\tv->inq = false;\n\n\t\t\tfor (int i = 0, n = v->edges.size(); i < n; i++) {\n\t\t\t\tEdge *e = &v->edges[i];\n\n\t\t\t\tif (e->cap > e->flow && e->to->dist < v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inNode = v;\n\t\t\t\t\te->to->inEdge = i;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->cap - e->flow);\n\t\t\t\t\tif (!e->to->inq) {\n\t\t\t\t\t\te->to->inq = true;\n\t\t\t\t\t\tif (q.empty() || e->to->dist < q.front()->dist) q.push_front(e->to);\n\t\t\t\t\t\telse q.push_back(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn !equal(t->dist, NEG_INF);\n\t}\n\n\tinline void argument() {\n\t\tint flow = t->flow;\n\n\t\tfor (Edge *e = &t->inNode->edges[t->inEdge]; ;) {\n\t\t\te->flow += flow;\n\t\t\te->to->edges[e->rev].flow -= flow;\n\n\t\t\tif (e->fr->inNode) e = &e->fr->inNode->edges[e->fr->inEdge];\n\t\t\telse break;\n\t\t}\n\n\t\tmaxFlow += flow;\n\t\tminCost += t->dist * flow;\n\t}\n\n\tinline void solve(int s, int t, int n) {\n\t\tEK::maxFlow = 0, EK::minCost = 0;\n\t\tEK::s = &N[s], EK::t = &N[t], EK::n = n;\n\n\t\twhile (spfa()) argument();\n\t}\n\n\tinline void clear(int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].edges.clear();\n\t}\n}\n\nint n;\nint a[MAX_N + 1][MAX_N + 1], b[MAX_N + 1][MAX_N + 1];\n\ninline bool check(double bound) {\n\tEK::clear(n * 2 + 2);\n\n\tint s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tEK::addEdge(i, j + n, 1, a[i][j] - bound * b[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) EK::addEdge(s, i, 1, 0);\n\tfor (int i = 1; i <= n; i++) EK::addEdge(i + n, t, 1, 0);\n\n\tEK::solve(s, t, n * 2 + 2);\n\n\treturn dcmp(EK::minCost) >= 0;\n}\n\ninline double solve() {\n\tdouble l = 0, r = 1e4;\n\n\twhile (r - l > EPS) {\n\t\tdouble mid = (l + r) / 2;\n\t\tif (check(mid)) l = mid; else r = mid;\n\t}\n\n\treturn (l + r) / 2;\n}\n\nint main() {\n//\tfreopen(\"ball.in\", \"r\", stdin);\n//\tfreopen(\"ball.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) scanf(\"%d\", &a[i][j]);\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) scanf(\"%d\", &b[i][j]);\n\n\tprintf(\"%.6lf\\n\", solve());\n\n\treturn 0;\n}\n```\n\n","tags":["费用流"],"categories":["OI"]},{"title":"「SDOI2017」序列计数 - DP，矩阵乘法，线性筛","url":"%2Fsdoi2017-count%2F","content":"\n\nAlice 想要得到一个长度为 $ n $ 的序列，序列中的数都是不超过 $ m $ 的正整数，而且这 $ n $ 个数的和是 $ p $ 的倍数。\n\nAlice 还希望，这 $ n $ 个数中，至少有一个数是质数。\n\nAlice 想知道，有多少个序列满足她的要求。\n\n<!--more-->\n\n# 题解\n考虑一个比较显然的 dp，设 $ f(i, j) $ 表示序列长度为 $ i $，序列中元素模 $ p $ 的值为 $ j $ 时的方案数。这样考虑不到需要有质数的要求，那么考虑容斥，设 $ g(i, j) $ 表示的意义与 $ f(i, j) $ 相同，但是不允许选出的序列中的元素有质数。\n\n这样最后的答案就是 $ f(n, 0) - g(n, 0) $。\n\n刚才 dp 的转移方程是平凡的：\n$$\nf(i, j) = \\sum\\limits_{k = 1}^{m} f(i - 1, (j - k) \\mod p)\n$$\n\n可以观察到这是一个一维转移，可以使用矩阵乘法来优化转移。\n\n考虑一个转移矩阵 $ A $ 和初始矩阵 $ F $。\n\n考虑构造转移矩阵，若 $ F $ 矩阵的形式如下：\n$$\n\\begin{bmatrix}\nf(i, 0) \\\\\\\\\nf(i, 1) \\\\\\\\\nf(i, 2) \\\\\\\\\n\\dots \\\\\\\\\nf(i, p - 1)\n\\end{bmatrix}\n$$\n\n我们以转移矩阵的第一行为例，若转移矩阵第一行形式如下：\n$$\n\\begin{bmatrix}\na_0 & a_1 & a_2 & \\dots & a_{p - 1}\n\\end{bmatrix}\n$$\n\n我们应使得\n$$\n\\sum\\limits_{j = 0}^{p - 1} a_j\\ f(i, j) = f(i + 1, 0)\n$$\n\n也就是说，转移矩阵第一行的每个位置对应的应该是对于每个 $ j $ 能够使得 $ j + k, k \\in [1, m] = 0 $ 的方案数。余下几行同理。\n\n在这里注意一个细节，我们并不需要枚举 $ [1, m] $ 中的数来构造转移矩阵，我们可以预处理处 $ [1, m] $ 中的数模 $ p $ 后的结果，并统计每个结果的出现次数，这样枚举的复杂度就从 $ O(m) $ 减小到 $ O(p) $ 了。原来构造转移矩阵需要 $ O(mp) $ 这样优化以后只需要 $ O(p^2) $。\n\n这是对于 $ f(i, j) $ 的处理。同理，如果要处理 $ g(i, j) $ 的话，只需要在构造转移矩阵的时候排除掉加上质数转移的情况，处理的方式是线筛出 $ [1, m] $ 中的质数，然后在上一步统计 $ [1, m] $ 中的数模 $ p $ 所得结果出现次数时分质数和非质数来讨论就可以了。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAX_N = 1e9;\nconst int MAX_M = 2e7;\nconst int MAX_P = 100;\nconst int MAX_PRIME = 1270607;\nconst int MOD = 20170408;\n\nbool isNotPrime[MAX_M + 1];\nint primes[MAX_PRIME + 1], cnt;\nint n, m, p;\n\ninline int get()\n{\n    int res = 1, Q = 1;\n    char c;\n    while ((c = getchar()) < 48 || c > 57)\n    if (c == '-') Q = -1;\n    if (Q) res = c-48;\n    while ((c=getchar()) >= 48 && c <= 57)\n    res = res * 10 + c - 48;\n    return res * Q;\n}\n\ninline void sieve() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 1; i <= MAX_M; i++) {\n\t\tif (!isNotPrime[i]) primes[cnt++] = i;\n\t\tfor (int j = 0; j < cnt && (long long)i * primes[j] <= MAX_M; j++) {\n\t\t\tisNotPrime[i * primes[j]] = true;\n\t\t\tif (i % primes[j] == 0) break;\n\t\t}\n\t}\n}\n\nstruct Matrix {\n    long long a[MAX_P][MAX_P];\n    int n, m;\n\n    Matrix(int n, int m, bool unit = false) : n(n), m(m) {\n        memset(a, 0, sizeof(a));\n        if (unit) for (int i = 0; i < n; i++) a[i][i] = 1;\n    }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n    Matrix res(a.n, b.m);\n    for (int i = 0; i < a.n; i++) {\n        for (int j = 0; j < b.m; j++) {\n            for (int k = 0; k < a.m; k++) {\n                res.a[i][j] += a.a[i][k] * b.a[k][j] % MOD;\n            }\n        }\n    }\n    return res;\n}\n\nMatrix pow(Matrix a, int n) {\n    Matrix res(a.n, a.n, true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint primeCnt[MAX_P], nonPrimeCnt[MAX_P];\n\ninline int calc(bool flag) {\n    Matrix A(p, p), F(p, 1);\n\tfor (int j = 0; j < p; j++) {\n\t\tfor (int k = 0; k < p; k++) {\n\t\t\tA.a[(j + k) % p][j] = (primeCnt[k] * flag + nonPrimeCnt[k]) % MOD;\n\t\t}\n\t}\n\tA = pow(A, n);\n\tF.a[0][0] = 1;\n\tA = A * F;\n\treturn A.a[0][0];\n}\n\nint main() {\n\tn = get(), m = get(), p = get();\n\tsieve();\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (isNotPrime[i]) nonPrimeCnt[i % p]++;\n\t\telse primeCnt[i % p]++;\n\t}\n\n\tprintf(\"%d\\n\", (calc(true) - calc(false) + MOD) % MOD);\n\n\treturn 0;\n}\n```\n\n","tags":["线性筛"],"categories":["OI"]},{"title":"「SDOI2017」树点涂色 - LCT，线段树","url":"%2Fsdoi2017-paint%2F","content":"\nBob 有一棵 $ n $ 个点的有根树，其中 $ 1 $ 号点是根节点。Bob 在每个节点上涂了颜色，并且每个点上的颜色不同。\n\n定义一条路径的权值是，这条路径上的点（包括起点和终点）共有多少种不同的颜色。\n\nBob 可能会进行这几种操作：\n\n* $ 1 \\ x $，把点 $ x $ 到根节点的路径上的所有的点染上一种没有用过的新颜色；\n* $ 2 \\ x \\ y $，求 $ x $ 到 $ y $ 的路径的权值；\n* $ 3 \\ x $，在以 $ x $ 为根的子树中选择一个点，使得这个点到根节点的路径权值最大，求最大权值。\n\nBob 一共会进行 $ m $ 次操作。\n\n<!--more-->\n\n# 题解\n明显地，操作 $ 1 $ 对应的是 `LCT` 里的 `access` 操作，由于每次染上的颜色一定是一个没有出现过的颜色，所以说有两个比较明显的结论：\n\n1. `LCT` 中每条实路径上的颜色是相同的。\n2. 一个节点到根路径上颜色种类的数量等于它到根路径上虚边的个数。\n\n这样，用线段树维护节点到根路径上的颜色种类数，`access` 时每次虚实边转换时，虚边变成实边的，子树中答案集体减一，实边变成虚边的，子树中答案集体加一。\n\n对于操作 $ 3 $，直接线段树查找子树最大就可以了。\n\n对于操作 $ 2 $，简单的 yy 一下以后可以发现，两个节点的颜色不可能同时和它们的 `LCA` 相同，所以 `LCA` 的颜色对答案的贡献一定是 $ 1 $，这样，我们就把两个点到根路径上的颜色数各自减去 `LCA` 到根路径上的颜色数，然后再加上 `LCA` 贡献的 $ 1 $ 即可。\n\n# 代码\n\n专业写挂线段树。\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <stack>\n#include <algorithm>\n\nconst int MAX_N = 1e5;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tNode *fa, *top, *maxc;\n\tint dep, size, min, max;\n\tbool vis;\n} N[MAX_N + 1];\n\nstruct Edge {\n\tNode *to;\n\tEdge *ne;\n\t\n\tEdge(Node *fr, Node *to) : to(to), ne(fr->e) {}\n};\n\ninline void addEdge(int fr, int to) {\n\tN[fr].e = new Edge(&N[fr], &N[to]);\n\tN[to].e = new Edge(&N[to], &N[fr]);\n}\n\nint n, m;\n\ninline void split() {\n\tstd::stack<Node *> s;\n\ts.push(&N[1]);\n\tN[1].dep = 1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->vis) {\n\t\t\tv->vis = true;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\t\tif (e->to != v->fa) {\n\t\t\t\t\te->to->fa = v;\n\t\t\t\t\te->to->dep = v->dep + 1;\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\t\tif (e->to->fa == v) {\n\t\t\t\t\tv->size += e->to->size;\n\t\t\t\t\tif (!v->maxc || v->maxc->size < e->to->size) v->maxc = e->to;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) N[i].vis = false;\n\n\tint ts = 0;\n\n\ts.push(&N[1]);\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->vis) {\n\t\t\tv->vis = true;\n\t\t\tv->min = ++ts;\n\n\t\t\tif (!v->fa || v != v->fa->maxc) v->top = v;\n\t\t\telse v->top = v->fa->top;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\t\tif (e->to->fa == v && e->to != v->maxc) {\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (v->maxc) s.push(v->maxc);\n\t\t} else {\n\t\t\tv->max = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\nint a[MAX_N + 1];\n\nstruct Segt {\n\tint l, r;\n\tSegt *lc, *rc;\n\tint max;\n\tint tag;\n\n\tSegt(int l, int r, Segt *lc, Segt *rc) : l(l), r(r), lc(lc), rc(rc), max(std::max(lc->max, rc->max)), tag(0) {}\n\tSegt(int l, int r, Segt *lc, Segt *rc, int max) : l(l), r(r), lc(lc), rc(rc), max(max), tag(0) {}\n\n\tvoid maintain() {\n\t\tmax = std::max(lc->max, rc->max);\n\t}\n\n\tvoid add(int x) {\n\t\tmax += x;\n\t\ttag += x;\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag) {\n\t\t\tlc->add(tag);\n\t\t\trc->add(tag);\n\n\t\t\ttag = 0;\n\t\t}\n\t}\n\n\tvoid modify(int l, int r, int val) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) add(val);\n\t\telse pushDown(), lc->modify(l, r, val), rc->modify(l, r, val), maintain();\n\t}\n\n\tint query(int pos) {\n\t\tif (l == r) return max;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint mid = l + (r - l) / 2;\n\n\t\t\tif (pos <= mid) return lc->query(pos);\n\t\t\telse if (pos > mid) return rc->query(pos);\n\t\t}\n\t}\n\n\tint query(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse return pushDown(), std::max(lc->query(l, r), rc->query(l, r));\n\t}\n\n\tstatic Segt *build(int l, int r) {\n\t\tif (l == r) return new Segt(l, r, NULL, NULL, N[a[l]].dep);\n\t\telse {\n\t\t\tint mid = l + (r - l) / 2;\n\t\t\treturn new Segt(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segt;\n\nstruct LinkCutTree {\n\tstruct Node {\n\t\tNode *c[2], *fa, *pathFa, *min;\n\t\tint begin, end;\n\n\t\tNode() : min(this) {}\n\n\t\tvoid maintain() {\n\t\t\tif (c[0]) min = c[0]->min;\n\t\t\telse min = this;\n\t\t}\n\t\t\n\t\tint relation() {\n\t\t\treturn this == fa->c[1];\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tstd::swap(pathFa, fa->pathFa);\n\n\t\t\tNode *old = fa;\n\t\t\tint x = relation();\n\n\t\t\tfa = old->fa;\n\t\t\tif (old->fa) old->fa->c[old->relation()] = this;\n\n\t\t\told->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->fa = old;\n\n\t\t\tc[x ^ 1] = old;\n\t\t\told->fa = this;\n\n\t\t\told->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (fa) {\n\t\t\t\tif (!fa->fa) rotate();\n\t\t\t\telse if (fa->relation() == relation()) fa->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\n\t\t\tif (c[1]) {\n\t\t\t\tsegt->modify(c[1]->min->begin, c[1]->min->end, +1);\n\t\t\t\tstd::swap(c[1]->fa, c[1]->pathFa);\n\t\t\t\tc[1] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\n\t\t\tif (!pathFa) return false;\n\n\t\t\tsegt->modify(this->min->begin, this->min->end, -1);\n\t\t\tpathFa->expose();\n\t\t\tpathFa->c[1] = this;\n\t\t\tstd::swap(fa, pathFa);\n\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\t} N[MAX_N + 1];\n\n\tvoid link(int x, int fa) {\n\t\tNode *v = &N[x], *par = &N[fa];\n\t\tv->pathFa = par;\n\t}\n\n\tvoid init() {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tN[i].begin = ::N[i].min, N[i].end = ::N[i].max;\n\t\t\tif (::N[i].fa) link(i, static_cast<int>(::N[i].fa - ::N));\n\t\t}\n\t}\n\n\tvoid change(int x) {\n\t\tNode *v = &N[x];\n\t\tv->access();\n\t}\n} lct;\n\ninline void change(int x) {\n\tlct.change(x);\n}\n\ninline int queryMax(int x) {\n\treturn segt->query(N[x].min, N[x].max);\n}\n\ninline Node *lca(Node *u, Node *v) {\n\twhile (u->top != v->top) {\n\t\tif (u->top->dep < v->top->dep) std::swap(u, v);\n\t\tu = u->top->fa;\n\t}\n\n\tif (u->dep < v->dep) return u;\n\telse return v;\n}\n\ninline int query(int a, int b) {\n\tNode *u = &N[a], *v = &N[b];\n\tNode *p = lca(u, v);\n\treturn segt->query(u->min) + segt->query(v->min) - segt->query(p->min) * 2 + 1;\n}\n\nint main() {\n//\tfreopen(\"paint.in\", \"r\", stdin);\n//\tfreopen(\"paint.out\", \"w\", stdout);\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tsplit();\n\tlct.init();\n\n\tfor (int i = 1; i <= n; i++) a[N[i].min] = i;\n\n\tsegt = Segt::build(1, n);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint cmd, x, y;\n\t\tscanf(\"%d\", &cmd);\n\t\t\n\t\tif (cmd == 1) {\n\t\t\tscanf(\"%d\", &x);\n\t\t\tchange(x);\n\t\t} else if (cmd == 2) {\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tprintf(\"%d\\n\", query(x, y));\n\t\t} else if (cmd == 3) {\n\t\t\tscanf(\"%d\", &x);\n\t\t\tprintf(\"%d\\n\", queryMax(x));\n\t\t} else throw \"%%%Menci\";\n\t}\n\n\tfclose(stdin), fclose(stdout);\n\treturn 0;\n}\n```\n\n","tags":["LCA"],"categories":["OI"]},{"title":"「SDOI2017」数字表格 - 莫比乌斯反演","url":"%2Fsdoi2017-product%2F","content":"\nDoris 刚刚学习了 fibnacci 数列，用 $ f[i] $ 表示数列的第 $ i $ 项，那么：\n\n$$\n\\begin{aligned}\nf[0] &= 0 \\\\\\\\\nf[1] &= 1 \\\\\\\\\nf[n] &= f[n - 1] + f[n - 2], n \\geq 2\n\\end{aligned}\n$$\n\nDoris 用老师的超级计算机生成了一个 $ n \\times m $ 的表格，第 $ i $ 行第 $ j $ 列的格子中的数是 $ f[\\gcd(i, j)] $，其中 $ \\gcd(i, j) $ 表示 $ i $ 与 $ j $ 的最大公约数。\n\nDoris 的表格中共有 $ n \\times m $ 个数，她想知道这些数的乘积是多少。\n\n这些数的乘积实在是太大了，所以 Doris 只想知道乘积对 $ 1000000007 $ 取模后的结果。\n\n<!--more-->\n\n# 题解\n反演一下就好啦。\n\n设 $ n $ 为 $ n, m $ 中的较小值，首先，题目要求求的式子是\n$$\n\\prod\\limits_{i = 1}^{n} \\prod\\limits_{j = 1}^{m} f(\\gcd((i, j))\n$$\n\n考虑枚举一个 $ d $ 使得 $ d $ 作为 $ \\gcd(i, j) $ 的值，原式可化为\n$$\n\\prod\\limits_{d = 1}^{n} f(d) ^ {\\sum\\limits_{i = 1}^{n} \\sum\\limits_{j = 1}^{m} [\\gcd(i, j) = d]}\n$$\n\n把幂指数单独拿下来处理\n$$\n\\sum\\limits_{i = 1}^{n} \\sum\\limits_{j = 1}^{m} [\\gcd(i, j) = d]\n$$\n\n将 $ i, j $ 同时除以 $ d $ 得\n$$\n\\sum\\limits_{i = 1}^{n} \\sum\\limits_{j = 1}^{m} [\\gcd(\\lfloor \\frac i d \\rfloor \\lfloor \\frac j d \\rfloor) = 1]\n$$\n\n更改求和指标，设 $ N = \\lfloor \\frac n d \\rfloor, M = \\lfloor \\frac m d \\rfloor$\n$$\n\\sum\\limits_{i = 1}^{N} \\sum\\limits_{j = 1}^{M} [\\gcd(i, j) = 1]\n$$\n\n把 $ [\\gcd(i, j) = 1] $ 卷一下\n$$\n\\sum\\limits_{i = 1}^{N} \\sum\\limits_{j = 1}^{M} \\sum\\limits_{p} [p | \\gcd(i, j)]\\mu(p)\n$$\n\n更改求和顺序，改为先枚举 $ p $\n$$\n\\sum\\limits_{p = 1}^{N} \\sum\\limits_{i = 1}^{N} \\sum\\limits_{j = 1}^{M} [p | \\gcd(i, j)]\n$$\n\n$ p\\ | \\gcd(i, j) $ 的充要条件是 $ p\\ |\\ i \\wedge p\\ |\\ j $\n$$\n\\sum\\limits_{p = 1}^{N} \\mu(p) \\sum\\limits_{i = 1}^{N}[p\\ |\\ i]\\sum\\limits_{j = 1}^{M} [p\\ |\\ j]\n$$\n\n可以转化为\n$$\n\\sum\\limits_{p = 1}^{N} \\mu(p) \\lfloor \\frac N p \\rfloor \\lfloor \\frac M p \\rfloor\n$$\n\n预处理 $ \\mu $ 的前缀和，数论分块求。\n\n回到一开始的式子，上式可以看做一个函数 $ g(N, M) $，其中 $ N = \\lfloor \\frac n d \\rfloor, M = \\lfloor \\frac m d \\rfloor $。\n\n这样，预处理斐波那契数列前缀积，对于指数上的这个函数，也可以进行数论分块。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#define min(a, b) ((a) < (b) ? (a) : (b))\n\nconst int MAX_N = 1e6;\nconst int MOD = 1e9 + 7;\n\nint primes[MAX_N + 1], mu[MAX_N + 1], mus[MAX_N + 1], cnt;\nbool isNotPrime[MAX_N + 1];\n\ninline void sieve() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tfor (int i = 2; i <= MAX_N; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt && (long long)i * primes[j] <= MAX_N; j++) {\n\t\t\tint p = primes[j];\n\t\t\tisNotPrime[i * p] = true;\n\t\t\tif (i % p == 0) {\n\t\t\t\tmu[i * p] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmu[i * p] = -mu[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAX_N; i++) mus[i] = mus[i - 1] + mu[i];\n}\n\ninline void exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(long long x) {\n\tlong long r, g, tmp;\n\texgcd(x, MOD, g, r, tmp);\n\treturn (r % MOD + MOD) % MOD;\n}\n\nlong long fib[MAX_N + 1], fibProd[MAX_N + 1], fibProdInv[MAX_N + 1];\n\ninline void prepare() {\n\tfib[0] = 0, fib[1] = 1;\n\tfor (int i = 2; i <= MAX_N; i++) fib[i] = (fib[i - 1] + fib[i - 2]) % MOD;\n\n\tfibProd[0] = fibProdInv[0] = 1;\n\tfor (int i = 1; i <= MAX_N; i++) {\n\t\tfibProd[i] = fibProd[i - 1] * fib[i] % MOD;\n\t\tfibProdInv[i] = inv(fibProd[i]);\n\t}\n}\n\ninline long long g(int N, int M) {\n\tlong long res = 0;\n\tfor (int l = 1, r; l <= N; l = r + 1) {\n\t\tr = min(N / (N / l), M / (M / l));\n\n\t\tres += (long long)(mus[r] - mus[l - 1]) * (N / l) * (M / l);\n\t}\n\treturn res;\n}\n\ninline int pow(long long a, long long n) {\n\tlong long res = 1;\n\tfor (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n\treturn res;\n}\n\ninline int calc(int N, int M, int l, int r) {\n\treturn pow(fibProd[r] * fibProdInv[l - 1] % MOD, g(N, M));\n}\n\ninline int solve(int n, int m) {\n\tif (n > m) std::swap(n, m);\n\tlong long res = 1;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = min(n / (n / l), m / (m / l));\n\t\t(res *= calc(n / l, m / l, l, r)) %= MOD;\n\t}\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"product.in\", \"r\", stdin);\n\tfreopen(\"product.out\", \"w\", stdout);\n\tint T_T;\n\tscanf(\"%d\", &T_T);\n\tsieve();\n\tprepare();\n\n\twhile (T_T--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tprintf(\"%d\\n\", solve(n, m));\n\t}\n}\n1. 1. 1. 1. ```\n","tags":["莫比乌斯反演"],"categories":["OI"]},{"title":"「SDOI2011」染色 - 树链剖分，线段树","url":"%2Fbzoj2243%2F","content":"\n给定一棵 $ n $ 个节点的树，每个节点上有颜色，要求支持两种操作：\n1. 询问两点 $ (u, v) $ 之间有多少段颜色\n2. 将两点 $ (u, v) $ 之间所有的节点的颜色染成 $ c $\n\n<!--more-->\n\n# 题解\n树链剖分线段树维护，注意线段树每个节点要维护这个区间最左边和最右边位置上节点的颜色，两段区间的答案合并时如果左区间的最右节点和右区间的最左节点颜色相同的话答案要减 $ 1 $。\n\n树剖统计答案的时候也要注意这一点。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <stack>\n#include <algorithm>\n \nconst int MAX_N = 100000;\n \nstruct Node;\nstruct Edge;\n \nint a[MAX_N + 1];\n \nstruct Node {\n    Edge *e;\n    Node *fa, *top, *maxc;\n    int col, dep, size, dfn;\n    bool vis;\n} N[MAX_N + 1];\n \nstruct Edge {\n    Node *to;\n    Edge *ne;\n \n    Edge(Node *fr, Node *to) : to(to), ne(fr->e) {}\n};\n \ninline void addEdge(int fr, int to) {\n    N[fr].e = new Edge(&N[fr], &N[to]);\n    N[to].e = new Edge(&N[to], &N[fr]);\n}\n \nvoid dfs1(Node *v) {\n    v->size = 1;\n    v->vis = true;\n \n    for (Edge *e = v->e; e; e = e->ne) {\n        if (!e->to->vis) {\n            e->to->dep = v->dep + 1;\n            e->to->fa = v;\n            dfs1(e->to);\n            v->size += e->to->size;\n            if (!v->maxc || e->to->size > v->maxc->size) v->maxc = e->to;\n        }\n    }\n}\n \nvoid dfs2(Node *v) {\n    static int ts = 0;\n    v->dfn = ++ts;\n \n    if (!v->fa || v != v->fa->maxc) v->top = v;\n    else v->top = v->fa->top;\n \n    if (v->maxc) dfs2(v->maxc);\n    for (Edge *e = v->e; e; e = e->ne) {\n        if (e->to->fa == v && e->to != v->maxc) dfs2(e->to);\n    }\n}\n \nvoid split(Node *root) {\n    root->dep = 1;\n    dfs1(root);\n    dfs2(root);\n}\n \nstruct Segt {\n    int l, r;\n    Segt *lc, *rc;\n    int sum, tag;\n    int lcol, rcol;\n \n    Segt(int l, int r, Segt *lc, Segt *rc, int sum = 0, int lcol = -1, int rcol = -1) :\n        l(l), r(r), lc(lc), rc(rc), sum(sum), tag(-1), lcol(lcol), rcol(rcol) {}\n \n    void maintain() {\n        if (lc->rcol == rc->lcol) sum = lc->sum + rc->sum - 1;\n        else sum = lc->sum + rc->sum;\n        lcol = lc->lcol, rcol = rc->rcol;\n    }\n \n    void change(int col) {\n        sum = 1;\n        lcol = rcol = col;\n        tag = col;\n    }\n \n    void pushDown() {\n        if (tag != -1) {\n            lc->change(tag);\n            rc->change(tag);\n \n            tag = -1;\n        }\n    }\n \n    void modify(int l, int r, int col) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) change(col);\n        else pushDown(), lc->modify(l, r, col), rc->modify(l, r, col), maintain();\n    }\n \n    int query(int l, int r) {\n        if (l <= this->l && r >= this->r) return sum;\n        else {\n            pushDown();\n            int mid = this->l + (this->r - this->l) / 2;\n            if (l > mid) return rc->query(l, r);\n            else if (r <= mid) return lc->query(l, r);\n            else {\n                int lsum = lc->query(l, r), rsum = rc->query(l, r);\n                if (lc->rcol == rc->lcol) return lsum + rsum - 1;\n                else return lsum + rsum;\n            }\n        }\n    }\n \n    int query(int pos) {\n        if (l == r) return lcol;\n        else {\n            pushDown();\n            int mid = l + (r - l) / 2;\n            if (pos <= mid) return lc->query(pos);\n            else return rc->query(pos);\n        }\n    }\n \n    static Segt *build(int l, int r) {\n        if (l == r) return new Segt(l, r, NULL, NULL, 1, a[l], a[r]);\n        else {\n            int mid = l + (r - l) / 2;\n            Segt *v = new Segt(l, r, build(l, mid), build(mid + 1, r));\n            v->maintain();\n            return v;\n        }\n    }\n} *segt;\n \ninline void change(int a, int b, int c) {\n    Node *u = &N[a], *v = &N[b];\n    while (u->top != v->top) {\n        if (u->top->dep < v->top->dep) std::swap(u, v);\n        segt->modify(u->top->dfn, u->dfn, c);\n        u = u->top->fa;\n    }\n \n    if (u->dep > v->dep) std::swap(u, v);\n    segt->modify(u->dfn, v->dfn, c);\n}\n \ninline int query(int a, int b) {\n    Node *u = &N[a], *v = &N[b];\n    int res = 0;\n    while (u->top != v->top) {\n        if (u->top->dep < v->top->dep) std::swap(u, v);\n        res += segt->query(u->top->dfn, u->dfn);\n        if (segt->query(u->top->dfn) == segt->query(u->top->fa->dfn)) res--;\n        u = u->top->fa;\n    }\n \n    if (u->dep > v->dep) std::swap(u, v);\n    res += segt->query(u->dfn, v->dfn);\n    return res;\n}\n \nint main() {\n//  freopen(\"data.in\", \"r\", stdin);\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &N[i].col);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n    }\n \n    split(&N[1]);\n \n    for (int i = 1; i <= n; i++) {\n        a[N[i].dfn] = N[i].col;\n    }\n \n    segt = Segt::build(1, n);\n \n    for (int i = 1; i <= m; i++) {\n        char cmd[2];\n        scanf(\"%s\", cmd);\n        if (cmd[0] == 'C') {\n            int a, b, c;\n            scanf(\"%d %d %d\", &a, &b, &c);\n            change(a, b, c);\n        } else if (cmd[0] == 'Q') {\n            int a, b;\n            scanf(\"%d %d\", &a, &b);\n            printf(\"%d\\n\", query(a, b));\n        }\n    }\n \n    return 0;\n}\n```\n\n","tags":["SDOI"],"categories":["OI"]},{"title":"「NOIP2016」天天爱跑步","url":"%2FNOIP2016-running%2F","content":"\n小 C 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。\n\n这个游戏的地图可以看作一棵包含 $ n $ 个结点和 $ n - 1 $ 条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从 $ 1 $ 到 $ n $ 的连续正整数。\n\n现在有 $ m $ 个玩家，第 $ i $ 个玩家的起点为 $ S_i $，终点为 $ T_i $。每天打卡任务开始时，所有玩家在第 $ 0 $  秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的）\n\n小 C 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 $ j $ 的观察员会选择在第 $ W_j $ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 $ W_j $ 秒也理到达了结点 $ j $。小 C 想知道每个观察员会观察到多少人？\n\n注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一段时间后再被观察员观察到。即对于把结点 $ j $ 作为终点的玩家：若他在第 $ W_j $ 秒前到达终点，则在结点 $ j $ 的观察员不能观察到该玩家；若他正好在第 $ W_j $ 秒到达终点，则在结点 $ j $ 的观察员可以观察到这个玩家。\n\n<!--more-->\n\n# 题目链接\n[LYOI#100](https://ly.men.ci/problem/100/)\n\n# 题解\n首先考虑在序列上的做法。\n\n假设现在我们的序列是一个 $ [0, L) $ 的序列，那么对于每一个玩家 $ (S_i, T_i) $ ，有两种情况。\n\n当 $ S_i < T_i $ 时，只有在序列的 $ [S_i, T_i] $ 这段区间内的某个 $ j $ 才有可能观察到这个玩家。 考虑在位置 $ j $ 的观察员观察到玩家 $ i $ 的充要条件，就是玩家 $ i $ 到达位置 $ j $ 的时间等于位置 $ j $ 的观察员出现的时间，即 $ W_j $，又因为相邻两个点的距离和玩家的速度都为 $ 1 $ ，所以上述条件可以用式子表示出来，即 $ j - S_i = W_j $，移项后得 $ j - W_j = S_i $。\n\n对于一个确定的点，它的 $ j - W_j $ 是确定的，也就是说这种情况的问题转化为，设 $ X_j = j - W_j $ 区间加一个数，然后对于区间中的某个节点 $ j $ 询问该位置上的数等于 $ X_j $ 的个数。这个问题我们可以用差分化思想解决，即对于需要添加的一个数，在位置 $ S $ 把它加上，在位置 $ T + 1 $ 把它删去。\n\n当 $ S_i > T_j $ 时，仍可以用差分化思想解决，只不过这个时候能够观察到的先决条件变为 $ S_i - j = W_j $。我们设 $ X_j = j + W_j $，按照上述做法来做即可。\n\n问题转移到树上，考虑树链剖分。\n\n把每一条链看成是一个序列，链上深度最小的点的位置为 $ 0 $，向下位置递增，向上位置为负。\n\n这样可以把每个玩家的运动过程拆成从 $ S $ 到 $ lca(S, T) $ 的第一部分以及从 $ lca(S, T) $ 到 $ T $ 的第二部分。\n\n对于第一部分的每一条链上的情况，把它看作是 $ S > T $ 的情况，第二部分的每一条链上的情况，把它看作是 $ S < T $ 的情况。\n\n我们记链上每个节点的位置为 $ id $，其深度为 $ dep $，两点之间的距离为 $ dist $。\n\n具体来讲，对于第一种情况，考虑链上的深度最大的由 $ S $ 到 $ lca $ 的必经点，记为 $ u $，由它向上走到链上任意深度大于 $ lca(S, T) $ 的点上的观察员都是可能观察到这位玩家的。由它向上走到的某一个合法的，链上坐标为 $ j $ 的点能观察到这个玩家的充要条件是，由 $ S $ 到 $ u $ 的距离加上从 $ u $ 到 $ j $ 的距离等于 $ W_j $，即 $ dist(S, u) + dist(u, j) $。用已知的量表示出来就是 $ S.dep - u.dep + u.id - j.id = W_j $。\n\n对于第二种情况，在某条链上，将 $ S $ 的坐标看成一个负值，则它的坐标应该是从 $ S $ 到这条链顶端节点的距离的相反数，我们将原有的条件取反，则得到 $ S = W_j - j $。\n\n本来想画个图的，但是感觉让我画图还不如让我干说（其实是写题解的时候找不到画图工具了。。），不过有时间会补上图的。具体实现细节见代码吧。还有我的代码在洛谷上是过不去的。。本身 $ n\\log n $ 的复杂度就有点不靠谱。。不过如果您会 \\_\\_\\_\\_ 的 \\_\\_\\_\\_ 的话树剖当然稳稳过啦。\n\n其实这个题有 $ O(n + m) $ 的做法，只不过我目前还没有去看 qwq （其实就是懒找什么借口），如果写出线性做法的话再更新辣。\n\n感觉自己是真的菜，NOIP2016 爆炸以后这么久才填完坑。。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <new>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nconst int MAX_N = 300000;\n\nint n, m;\n\nstruct Tag {\n\tint x;\n\tbool del;\n\n\tTag(bool del, int x) : x(x), del(del) {}\n};\n\nstruct Node;\nstruct Edge;\nstruct Chain;\n\nstruct Node {\n\tEdge *e;\n\tNode *fa, *maxc;\n\tChain *chain;\n\tint size, dep, dfn, id, w, x, ans;\n\tbool vis;\n\tstd::vector<Tag> forwTag, bacwTag;\n} N[MAX_N];\n\nstruct Edge {\n\tNode *fr, *to;\n\tEdge *ne;\n\n\tEdge() {}\n\tEdge(Node *fr, Node *to) : fr(fr), to(to), ne(fr->e) {}\n} _pool[MAX_N * 2], *_end;\n\ninline void addEdge(int fr, int to) {\n\tN[fr].e = new (_end++) Edge(&N[fr], &N[to]);\n\tN[to].e = new (_end++) Edge(&N[to], &N[fr]);\n}\n\nstruct Chain {\n\tNode *top, *bot;\n\tstd::vector<Node *> nodes;\n\tint len;\n} chains[MAX_N];\n\nint chainCnt = 0;\n\ntemplate<typename T>\nstruct Stack {\n\tT s[MAX_N];\n\tint tot;\n\n\tStack() : tot(0) {}\n\n\tvoid push(T val) {\n\t\ts[tot++] = val;\n\t}\n\n\tvoid pop() {\n\t\ttot--;\n\t}\n\n\tbool empty() {\n\t\treturn tot == 0;\n\t}\n\n\tT top() {\n\t\treturn s[tot - 1];\n\t}\n};\n\nStack<Node *> s;\n\ninline void split() {\n//\tstd::stack<Node *> s;\n\tN[1].dep = 1;\n\ts.push(&N[1]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->vis) {\n\t\t\tv->vis = true;\n\t\t\tv->size = 1;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\t\tif (e->to != v->fa) {\n\t\t\t\t\te->to->fa = v;\n\t\t\t\t\te->to->dep = v->dep + 1;\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\t\tif (e->to->fa == v) {\n\t\t\t\t\tv->size += e->to->size;\n\t\t\t\t\tif (!v->maxc || e->to->size > v->maxc->size) v->maxc = e->to;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) N[i].vis = false;\n\n\ts.push(&N[1]);\n\tN[1].dep = 1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->vis) {\n\t\t\tv->vis = true;\n\n\t\t\tif (!v->fa || v != v->fa->maxc) {\n\t\t\t\tv->chain = &chains[chainCnt++];\n\t\t\t\tv->chain->top = v;\n\t\t\t\tv->id = 0;\n\t\t\t} else {\n\t\t\t\tv->chain = v->fa->chain;\n\t\t\t\tv->id = v->fa->id + 1;\n\t\t\t}\n\t\t\tv->chain->nodes.push_back(v);\n\t\t\tv->chain->bot = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\t\tif (e->to->fa == v) s.push(e->to);\n\t\t\t}\n\t\t} else {\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < chainCnt; i++) chains[i].len = chains[i].nodes.size();\n}\n\ninline Node *lca(Node *u, Node *v) {\n\twhile (u->chain != v->chain) {\n\t\tif (u->chain->top->dep < v->chain->top->dep) std::swap(u, v);\n\t\tu = u->chain->top->fa;\n\t}\n\tif (u->dep > v->dep) return v;\n\telse return u;\n}\n\ninline int dist(Node *u, Node *v, Node *p) {\n\treturn u->dep + v->dep - p->dep * 2;\n}\n\ninline void addTag(bool forw, Chain *chain, int s, int t, int x) {\n\tif (forw) {\n\t\tif (s > t) return;\n\t\tchain->nodes[s]->forwTag.push_back(Tag(false, x));\n\t\tchain->nodes[t]->forwTag.push_back(Tag(true, x));\n\t} else {\n\t\tif (s < t) return;\n\t\tchain->nodes[s]->bacwTag.push_back(Tag(false, x));\n\t\tchain->nodes[t]->bacwTag.push_back(Tag(true, x));\n\t}\n}\n\ninline void play(Node *s, Node *t) {\n\tif (s == t) {\n\t\tif (s->w == 0) s->ans++;\n\t\treturn;\n\t}\n\n\tNode *p = lca(s, t), *u = s, *v = t;\n\tif (dist(s, p, p) == p->w) p->ans++;\n\n\tif (s != p) {\n\t\twhile (u->chain != p->chain) {\n\t\t\taddTag(false, u->chain, u->id, 0, s->dep - u->dep + u->id);\n\t\t\tu = u->chain->top->fa;\n\t\t}\n\t\taddTag(false, u->chain, u->id, p->id + 1, s->dep - u->dep + u->id);\n\t}\n\n\tif (t != p) {\n\t\twhile (v->chain != p->chain) {\n\t\t\taddTag(true, v->chain, 0, v->id, (s->dep - p->dep) + (v->chain->top->dep - p->dep));\n\t\t\tv = v->chain->top->fa;\n\t\t}\n\t\taddTag(true, v->chain, p->id + 1, v->id, (s->dep - p->dep) + (v->chain->top->dep - p->dep));\n\t}\n}\n\nint _cnt[MAX_N * 4 + 1], *cnt = _cnt + MAX_N * 2;\n\ninline void solve() {\n\tfor (int i = 0; i < chainCnt; i++) {\n\t\tChain &chain = chains[i];\n\n\t\t// forw on tree\n\t\tfor (int j = 0; j < chain.len; j++) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->forwTag.begin(); it != chain.nodes[j]->forwTag.end(); it++) {\n\t\t\t\tif (!it->del) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - j];\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->forwTag.begin(); it != chain.nodes[j]->forwTag.end(); it++) {\n\t\t\t\tif (it->del) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\n\t\t// bacw on tree\n\t\tfor (int j = chain.len - 1; j >= 0; j--) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->bacwTag.begin(); it != chain.nodes[j]->bacwTag.end(); it++) {\n\t\t\t\tif (!it->del) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w + j];\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->bacwTag.begin(); it != chain.nodes[j]->bacwTag.end(); it++) {\n\t\t\t\tif (it->del) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"running.in\", \"r\", stdin);\n\tfreopen(\"running.out\", \"w\", stdout);\n\t\n\t_end = _pool;\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tsplit();\n\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &N[i].w);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tplay(&N[u], &N[v]);\n\t}\n\n\tsolve();\n\n\tfor (int i = 1; i <= n; i++) printf(\"%d%c\", N[i].ans, i == n ? '\\n' : ' ');\n\treturn 0;\n}\n```\n","tags":["差分化标记"],"categories":["OI"]},{"title":"Link-Cut Tree 学习笔记","url":"%2Flct-note%2F","content":"\nLCT 学习笔记，防忘\n\n<!--more-->\n\n# 动态树\n有一类问题，要求我们维护树上路径的信息，如果树是静态的，即树的结构是不会变的，树链剖分可以解决这类问题。但是如果要求支持我们修改树的结构，比如加边，删边等操作，树剖就 gg 了。。\n\n这种动态维护树上信息的问题，我们称之为动态树问题，上述例子是比较简单的动态树问题，不存在对子树进行操作等丧心病狂的操作，所以我们可以用 `Link-Cut Tree` 来解决。\n\n# Link-Cut Tree\n`Link-Cut Tree` 是一种能在 $ O(\\log n) $ 的时间内解决上述问题的数据结构。\n\n简单来说， `LCT` 与树链剖分一样，会对树中节点的儿子进行划分，轻重链剖分根据子树大小将节点的儿子分为轻儿子和重儿子， `LCT` 则会将儿子划分为实、虚两种儿子，相应的边被称为实边和虚边，而且任意时刻，一个节点最多会有一个实儿子，也可能没有。\n\n与树剖不同的是， `LCT` 并不固定划分实虚儿子，由于树的形态不断改变，实虚儿子也有可能变化。\n\n# 基本定义\n深度：深度越大，到根节点越远，反之亦然。\n\n实边：一个非叶节点，向它的实儿子连的一条边叫做实边，向其他所有儿子连的边均为虚边。注意，一个非叶节点可以没有实儿子，此时它向所有儿子连边均为虚边。\n\n实路径：由若干条实边首尾相连的，不可伸长的路径称之为实路径。实路径之间并非孤立的，各条实路径之间通过虚边连接。一条实路径中深度最小的点在树中的父节点被称之为实路径的父亲，在代码中用 `pathFa` 体现。\n\n# 基本操作\n用 `Splay` 来维护实路径。由于实路径中的任意两个节点都是祖先和子孙的关系，则如果我们按照节点的深度进行排序，我们会得到一个唯一的有序深度序列，换言之，在某条实路径对应的 `Splay` 中，一个节点的左子树中的所有节点一定是其祖先，右子树中的所有子树一定是其子孙，这也是我们用`Splay`维护实路径的原因。\n\n在实际维护中，并不需要真的在 `Splay` 中用维护有序集的方法去排序，我们只需要在修改 `Splay` 的时候满足其中序遍历满足我们的需求即可。\n\n我们设 `v` 是树中某个节点，`v.OPERATION`可以使得这个节点进行`OPERATION`这个操作。\n\n1. `v.access` 使得节点 `v` 到根节点的路径成为实路径。\n \n 节点 $ v $ 可能不是目前属实路径的尾部，所以我们将其旋转到其所属`Splay`的根节点，此时如果它有右子树，则它右子树中所有的节点都是它目前所处实路径的下方的节点，我们要断掉这条边（注意不是真的断掉，只是转换成虚边），要做的操作是将其右儿子的 `pathFa` 设成它，同时将其右儿子置空。\n \n 如果此时这条实路径包含根节点，操作结束\n \n 然后我们要做的是将以节点`v`为尾部的这条实路径和它的父亲相连，此时我们对这条实路径的父亲执行上述操作，并且将这条实路径的父亲向实路径的顶部节点的边置为实边，即在这条实路径对应的 `Splay` 中将原来的 `pathFa` 设为 `fa` 即可。\n \n 继续查询该实路径是否包含根节点，若不包含，则继续执行上述操作。\n \n2. `v.find` 找到节点`v`所处这棵树的根节点。  \n 我们只需要执行`v.access`，此时节点`v`与根节点处在一条实路径中，而且根节点一定是深度最小的那个节点，所以查找实路径对应`Splay`的最左节点即可。\n \n3. `v.evert` 将节点`v`置为整棵树的根  \n 首先我们将节点`v`和根置于一条实路径上，即执行`v.access`，此时我们只需让这条实路径反转即可将`v`置为整棵树的根。利用平衡树打标记处理即可。\n 注：维护根不变的树时，不需要此操作。\n \n4. `link(u, v)` 将节点`u`和节点`v`连起来  \n 首先`u.evert`，然后将`u`所在实路径上的`pathFa`置成`v`即可。\n 注：这样操作，让节点`u`成为了节点`v`的儿子\n \n5. `cut(u, v)` 删掉节点`u`和节点`v`之间的边\n 先`u.evert`使得`u`成为有根树的根节点，这样保证`v`一定是节点`u`的子节点，然后`v.access`，再将`v`旋转至`Splay`的根，这样如果原树中有边`(u, v)`，那么`v`的左子树一定只有`u`这个节点。\n \n附上「BZOJ2049」洞穴勘探 的代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nstruct LinkCutTree {\n    struct Node {\n        Node *fa, *ch[2], *pathFa;\n        bool rev;\n\n        void pushDown() {\n            if (rev) {\n                std::swap(ch[0], ch[1]);\n                if (ch[0]) ch[0]->rev ^= 1;\n                if (ch[1]) ch[1]->rev ^= 1;\n\n                rev = false;\n            }\n        }\n\n        int relation() {\n            return this == fa->ch[1];\n        }\n\n        void rotate() {\n            pushDown();\n\n            std::swap(pathFa, fa->pathFa);\n\n            Node *old = fa;\n            int x = relation();\n\n            fa = old->fa;\n            if (old->fa) old->fa->ch[old->relation()] = this;\n\n            old->ch[x] = ch[x ^ 1];\n            if (ch[x ^ 1]) ch[x ^ 1]->fa = old;\n\n            ch[x ^ 1] = old;\n            old->fa = this;\n        }\n\n        void splay() {\n            while (fa) {\n                if (fa->fa) fa->fa->pushDown();\n                fa->pushDown();\n\n                if (!fa->fa) rotate();\n                else if (fa->relation() == relation()) fa->rotate(), rotate();\n                else rotate(), rotate();\n            }\n        }\n\n        void expose() {\n            splay();\n            pushDown();\n\n            if (ch[1]) {\n                std::swap(ch[1]->pathFa, ch[1]->fa);\n                ch[1] = NULL;\n            }\n        }\n\n        bool splice() {\n            splay();\n\n            if (!pathFa) return false;\n\n            pathFa->expose();\n            pathFa->ch[1] = this;\n            std::swap(pathFa, fa);\n\n            return true;\n        }\n\n        void access() {\n            expose();\n            while (splice());\n        }\n\n        void evert() {\n            access();\n            splay();\n            rev ^= 1;\n        }\n    } N[MAXN + 1];\n\n    void link(int a, int b) {\n        Node *u = &N[a], *v = &N[b];\n\n        u->evert();\n        u->pathFa = v;\n    }\n\n    void cut(int a, int b) {\n        Node *u = &N[a], *v = &N[b];\n\n        u->evert();\n        v->access();\n\n        u->splay();\n        u->pushDown();\n\n        u->ch[1] = NULL;\n        v->fa = NULL;\n    }\n\n    int find(int a) {\n        Node *v = &N[a];\n        v->access();\n\n        v->splay();\n        while (v->pushDown(), v->ch[0]) v = v->ch[0];\n\n        return v - N;\n    }\n} lct;\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= m; i++) {\n        char s[8];\n        int u, v;\n        scanf(\"%s %d %d\", s, &u, &v);\n        if (s[0] == 'C') lct.link(u, v);\n        else if (s[0] == 'D') lct.cut(u, v);\n        else if (s[0] == 'Q') puts(lct.find(u) == lct.find(v) ? \"Yes\" : \"No\");\n    }\n    return 0;\n}\n```\n \n\n","tags":["学习笔记"],"categories":["OI"]},{"title":"「SDOI2014」旅行","url":"%2Fbzoj3531%2F","content":"\nS国有 $ N $ 个城市，编号从$ 1 $到$ N $。城市间用$ N - 1 $条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。为了方便，我们用不同的正整数代表各种宗教，S国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S国政府为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。\n\n<!--more-->\n\n在S国的历史上常会发生以下几种事件:  \n`CC x c`：城市$ x $的居民全体改信了$ c $教;  \n`CW x w`：城市$ x $的评级调整为$ c $;  \n`QS x y`：一位旅行者从城市$ x $出发，到城市$ y $，并记下了途中留宿过的城市的评级总和；  \n`QM x y`：一位旅行者从城市$ x $出发，到城市$ y $，并记下了途中留宿过的城市的评级最大值。\n\n由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。\n\n# 题解\n本题的主要限制在宗教，做法是对于每个宗教开一棵线段树。\n\n显然地，如果一开始就把 $ c $ 棵线段树建好，那么一定会 `MLE`，所以我们要用线段树动态开点来搞，大意就是每次插入的时候沿路新建不存在的节点。\n\n写法就是把线段树中的节点在修改中下传，若该节点为空，则新建它。\n\n更改宗教时，将一个节点在原宗教线段树中的值设为 $ 0 $ ，再将其插入新宗教线段树中。\n\n顺便说一句，更改某个节点的值时不要只修改它在线段树中的值，别问我是怎么知道的。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <stack>\n#include <algorithm>\n\nconst int MAX_N = 100000;\nconst int MAX_C = 100000;\nconst int MAX_NODE_NUM = 3400000;\n\nstruct SegmentTree {\n#define mid ((l + r) >> 1)\n\tstruct Node {\n\t\tNode *lc, *rc;\n\t\tint sum, max;\n\n\t\tvoid init() {\n\t\t\tlc = rc = NULL;\n\t\t\tsum = max = 0;\n\t\t}\n\n\t\tvoid update() {\n\t\t\tsum = (lc ? lc->sum : 0) + (rc ? rc->sum : 0);\n\t\t\tmax = std::max(lc ? lc->max : 0, rc ? rc->max : 0);\n\t\t}\n\t};\n\n\tstatic Node *newNode() {\n\t\tstatic Node N[MAX_NODE_NUM], *_end = N;\n\t\treturn _end->init(), _end++;\n\t}\n\n\tNode *root;\n\tint L, R;\n\n\tSegmentTree(int l, int r) {\n\t\tL = l, R = r, root = NULL;\n\t}\n\n\tint querySum(Node *v, int l, int r, int ql, int qr) {\n\t\tif (v == NULL) return 0;\n\t\telse if (l == ql && r == qr) return v->sum;\n\t\telse if (mid >= qr) return querySum(v->lc, l, mid, ql, qr);\n\t\telse if (mid <= ql) return querySum(v->rc, mid, r, ql, qr);\n\t\telse return querySum(v->lc, l, mid, ql, mid) + querySum(v->rc, mid, r, mid, qr);\n\t}\n\n\tint queryMax(Node *v, int l, int r, int ql, int qr) {\n\t\tif (v == NULL) return 0;\n\t\telse if (l == ql && r == qr) return v->max;\n\t\telse if (mid >= qr) return queryMax(v->lc, l, mid, ql, qr);\n\t\telse if (mid <= ql) return queryMax(v->rc, mid, r, ql, qr);\n\t\telse return std::max(queryMax(v->lc, l, mid, ql, mid), queryMax(v->rc, mid, r, mid, qr));\n\t}\n\n\tvoid modify(Node *&v, int l, int r, int pos, int val) {\n\t\tif (v == NULL) v = newNode();\n\n\t\tif (r - l == 1) v->sum = v->max = val;\n\t\telse {\n\t\t\tif (pos < mid) modify(v->lc, l, mid, pos, val);\n\t\t\telse modify(v->rc, mid, r, pos, val);\n\t\t\tv->update();\n\t\t}\n\t}\n\n\tint querySum(int l, int r) {\n\t\treturn querySum(root, L, R, l, r);\n\t}\n\n\tint queryMax(int l, int r) {\n\t\treturn queryMax(root, L, R, l, r);\n\t}\n\n\tvoid modify(int pos, int val) {\n\t\tmodify(root, L, R, pos, val);\n\t}\n} *segt[MAX_C + 1];\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tNode *fa, *maxChild, *pathFa;\n\tint dfn, depth, size;\n\tbool vis;\n\n\tint type, val;\n} N[MAX_N + 5];\n\nstruct Edge {\n\tNode *fr, *to;\n\tEdge *ne;\n\n\tEdge() {}\n\tEdge(Node *fr, Node *to) : fr(fr), to(to), ne(fr->e) {}\n};\n\ninline void addEdge(int fr, int to) {\n\tNode *u = &N[fr], *v = &N[to];\n\n\tu->e = new Edge(u, v);\n\tv->e = new Edge(v, u);\n}\n\nint n, c;\n\ninline void treeChainSplit(Node *root) {\n\tstd::stack<Node *> s;\n\ts.push(root), root->fa = NULL, root->depth = 0;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->vis) {\n\t\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\t\tif (e->to != v->fa) {\n\t\t\t\t\te->to->fa = v, e->to->depth = v->depth + 1;\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tv->vis = true;\n\t\t} else {\n\t\t\tv->size = 1, v->maxChild = NULL;\n\t\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\t\tif (e->to != v->fa) {\n\t\t\t\t\tv->size += e->to->size;\n\t\t\t\t\tif (!v->maxChild || v->maxChild->size < e->to->size) v->maxChild = e->to;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) N[i].vis = false;\n\n\tint timeStamp = 0;\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->vis) {\n\t\t\tv->dfn = timeStamp++;\n\t\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\t\tif (e->to != v->fa && e->to != v->maxChild) {\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (v->maxChild) s.push(v->maxChild);\n\n\t\t\tv->pathFa = (!v->fa || v != v->fa->maxChild) ? v : v->fa->pathFa;\n\n\t\t\tv->vis = true;\n\t\t} else {\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\ninline void build() {\n\ttreeChainSplit(N);\n\n\tfor (int i = 1; i <= MAX_C; i++) segt[i] = new SegmentTree(0, n);\n\n\tfor (int i = 0; i < n; i++) segt[N[i].type]->modify(N[i].dfn, N[i].val);\n}\n\ninline void modifyType(int i, int x) {\n\tNode *v = &N[i];\n\n\tsegt[v->type]->modify(v->dfn, 0);\n\tsegt[v->type = x]->modify(v->dfn, v->val);\n}\n\ninline void modifyVal(int i, int val) {\n\tNode *v = &N[i];\n\tsegt[v->type]->modify(v->dfn, v->val = val);\n}\n\ninline int querySum(int x, int y) {\n\tNode *u = &N[x], *v = &N[y];\n\tSegmentTree *s = segt[u->type];\n\n\tint res = 0;\n\twhile (u->pathFa != v->pathFa) {\n\t\tif (u->pathFa->depth < v->pathFa->depth) std::swap(u, v);\n\n\t\tres += s->querySum(u->pathFa->dfn, u->dfn + 1);\n\t\tu = u->pathFa->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres += s->querySum(u->dfn, v->dfn + 1);\n\n\treturn res;\n}\n\ninline int queryMax(int x, int y) {\n\tNode *u = &N[x], *v = &N[y];\n\tSegmentTree *s = segt[u->type];\n\n\tint res = INT_MIN;\n\twhile (u->pathFa != v->pathFa) {\n\t\tif (u->pathFa->depth < v->pathFa->depth) std::swap(u, v);\n\n\t\tres = std::max(res, s->queryMax(u->pathFa->dfn, u->dfn + 1));\n\t\tu = u->pathFa->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres = std::max(res, s->queryMax(u->dfn, v->dfn + 1));\n\n\treturn res;\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &N[i].val, &N[i].type);\n\t}\n\n\tfor (int i = 0, u, v; i < n - 1; i++) {\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tbuild();\n\n\tstatic char cmd[3];\n\tfor (int i = 0, x, y; i < q; i++) {\n\t\tscanf(\"%s %d %d\", cmd, &x, &y);\n\n\t\tif (cmd[0] == 'C') {\n\t\t\tx--;\n\t\t\tif (cmd[1] == 'C') modifyType(x, y);\n\t\t\telse if (cmd[1] == 'W') modifyVal(x, y);\n\t\t\telse throw \"%%% Menci\";\n\t\t} else if (cmd[0] == 'Q') {\n\t\t\tx--, y--;\n\t\t\tif (cmd[1] == 'S') printf(\"%d\\n\", querySum(x, y));\n\t\t\telse if (cmd[1] == 'M') printf(\"%d\\n\", queryMax(x, y));\n\t\t\telse throw \"%%% Menci\";\n\t\t} else throw \"%%% Menci\";\n\t}\n\n\treturn 0;\n}\n```\n\n","tags":["SDOI"],"categories":["OI"]},{"title":"「BZOJ1756」小白逛公园 - 线段树","url":"%2Fbzoj1756%2F","content":"\n给定一个序列，需要支持两种操作：\n1. 询问给定区间 $ [l, r] $ 中的最大子段和\n2. 修改序列中某个元素的值\n\n<!--more-->\n\n# 题解\n最大子段和问题的最优复杂度显然是 $ O(n) $ 的 dp，但是我们要求的是某个区间中的最大子段和，并且需要支持对区间上的某个位置修改其值，所以我们用分治法来求，用线段树来维护信息。\n\n我们考虑对于求解一个区间的最大子段和的分治做法，首先将其分为两个子区间。\n\n整个大区间的最大子段和可能等于某一个小区间的最大子段和，但是也有可能存在最大子段和中的子段跨过区间中点的情况，所以我们需要左半边区间强制包含右端点的最大子段和，以及右半边区间强制包含左端点的最大子段和，这样将这两个加起来，得到大区间跨过区间中点的最大子段和，三者取最大即可。\n\n对于线段树而言，我们对于每个节点都记录该区间的最大子段和，该区间包含左端点，包含右端点的最大子段和，具体实现见代码。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 100000;\n\nstruct SegmentTree {\n    struct Node {\n        Node *lc, *rc;\n        int l, r, val;\n        int sum, lsum, rsum, maxSum;\n\n        Node() {}\n        Node(Node *lc, Node *rc, int l, int r) : lc(lc), rc(rc), l(l), r(r) {}\n\n        void update() {\n            sum = val;\n\t\t\tif (lc) sum += lc->sum;\n\t\t\tif (rc) sum += rc->sum;\n\n            lsum = rsum = sum;\n            if (lc) {\n                lsum = std::max(lsum, lc->lsum);\n                if (rc) lsum = std::max(lsum, lc->sum + rc->lsum);\n            }\n            if (rc) {\n                rsum = std::max(rsum, rc->rsum);\n                if (lc) rsum = std::max(rsum, rc->sum + lc->rsum);\n            }\n\n            maxSum = sum;\n            maxSum = std::max(maxSum, lsum);\n            maxSum = std::max(maxSum, rsum);\n            if (lc) maxSum = std::max(maxSum, lc->maxSum);\n            if (rc) maxSum = std::max(maxSum, rc->maxSum);\n            if (lc && rc) maxSum = std::max(maxSum, lc->rsum + rc->lsum);\n        }\n\n        void query(int l, int r, int &sum, int &lsum, int &rsum, int &maxSum) {\n            if (this->l > r || this->r < l) return;\n            else if (this->l >= l && this->r <= r) {\n                sum = this->sum;\n                lsum = this->lsum;\n                rsum = this->rsum;\n                maxSum = this->maxSum;\n            } else {\n                int mid = (this->l + this->r) >> 1;\n                if (r <= mid) return lc->query(l, r, sum, lsum, rsum, maxSum);\n                if (l >= mid + 1) return rc->query(l, r, sum, lsum, rsum, maxSum);\n                else {\n                    int suml, lsuml, rsuml, maxSuml;\n                    int sumr, lsumr, rsumr, maxSumr;\n                    lc->query(l, r, suml, lsuml, rsuml, maxSuml);\n                    rc->query(l, r, sumr, lsumr, rsumr, maxSumr);\n\n                    maxSum = sum = suml + sumr;\n                    lsum = std::max(lsuml, suml + lsumr);\n                    rsum = std::max(rsumr, sumr + rsuml);\n                    maxSum = std::max(maxSum, maxSuml);\n                    maxSum = std::max(maxSum, maxSumr);\n                    maxSum = std::max(maxSum, rsuml + lsumr);\n                }\n            }\n        }\n\n        void modify(int pos, int val) {\n            if (this->l > pos || this->r < pos) return;\n            else if (this->l == pos && this->r == pos) this->val = val, update();\n            else {\n                if (lc) lc->modify(pos, val);\n                if (rc) rc->modify(pos, val);\n                update();\n            }\n        }\n    } *root;\n\n    SegmentTree(int l, int r) {\n        root = build(l, r);\n    }\n\n    Node *build(int l, int r) {\n        if (l > r) return NULL;\n        else if (l == r) return new Node(NULL, NULL, l, r);\n        else {\n            int mid = (l + r) >> 1;\n            return new Node(build(l, mid), build(mid + 1, r), l, r);\n        }\n    }\n\n    void modify(int pos, int val) {\n        root->modify(pos, val);\n    }\n\n    int query(int l, int r) {\n        int sum, lsum, rsum, maxSum;\n        root->query(l, r, sum, lsum, rsum, maxSum);\n        return maxSum;\n    }\n} *segt;\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    segt = new SegmentTree(1, n);\n    for (int i = 1; i <= n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        segt->modify(i, x);\n    }\n\n    for (int i = 0; i < m; i++) {\n        int k;\n        scanf(\"%d\", &k);\n        if (k == 1) {\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n            if (l > r) std::swap(l, r);\n            printf(\"%d\\n\", segt->query(l, r));\n        } else {\n            int pos, val;\n            scanf(\"%d %d\", &pos, &val);\n            segt->modify(pos, val);\n        }\n    }\n    return 0;\n}\n```\n\n","tags":["BZOJ"],"categories":["OI"]},{"title":"「网络流24题」最长递增子序列 - 网络流","url":"%2Flcp-network-flow%2F","content":"\n给定正整数序列 $ x_1 \\sim x_n $，以下递增子序列均为**非严格**递增。\n\n1. 计算其最长递增子序列的长度 $ s $。\n2. 计算从给定的序列中最多可取出多少个长度为 $ s $ 的递增子序列。\n3. 如果允许在取出的序列中多次使用 $ x_1 $ 和 $ x_n $，则从给定序列中最多可取出多少个长度为 $ s $ 的递增子序列。\n\n<!--more-->\n\n# 题解\n题意不清的辣鸡题。。这里感谢 Menci 同学在博客里和 OJ 上都强调了 **非严格递增**\n题意要求求出 “最长递增子序列” ，然而实际数据却是 “最长不下降子序列”\n第一问直接 dp 即可，第二问第三问网络流解决。\n\n第二问:\n记第一问答案为 $ K $。\n首先在 dp 中，$ f(i) $ 表示以第 i 个元素结尾的最长不下降子序列长度，\n然后我们将每个 $ (f(i) = 1) $ 与 源点连边，容量为 $ 1 $ ，\n每个 $ (f(i) = K) $ 向汇点连边，每个可能的转移连边，对于可能的转移 $ f(j) \\rightarrow f(i) $，需要满足的条件是 $ j < i $，$ a_j < a_i $ 且 $ f(j) + 1 = f(i) $。\n\n但是第二问要求的方案数其实是不允许在不同方案中选取相同元素的，\n所以我们把每个点拆点限制容量。\n\n第三问:\n第三问就是允许在不同的方案中出现多次 $ a_1 $ 或 $ a_n $，\n这是我们只需要把与 $ f(1) $ 或 $ f(n) $ 相连的边的容量限制撤掉即可，即与其相连的边容量为 $ \\infty $;\n顺便吐槽一句出题人这里也没有解释清楚。。。\n\n注意特判，如果第一问求得答案为 $ 1 $ ，则直接输出 $ 1 \\ n \\ n $。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <new>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint level;\n} N[MAXN * 2 + 10];\n\nstruct Edge {\n\tNode *fr, *to;\n\tEdge *ne, *rev;\n\tint cap, flow;\n\n\tEdge() {}\n\tEdge(Node *fr, Node *to, int cap) : fr(fr), to(to), ne(fr->e), cap(cap), flow(0) {}\n};\n\ninline void addEdge(int fr, int to, int cap) {\n\tN[fr].e = new Edge(&N[fr], &N[to], cap);\n\tN[to].e = new Edge(&N[to], &N[fr], 0);\n\n\tN[fr].e->rev = N[to].e, N[to].e->rev = N[fr].e;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\t\tif (e->cap > e->flow && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->ne) {\n\t\t\tif (e->cap > e->flow && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->cap - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->rev->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint flow;\n\t\t\tif ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n\t\t}\n\t\treturn res;\n\t}\n} dinic;\n\nint a[MAXN + 1], f[MAXN + 1], n, maxLength;\n\nint subTask1() {\n\tint res = 0;\n\tfor (int i = 1; i <= n; i++) f[i] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint lastStat = 0;\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (a[i] >= a[j] && lastStat < f[j]) lastStat = f[j];\n\t\t}\n\n\t\tf[i] = lastStat + 1;\n\t\tres = std::max(res, f[i]);\n\t}\n\treturn res;\n}\n\nint subTask2() {\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(i, i + n, 1);\n\n\t\tif (f[i] == maxLength) addEdge(i + n, t, 1);\n\t\tif (f[i] == 1) addEdge(s, i, 1);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j] == f[i] - 1 && a[j] <= a[i]) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\tint res = dinic(s, t, n * 2 + 2);\n\treturn res;\n}\n\nint subTask3() {\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint cap = 1;\n\t\tif (i == 1 || i == n) cap = INT_MAX;\n\n\t\taddEdge(i, i + n, cap);\n\t\tif (f[i] == maxLength) addEdge(i + n, t, cap);\n\t\tif (f[i] == 1) addEdge(s, i, cap);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j] == f[i] - 1 && a[j] <= a[i]) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\tint res = dinic(s, t, n * 2 + 2);\n\treturn res;\n}\n\nint main() {\n//\tfreopen(\"alis.in\", \"r\", stdin);\n//\tfreopen(\"alis.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tprintf(\"%d\\n\", maxLength = subTask1());\n\tif (maxLength == 1) {\n\t\tprintf(\"%d\\n%d\", n, n);\n\t} else {\n\t\tprintf(\"%d\\n\", subTask2());\n\t\tfor (int i = 0; i < n * 2 + 2; i++) {\n\t\t\tfor (Edge *&e = N[i].e, *ne; e; ne = e->ne, delete e, e = ne);\n\t\t\tN[i].e = N[i].c = NULL;\n\t\t\tN[i].level = 0;\n\t\t}\n\t\tprintf(\"%d\\n\", subTask3());\n\t}\n\n//\tfclose(stdin);\n//\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","tags":["网络流"],"categories":["OI"]},{"title":"「网络流24题」最小路径覆盖","url":"%2Froad-network-flow%2F","content":"\n给定有向图 $ G = (V, E) $。设 $ P $ 是 $ G $ 的一个简单路（顶点不相交）的集合。如果 $ V $ 中每个顶点恰好在 $ P $ 的一条路上，则称 $ P $ 是 $ G $ 的一个路径覆盖。$ P $ 中路径可以从 $ V $ 的任何一个顶点开始，长度也是任意的，特别地，可以为 $ 0 $。$ G $ 的最小路径覆盖是 $ G $ 的所含路径条数最少的路径覆盖。\n\n设计一个有效算法求一个有向无环图 $ G $ 的最小路径覆盖。\n\n<!--more-->\n\n# 题解\n关于路径覆盖的定义，这题题面里说的比较好。\n\n路径覆盖就是用若干条路径来覆盖一个DAG上的所有点，但是不同路径上的各个顶点不可以重复\n特别的，一条路径的长度可以为 $ 1 $ ，也就是一个顶点可以算作一条路径\n\n最小路径覆盖的意义就是最小化路径覆盖集的大小\n\n考虑把一个顶点拆成两个，分属集合 $ A $ 以及集合 $ B $，若原图中有某一条边 $ (u, v) $,则在网络中建立$ (u \\in A, v \\in B) $，在这个二分图上找最大匹配，最终答案就是原图点数减去最大匹配数。\n\n这样做的道理是什么呢?\n考虑路径覆盖的定义，我们每将原图中的一条边 $ (u, v) $ 加入路径覆盖的条件是:\n保证对于路径覆盖集中的任意其他路径，保证不存在 $ s \\in V, (u, s) $;\n这和二分图匹配的定义相似，所以我们拆点做二分图匹配\n\n黄学长这题题解里有句话说的非常好：如果无匹配，显然要 $ n $ 条路径才能覆盖所有点，两个点匹配意味着将可以把它们用一条路径覆盖，路径数就可以减 $ 1 $\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <new>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 400;\nconst int MAXM = 6000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint level, id;\n\tbool vis;\n} N[MAXN + 5];\n\nstruct Edge {\n\tNode *fr, *to;\n\tEdge *ne, *rev;\n\tint cap, flow;\n\t\n\tEdge() {}\n\tEdge(Node *fr, Node *to, int cap) : fr(fr), to(to), ne(fr->e), cap(cap), flow(0) {}\n};\n\ninline void addEdge(int fr, int to, int cap) {\n\tN[fr].e = new Edge(&N[fr], &N[to], cap);\n\tN[to].e = new Edge(&N[to], &N[fr], 0);\n\n\tN[fr].e->rev = N[to].e, N[to].e->rev = N[fr].e;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\t\tif (e->cap > e->flow && !e->to->level) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->ne) {\n\t\t\tif (e->cap > e->flow && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->cap - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->rev->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint flow;\n\t\t\tif ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n\t\t}\n\t\treturn res;\n\t}\n} dinic;\n\nvoid printPath(Node *v) {\n\tprintf(\"%d \", v->id);\n\n\tv->vis = true;\n\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\tif (e->flow == e->cap && e->to->id != 0 && !N[e->to->id].vis) {\n\t\t\tprintPath(&N[e->to->id]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\t// let [1, n] equal to the set A, [n + 1, n * 2] equal to the set B;\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1), addEdge(i + n, t, 1), N[i].id = N[i + n].id = i;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v + n, 1);\n\t}\n\tint res = dinic(s, t, n * 2 + 2);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!N[i].vis) {\n\t\t\tprintPath(&N[i]);\n\t\t\tputs(\"\");\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", n - res);\n\n\treturn 0;\n}\n```\n\n","tags":["二分图匹配"],"categories":["OI"]},{"title":"「网络流24题」太空飞行计划 - 最大权闭合子图","url":"%2Fshuttle%2F","content":"\nW 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 $ E = \\{ E_1, E_2, \\cdots, E_m \\} $，和进行这些实验需要使用的全部仪器的集合 $ I = \\{ I_1, I_2, \\cdots, I_n \\} $。实验 $ E_j $ 需要用到的仪器是 $ I $ 的子集 $ R_j \\subseteq I $。\n\n配置仪器 $ I_k $ 的费用为 $ c_k $ 美元。实验 $ E_j $ 的赞助商已同意为该实验结果支付 $ p_j $ 美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。\n\n对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。\n\n<!--more-->\n\n# 链接\n[LYOI #118](https://ly.men.ci/problem/118)\n[COGS #727](http://cogs.pro/cogs/problem/problem.php?pid=727)\n\n# 题解\n源点与正权点连边，容量为点权值\n正权点与负权点连边，容量为负无穷\n负权点与汇点连边，容量为点权值绝对值\n最大权闭合子图的点权和 = 正点权和 - 最大流\n\n上面讲述了一种通过最大权闭合子图来思考的模式，具体证明见胡伯涛论文。\n\n按照上述方式建图，考虑这张图中割的意义。\n\n割中不应该存在实验连向仪器的边，因为它们的容量是正无穷。那么如果一条源点到实验的边被割开，意味着这个实验被抛弃不做，一条仪器到汇点的边被割去了，意味着这个仪器会被使用，也就是最后的收益要减去仪器的价格。这样求出最小割以后，就可以最小化弃置实验的价值和使用仪器的代价，最终把期望总收益（所有实验的收益和）减去我们得到的最小代价，得到的就是最终的答案。\n\n求最小割:\n在包含负权边的网络中沿着未满流的边 bfs，\n到达的点打上标记，一条跨越标记点和未标记点的边属于最小割。\n\n# 代码\n\n我才不要用什么 `set_difference` 呢。\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <new>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint level;\n\tbool chosen, flag;\n\n\tNode() : e(NULL), c(NULL), level(0), chosen(false), flag(false) {};\n} N[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *fr, *to;\n\tEdge *ne, *rev;\n\tint cap, flow;\n\tbool isCut;\n\n\tEdge() {}\n\tEdge(Node *fr, Node *to, int cap) : fr(fr), to(to), ne(fr->e), cap(cap), flow(0), isCut(false) {}\n} _pool[MAXN * MAXM + MAXN + MAXM + 1000], *_end;\n\ninline void init() {\n\t_end = _pool;\n}\n\ninline void addEdge(int fr, int to, int cap) {\n\tN[fr].e = new (_end++) Edge(&N[fr], &N[to], cap);\n\tN[to].e = new (_end++) Edge(&N[to], &N[fr], 0);\n\n\tN[fr].e->rev = N[to].e, N[to].e->rev = N[fr].e;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i <= n; i++) N[i].c = N[i].e, N[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\t\tif (e->cap > e->flow && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->ne) {\n\t\t\tif (e->cap > e->flow && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->cap - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->rev->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint flow;\n\t\t\tif ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n\t\t}\n\t\treturn res;\n\t}\n} dinic;\n\nvoid minCut(int s) {\n\tstd::queue<Node *> q;\n\tq.push(&N[s]);\n\tN[s].flag = true;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->ne) {\n\t\t\tif (e->flow < e->cap && !e->to->flag) {\n\t\t\t\te->to->flag = true;\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (Edge *e = _pool; e != _end; e++) {\n\t\tif (e->fr->flag && !e->to->flag) e->isCut = true;\n\t}\n}\n\nint main() {\n\tinit();\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\\n\", &m, &n);\n\tconst int s = 0, t = n + m + 1;\n    for (int i = 1; i <= m; i++) {\n        std::string str;\n        std::getline(std::cin, str);\n\n        std::stringstream ss;\n        ss << str;\n\n        int x;\n        ss >> x;\n        sum += x;\n        addEdge(s, n + i, x);\n\n        while (!ss.eof()) {\n            ss >> x;\n            addEdge(n + i, x, INT_MAX);\n        }\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        addEdge(i, t, x);\n    }\n\n\tint maxFlow = dinic(s, t, t);\n\tminCut(s);\n\n\tfor (Edge *e = _pool; e != _end; e++) {\n\t\tif (e->isCut) {\n\t\t\tif (e->fr - N == s) e->to->chosen = true;\n\t\t\tif (e->to - N == t) e->fr->chosen = true;\n\t\t}\n\t}\n\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tif (!N[i].chosen) printf(\"%d \", i - n);\n\t}\n\n\tputs(\"\");\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].chosen) printf(\"%d \", i);\n\t}\n\n\tprintf(\"\\n%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n\n","tags":["最大权闭合子图"],"categories":["OI"]},{"title":"「CQOI 2015」任务查询系统 - 可持久化权值线段树","url":"%2Fbzoj3932%2F","content":"\n给定若干个任务 $ (s_i, e_i, p_i) $，表示该任务从第 $ s_i $ 秒运行到第 $ e_i $ 秒，它的价值为 $ p_i $，每次询问给定一个 $ x $ 并由你计算一个 $ k $，查询第 $ x $ 秒时价值最小的 $ k $ 个任务的价值之和，如果第 $ x $ 秒时运行的任务不足 $ k $ 个，则输出此时所有任务的价值和。\n\n<!--more-->\n\n# 题解\n这里用一种差分的思想来建主席树。\n\n考虑当我们接受到一个任务时，它会从第 $ s_i $ 秒存在到第 $ e_i $ 秒，而且查询是查询第 $ x $ 秒存在的的所有任务，所以我们对于时间建主席树，对于一个任务 $ i $，我们在建第 $ s_i $ 棵线段树时把它插入主席树，在建 $ e_i + 1  $ 棵线段树时把它删掉，这样我们可以保证第 $ i $ 棵线段树中存储的任务是所有在第 $ i $ 秒中运行的任务，剩下的就是主席树上二分查询了。。\n\n注意，相同优先级的任务可能有多个。\n\n顺便吐个槽，感觉这种写法叫做可持久化权值线段树更好。。\n\n# 代码\n\n奇怪的类名实例名什么的不要在意啦 qwq\n\n```c++\n#include <cassert>\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Mission {\n\tint val;\n\tbool isDelete;\n\n\tMission() {}\n\tMission(int val, bool isDelete) : val(val), isDelete(isDelete) {}\n};\n\nstd::vector<Mission> a[MAXM + 50];\n\nstruct PresentTreeByGoldYeInInternationalOlympidInInformaticsHellc {\n\tstruct Node {\n\t\tint l, r;\n\t\tNode *lc, *rc;\n\t\tint size, sum;\n\n\t\tNode() {}\n\t\tNode(int l, int r, Node *lc, Node *rc) : l(l), r(r), lc(lc), rc(rc), size(lc->size + rc->size), sum(lc->sum + rc->sum) {}\n\t\tNode(int l, int r, Node *lc, Node *rc, int size, int sum) : l(l), r(r), lc(lc), rc(rc), size(size), sum(sum) {}\n\t} *roots[MAXN + 50], *null, _pool[MAXN * 200], *_curr;\n\n\tint l, r;\n\n\tPresentTreeByGoldYeInInternationalOlympidInInformaticsHellc() {\n\t\tnull = new Node(-1, -1, NULL, NULL, 0, 0);\n\t\tnull->lc = null, null->rc = null;\n\t}\n\n\tNode *insert(Node *v, int l, int r, int x, bool isDelete) {\n\t\tif (!isDelete) {\n\t\t\tif (x < l || x > r) return v;\n\t\t\telse if (l == r) return new (_curr++) Node(l, r, null, null, v->size + 1, v->sum + x);\n\t\t\telse {\n\t\t\t\tint mid = l + (r - l) / 2;\n\t\t\t\treturn new (_curr++) Node(l, r, insert(v->lc, l, mid, x, isDelete), insert(v->rc, mid + 1, r, x, isDelete));\n\t\t\t}\n\t\t} else {\n\t\t\tif (x < l || x > r) return v;\n\t\t\telse if (l == r) return new (_curr++) Node(l, r, null, null, v->size - 1, v->sum - x);\n\t\t\telse {\n\t\t\t\tint mid = l + (r - l) / 2;\n\t\t\t\treturn new (_curr++) Node(l, r, insert(v->lc, l, mid, x, isDelete), insert(v->rc, mid + 1, r, x, isDelete));\n\t\t\t}\n\t\t}\n\t}\n\n/*\n\tvoid update(Node *v, int x, bool isDelete) {\n\t\tif (!isDelete) {\n\t\t\tv->size++, v->sum += x;\n\t\t\tif (v->l == v->r) return;\n\t\t\telse {\n\t\t\t\tint mid = v->l + (v->r - v->l) / 2;\n\t\t\t\tif (x <= mid) update(v->lc, x, isDelete);\n\t\t\t\telse update(v->rc, x, isDelete);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size--, v->sum -= x;\n\t\t\tif (v->l == v->r) return;\n\t\t\telse {\n\t\t\t\tint mid = v->l + (v->r - v->l) / 2;\n\t\t\t\tif (x <= mid) update(v->lc, x, isDelete);\n\t\t\t\telse update(v->rc, x, isDelete);\n\t\t\t}\n\t\t}\n\t}\n*/\n\n\tvoid build(std::vector<Mission> *a, int n, int l, int r) {\n\t\t_curr = _pool;\n\t\troots[0] = null;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tstd::vector<Mission>::iterator it = a[i].begin();\n\t\t\tif (it == a[i].end()) { roots[i] = roots[i - 1]; continue; }\n\t\t\telse {\n\t\t\t\troots[i] = insert(roots[i - 1], l, r, it->val, it->isDelete);\n\t\t\t\tit++;\n\t\t\t\tfor (; it != a[i].end(); it++) {\n\t\t\t\t\tassert(it != a[i].end());\n\t\t\t\t\troots[i] = insert(roots[i], l, r, it->val, it->isDelete);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis->l = l, this->r = r;\n\t}\n\n\tlong long query(int qr, int k) {\n\t\tlong long ans = 0, lsize;\n\t\tNode *v = roots[qr];\n\n\t\tif (k >= v->size) return v->sum;\n\n\t\tlsize = v->lc->size;\n\t\twhile (v->l != v->r) {\n\t\t\tif (k <= lsize) {\n\t\t\t\tv = v->lc;\n\t\t\t\tlsize = v->lc->size;\n\t\t\t} else {\n\t\t\t\tk -= lsize;\n\t\t\t\tans += v->lc->sum;\n\t\t\t\tv = v->rc;\n\t\t\t\tlsize = v->lc->size;\n\t\t\t}\n\t\t}\n\t\tif (k) ans += v->l * k;\n\t\treturn ans;\n\t}\n} presentTreeByGoldYeInInternationalOlympidInInformaticsHellc;\n\nint main() {\n\tint m, n;\n\tscanf(\"%d %d\", &m, &n);\n\tint max = INT_MIN, min = INT_MAX;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint s, t, val;\n\t\tscanf(\"%d %d %d\", &s, &t, &val);\n\t\tmax = std::max(max, val);\n\t\tmin = std::min(min, val);\n\t\ta[s].push_back(Mission(val, false));\n\t\ta[t + 1].push_back(Mission(val, true));\n\t}\n\n\tpresentTreeByGoldYeInInternationalOlympidInInformaticsHellc.build(a, n, min, max);\n\n\tlong long pre = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x, k;\n\t\tlong long a, b, c;\n\t\tscanf(\"%d %lld %lld %lld\", &x, &a, &b, &c);\n\t\tk = 1 + (a * pre + b) % c;\n\t\tpre = presentTreeByGoldYeInInternationalOlympidInInformaticsHellc.query(x, k);\n\t\tprintf(\"%lld\\n\", pre);\n\t}\n\treturn 0;\n}\n```\n","tags":["可持久化"],"categories":["OI"]},{"title":"「HDU 5791」Two - DP","url":"%2Fhdu5791%2F","content":"\n给定两个字符串 $ A $ 和 $ B $，求两个字符串的公共子序列个数。\n\n<!--more-->\n\n# 题解\n设 $ f(i, j) $ 为 $ A $ 串前 $ i $ 位和 $ B $ 串前 $ j $ 位的公共子序列个数，则\n$$\nf(i, j) = \n\\begin{cases}\nf(i, j - 1) + f(i - 1, j) + 1 & A_i = B_j\\\\\nf(i, j - 1) + f(i - 1, j) - f(i - 1, j - 1) & A_i \\neq B_j\n\\end{cases}\n$$\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1005;\nconst int MOD = 1000000007;\n\nint a[MAXN + 1], b[MAXN + 1], dp[MAXN + 1][MAXN + 1], n, m;\n\nint main() {\n\twhile (scanf(\"%d %d\", &n, &m) != EOF) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tmemset(b, 0, sizeof(b));\n\t\tmemset(dp, 0, sizeof(dp));\n\n\t\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\t\tfor (int i = 1; i <= m; i++) scanf(\"%d\", &b[i]);\n\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tif (a[i] == b[j]) dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + 1) % MOD;\n\t\t\t\telse dp[i][j] = ( ( (dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]) ) % MOD + MOD ) % MOD;\n\t\t\t}\n\t\tprintf(\"%d\\n\", dp[n][m] % MOD);\n\t}\n\treturn 0;\n}\n```\n","tags":["DP"],"categories":["OI"]},{"title":"「HDU5900」QSC and Master - 区间DP","url":"%2Fhdu5900%2F","content":"\n给定 $ n $ 个二元组，每个二元组由键和值构成，当且仅当相邻的两个二元组的键互质的时候，它们可以被消去，这时得到的价值为它们值的和，然后两边的元素链接在一起。\n\n求能够获得的最大价值。\n\n<!--more-->\n\n# 题解\n\n两遍 dp ，第一遍处理出某个区间 [l, r] 中的 value 能否被全部得到，方法如下:\n```plain\nlet canEarnAll(l, r) equal to if all the value in [l, r] can be earned;\ncanEarnAll(l, r) |= (canEarnAll(l + 1, r - 1) & (gcd(l, r) != 1));\nfor (int k = l; k < r; k++) canEarnAll |= (canEarnAll(l, k) & canEarnAll(k + 1, r));\n```\n\n然后按照做出来的结果继续 dp，方法如下:\n```plain\nlet maxValue equal to the max value can be earned in [l, r];\nif (canEarnAll(l, r) == true) maxValue(l, r) = sumValue(l, r);\nelse for (int k = l; k < r; k++) maxValue(l, r) = max(maxValue(l, r), maxValue(l, k) + maxValue(k + 1, r));\n```\n\n最后 `maxValue(1, n)` 即为答案。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500;\n\nlong long f[MAXN + 1][MAXN + 1], key[MAXN + 1], val[MAXN + 1], ans = 0;\nbool canEarnAll[MAXN + 1][MAXN + 1];\nint n;\n\nlong long gcd(long long a, long long b) {\n    return !b ? a : gcd(b, a % b);\n}\n\nint main() {\n    int T_T;\n    scanf(\"%d\", &T_T);\n    for (int i = 1; i <= T_T; i++) {\n        memset(f, 0, sizeof(f));\n        memset(canEarnAll, 0, sizeof(canEarnAll));\n        scanf(\"%d\", &n);\n        for (int i = 1; i <= n; i++) scanf(\"%lld\", &key[i]);\n        for (int i = 1; i <= n; i++) scanf(\"%lld\", &val[i]), val[i] += val[i - 1], canEarnAll[i][i - 1] = true;\n        canEarnAll[n + 1][n] = true;\n        \n        for (int len = 2; len <= n; len++) {\n            for (int i = 1; i <= n - len + 1; i++) {\n                int j = i + len - 1;\n                    canEarnAll[i][j] |= canEarnAll[i + 1][j - 1] & (gcd(key[i], key[j]) != 1);\n                    if (!canEarnAll[i][j]) for (int k = i; k < j; k++) canEarnAll[i][j] |= canEarnAll[i][k] & canEarnAll[k + 1][j];\n            }\n        }\n\n        for (int len = 2; len <= n; len++) {\n            for (int i = 1; i <= n - len + 1; i++) {\n                int j = i + len - 1;\n                if (canEarnAll[i][j]) f[i][j] = val[j] - val[i - 1];\n                else for (int k = i; k < j; k++) f[i][j] = std::max(f[i][j], f[i][k] + f[k + 1][j]);\n            }\n        }\n\n        printf(\"%lld\\n\", f[1][n]);\n    }\n    return 0;\n}\n```\n\n","tags":["区间DP"],"categories":["OI"]},{"title":"「BZOJ3223」文艺平衡树","url":"%2Fbzoj3223%2F","content":"\n给定一个序列，以及若干次反转区间的操作，要求输出经过若干次反转操作之后的序列。\n\n<!--more-->\n\n# 题解\n用 `Splay` 维护序列即可。\n\n对于一棵平衡树，满足旋转后其中序遍历始终不变的性质，所以我们按照序列来确定初始的 `Splay` ，这样做的话， `Splay` 的每个节点代表的是序列上的某个位置。\n\n而后，对于每次反转，其实就是反转某一棵中序遍历为 $ [l, r] $ 的子树，这里我们将 $ l - 1 $ 位置上的节点旋转到根，将 $ r + 1 $ 位置上的节点旋转到根的右子树，由于这棵 `Splay` 的中序遍历就是原来的序列，那么 $ r + 1 $ 位置上的节点的左子树的中序遍历一定是我们要的 $ [l, r] $ 这段区间，将这个节点打上反转标记即可。\n\n注意，访问某个节点的儿子的时候一定要记得下放标记。\n\n此外，如果要在函数内修改参数的值，不要忘记引用。。\n\n# 代码\n```c++\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\n#ifdef DBG\n\tconst int MAXN = 10;\n#else\n\tconst int MAXN = 100000;\n#endif\n\nint a[MAXN + 1];\n\nstruct Splay {\n\tstruct Node {\n\t\tNode *c[2], *fa, **root;\n\t\tint size, x;\n\t\tbool isBound, rev;\n\n\t\tNode(Node *fa, Node **root, int x, bool isBound = false) :\n\t\t\tfa(fa), root(root), size(1), x(x), isBound(isBound), rev(false) {\n\t\t\t\tc[0] = c[1] = NULL;\n\t\t}\n\n\t\tNode *pushDown() {\n\t\t\tif (rev) {\n\t\t\t\tstd::swap(c[0], c[1]);\n\t\t\t\tif (c[0]) c[0]->rev ^= 1;\n\t\t\t\tif (c[1]) c[1]->rev ^= 1;\n\t\t\t\trev = false;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (c[0] ? c[0]->size : 0) + (c[1] ? c[1]->size : 0) + 1;\n\t\t}\n\n\t\tint relation() {\n\t\t\treturn this == fa->c[1];\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tpushDown();\n\n\t\t\tNode *old = fa;\n\t\t\tint x = relation();\n\n\t\t\tif (old->fa) old->fa->c[fa->relation()] = this;\n\t\t\tfa = old->fa;\n\n\t\t\told->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->fa = old;\n\n\t\t\tc[x ^ 1] = old;\n\t\t\told->fa = this;\n\n\t\t\told->maintain(), maintain();\n\t\t\tif (!fa) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *target = NULL) {\n\t\t\twhile (fa != target) {\n\t\t\t\tif (fa->fa) fa->fa->pushDown();\n\t\t\t\tfa->pushDown();\n\n\t\t\t\tif (fa->fa == target) rotate();\n\t\t\t\telse if (relation() == fa->relation()) fa->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint lSize() {\n\t\t\treturn c[0] ? c[0]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {}\n\n\tvoid build(int *a, int n) {\n\t\troot = build(a, 1, n, NULL);\n\n\t\tNode **v = &root, *fa = NULL;\n\t\twhile (*v) {\n\t\t\tfa = *v;\n\t\t\tfa->size++;\n\t\t\tv = &(*v)->c[0];\n\t\t}\n\t\t*v = new Node(fa, &root, 0, true);\n\n\t\tv = &root, fa = NULL;\n\t\twhile (*v) {\n\t\t\tfa = *v;\n\t\t\tfa->size++;\n\t\t\tv = &(*v)->c[1];\n\t\t}\n\t\t*v = new Node(fa, &root, 0, true);\n\t}\n\n\tNode *build(int *a, int l, int r, Node *fa) {\n\t\tif (l > r) return NULL;\n\n\t\tint mid = (l + r) >> 1;\n\n\t\tNode *v = new Node(fa, &root, a[mid - 1]);\n\t\tif (l != r) {\n\t\t\tv->c[0] = build(a, l, mid - 1, v);\n\t\t\tv->c[1] = build(a, mid + 1, r, v);\n\t\t\tv->maintain();\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\n\t\twhile (k != v->pushDown()->lSize() + 1) {\n\t\t\tif (k < v->lSize() + 1) v = v->c[0];\n\t\t\telse k -= v->lSize() + 1, v = v->c[1];\n\t\t}\n#ifdef DBG\n\t\tprintf(\"Result before splay is %d\\n\", v->x);\n#endif\n\n\t\tv->splay();\n\n#ifdef DBG\n\t\tassert(root == v);\n\t\tprintf(\"Result is %d\\n\", v->x);\n\t\tprintf(\"------------------------------------------\\n\");\n#endif\n\t\treturn root;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *epl = select(l - 1), *epr = select(r + 1);\n\t\tepl->splay();\n\t\tepr->splay(epl);\n\t\treturn epr->c[0];\n\t}\n\n\tvoid reverse(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\trange->rev ^= 1;\n\t}\n\n\tvoid getAns(int *a) {\n\t\tdfs(a, root);\n\t}\n\n\tvoid dfs(int *&a, Node *v) {\n\t\tif (v) {\n\t\t\tv->pushDown();\n\n\t\t\tdfs(a, v->c[0]);\n\n\t\t\tif (!v->isBound) *a++ = v->x;\n\n\t\t\tdfs(a, v->c[1]);\n\t\t}\n\t}\n\n#ifdef DBG\n\tvoid print(Node *v) {\n\t\tif (v) {\n\t\t\tv->pushDown();\n\t\t\tprint(v->c[0]);\n\t\t\tprintf(\"Size : %d, value : %d\\n\", v->size, v->x);\n\t\t\tprint(v->c[1]);\n\t\t}\n\t}\n#endif\n\n} splay;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) a[i] = i + 1;\n\n\tsplay.build(a, n);\n#ifdef DBG\n\tsplay.print(splay.root);\n\tprintf(\"--------------------------------------\\n\");\n#endif\n\n\twhile (m--) {\n\t\tint l, r;\n\t\tscanf(\"%d %d\", &l, &r);\n\t\tsplay.reverse(l, r);\n#ifdef DBG\n\t\tsplay.print(splay.root);\n\t\tprintf(\"---------------------------------------------\\n\");\n#endif\n\t}\n\n\tsplay.getAns(a);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d \", a[i]);\n\n\treturn 0;\n}\n```\n\n","tags":["Splay"],"categories":["OI"]},{"title":"愤怒的小鸟 - 状态压缩，BFS，NOIP2016","url":"%2FNOIP2016-angrybirds%2F","content":"\nKiana最近沉迷于一款神奇的游戏无法自拔。\n\n简单来说，这款游戏是在一个平面上进行的。\n\n有一架弹弓位于 $ (0, 0) $ 处，每次Kiana可以用它向第一象限发射一只小鸟，小鸟们的飞行轨迹均为形如 $ y = ax ^ 2 + bx $ 的曲线，其中 $ a $，$ b $ 是Kiana指定的参数，且必须满足 $ a < 0 $。\n\n当小鸟落回地面（即 $ x $ 轴）时，它就会瞬间消失。\n\n在游戏的某个关卡里，平面的第一象限中有 $ n $ 只绿色的猪，其中第 $ i $ 只猪所在的坐标为 $ (x_i, y_i) $。\n\n如果某只小鸟的飞行轨迹经过了$ (x_i, y_i) $，那么第 $ i $ 只猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；\n\n如果一只小鸟的飞行轨迹没有经过$ (x_i, y_i) $，那么这只小鸟飞行的全过程就不会对第 $ i $ 只猪产生任何影响。\n\n例如，若两只猪分别位于 $ (1, 3) $ 和 $ (3, 3) $，Kiana可以选择发射一只飞行轨迹为 $ y = -x ^ 2 + 4x $ 的小鸟，这样两只猪就会被这只小鸟一起消灭。\n\n而这个游戏的目的，就是通过发射小鸟消灭所有的猪。\n\n这款神奇游戏的每个关卡对来说都很难，所以Kiana还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在「输入格式」中详述。\n\n假设这款游戏一共有 $ T $ 个关卡，现在Kiana想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的猪。由于她不会算，所以希望由你告诉她。\n\n<!--more-->\n\n# 链接\n[LYOI#104](https://ly.men.ci/problem/104/)\n\n# 题解\n## 状压\n\n因为猪的数量最多只有 $ 18 $ 只，所以自然而然地想到状压，这里说一下本题状压的思想。\n\n我们用一个形如 `011011001100110010` 的二进制数，表示游戏中现存的猪，其中从左往右数第 $ i $ 位，表示的是编号为 $ i $ 的猪的状态，该位为 $ 0 $ ，表示这只猪死亡或本身就不存在，反之表示这只猪现在还活着。\n\n对于一条抛物线（**真·题解**中会提到抛物线相关），我们也用一个类似的二进制数记录它的信息，即它的从左往右第 $ i $ 位为 $ 1 $，表示编号为 $ i $ 的猪可以被这条抛物线杀死，反之此抛物线不会对这只猪造成任何影响。\n\n用位运算乱搞就可以表示杀猪了 QwQ.\n\n## 真·题解\n\n由于弹弓的位置确定，为 $ (0,0) $，则可以由两个点唯一确定出一条形如题目描述中 $ a x ^ 2 + b y = 0 $ 抛物线，枚举每两只猪的坐标，求出 $ n^2 $ 条抛物线，并舍去其中不合题意的抛物线（即 $ a > 0 $ 的抛物线），使用一个二进制数来记录每条合法抛物线可击杀的猪。\n\n可以证明，这样枚举一定最优，因为每条击杀猪数目超过 $ 2 $ 的抛物线，一定会击杀至少两只猪，而所有可至少击杀两只猪的合法抛物线都在枚举的过程中被求出，则如此枚举可以所有击杀猪的数量最多的抛物线。\n\n但是这样还会有几只猪不在我们枚举到的任何一条合法的抛物线上，对于这种猪，我们为其虚拟出一条抛物线，我们不需要知道其方程，只需要标记这条抛物线可以击杀对应的猪即可。\n\n然后建立状态图进行 BFS 即可。\n\n当然在操作的过程中可能会用到各种各样的位运算操作，状压当中常见的奇技淫巧。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\nconst int MAXN = 18 + 3;\nconst int MAXS = (1 << (MAXN + 1));\nconst double EPS = 1e-6; // 精度搞的高一点\n\nstruct Point {\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n} a[MAXN];\n\ninline bool dcmp (double x) {\n    return fabs(x) <= EPS;\n}\n\ninline bool dcmp (double x, double y) {\n    return dcmp(x - y);\n} // 处理浮点数时常用的根据 EPS 判断相等的技巧\n\nstruct Line {\n    double a, b;\n    bool valid;\n    unsigned int kill;\n\n    Line(unsigned int kill = 0): a(0), b(0), valid(true), kill(kill) {}\n\n    bool operator<(const Line &other) const {\n        return kill > other.kill;\n    }\n\n    bool operator==(const Line &other) const {\n        return kill == other.kill;\n    }\n} lines[MAXN * MAXN];\n\nstruct Node {\n    bool vis;\n    int dist;\n} N[MAXS];\n\nint n, cmd, limit, lineCnt;\n\ninline int bfs (int status) {\n    if (!status) return 0;\n\n    queue<int> q;\n    q.push(status);\n    N[status].vis = true;\n    N[status].dist = 0;\n\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n\n        if (N[v].dist == limit) continue;\n\n        for (int i = 1; i <= lineCnt; i++) {\n            Line &l = lines[i];\n            if (l.valid && (l.kill & status)) {\n                int u = v;\n                u &= ~l.kill; // 状压通过位运算搞掉\n\n                if (!N[u].vis) {\n                    N[u].vis = true;\n                    N[u].dist = N[v].dist + 1;\n                    if (!u) return N[u].dist;\n                    q.push(u);\n                }\n            }\n        }\n    }\n\n    return n;\n}\n\ninline Line getLine (const Point &a, const Point &b) {\n    Line l;\n    l.a = (a.x * b.y - b.x * a.y) / (a.x * b.x * b.x - b.x * a.x * a.x);\n    l.b = (a.y - l.a * a.x * a.x) / a.x;\n\n    return l;\n}\n\ninline bool onLine (const Line &l, const Point &a) {\n    return dcmp(l.a * a.x * a.x + l.b * a.x, a.y);\n}\n\ninline int solve () {\n    bool flags[MAXN];\n    for (int i = 1; i <= n; i++) flags[i] = false;\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            if (dcmp(a[i].x, a[j].x)) continue;\n            Line l = getLine(a[i], a[j]);\n            if (l.a >= 0) continue;\n\n            flags[i] = flags[j] = true;\n            lines[++lineCnt] = l;\n        }\n    }\n\n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (onLine(lines[i], a[j])) {\n                lines[i].kill |= (1u << (j - 1));\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        if (!flags[i]) {\n            lines[++lineCnt] = Line(1u << (i - 1)); // 或运算标记能击杀的猪的编号\n        }\n    }\n\n    sort(lines + 1, lines + lineCnt + 1);\n\n    for (int i =  1; i <= lineCnt; i++) {\n        for (int j = i + 1; j <= lineCnt; j++) {\n            if ((lines[i].kill | lines[j].kill) == lines[i].kill) {\n                lines[j].valid = false;\n            } // 如果抛物线i能击杀抛物线j能击杀的所有猪，而且能击杀抛物线j不能击杀的猪，则使用抛物线j明显不优\n        }\n    }\n\n    for (unsigned int i = 0; i < (1u << n); i++) {\n        N[i].vis = false;\n    }\n\n    return bfs((1u << n) - 1);\n}\n\nint main() {\n    freopen(\"angrybirds.in\", \"r\", stdin);\n    freopen(\"angrybirds.out\", \"w\", stdout);\n\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        scanf(\"%d %d\", &n, &cmd);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%lf %lf\", &a[i].x, &a[i].y);\n        }\n        lineCnt = 0;\n\n        if (cmd == 1) {\n            limit = ceil(double(n) / 3 + 1);\n        } else {\n            limit = n;\n        }\n\n        printf(\"%d\\n\", solve());\n    }\n\n\tfclose(stdin);\n    fclose(stdout);\n}\n```\n\n最后写完这题才发现，貌似那个作弊指令没有什么卵用\n","tags":["BFS"],"categories":["OI"]},{"title":"蚯蚓 - 单调队列，NOIP2016","url":"%2FNOIP2016-earthworm%2F","content":"\n本题中，我们将用符号 $ \\lfloor c \\rfloor $ 表示对 $ c $ 向下取整，例如：$ \\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3 $。\n\n蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。\n\n蛐蛐国里现在共有 $ n $ 只蚯蚓（$ n $ 为正整数）。每只蚯蚓拥有长度，我们设第 $ i $ 只蚯蚓的长度为 $ a_i $（$ i = 1, 2, \\ldots , n $），并保证所有的长度都是非负整数（即：可能存在长度为 $ 0 $ 的蚯蚓）。\n\n每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 $ p $（是满足 $ 0 < p < 1 $ 的有理数）决定，设这只蚯蚓长度为 $ x $，神刀手会将其切成两只长度分别为 $ \\lfloor px \\rfloor $ 和 $ x - \\lfloor px \\rfloor $ 的蚯蚓。特殊地，如果这两个数的其中一个等于 $ 0 $，则这个长度为 $ 0 $ 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 $ q $（是一个非负整常数）。\n\n蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 $ m $ 秒才能到来 ……（$ m $ 为非负整数）\n\n蛐蛐国王希望知道这 $ m $ 秒内的战况。具体来说，他希望知道：\n\n* $ m $ 秒内，每一秒被切断的蚯蚓被切断前的长度（有 $ m $ 个数）；\n* $ m $ 秒后，所有蚯蚓的长度（有 $ n + m $ 个数）。\n\n蛐蛐国王当然知道怎么做啦！但是他想考考你 ……\n\n<!--more-->\n\n# 链接\n[LYOI#103](https://ly.men.ci/problem/103)\n\n# 题解\n当 $ q = 0 $ 时，首先将蚯蚓排序，然后每次将切割后的两段蚯蚓分别放入两个队列中，则三个队列始终是单调的。设第 $ i $ 次取出并切开的蚯蚓的长度为 $ a_i $，切开之后两段的长度分别为 $ l_i $ 和 $ r_i $，那么对于第 $ i + 1 $ 取出的蚯蚓，一定有 $ a_{i + 1} < a_i $，这是因为我们每次取最长的来切并且所有的蚯蚓长度只会减少，由此可得，一定有 $ l_{i + 1} < l_i, r_{i + 1} < r_i $。\n\n当 $ q \\neq 0 $时，每秒钟除了被切的蚯蚓，其他所有蚯蚓长度增加 $ q $，可以将其余蚯蚓增加 $ q $ 改为被切开的两段减少 $ q $ ，此时三个序列仍满足单调性，正确性显然。\n\n时间复杂度为 $ O(n\\log n + m) $，如果被辣鸡stl中队列卡常，可以尝试手写队列。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nconst int MAXN = 100000;\nconst int MAXM = 70000000;\n\nqueue<int> q[3];\n\nint getMax () {\n    int res = -1;\n    for (int i = 0; i < 3; i++) if (!q[i].empty() && (res == -1 || q[i].front() > q[res].front())) res = i;\n    return res;\n}\n\nbool cmp (int a, int b) { return a > b; }\n\nint len[MAXN + 1];\nint main () {\n\tfreopen(\"earthworm.in\", \"r\", stdin);\n\tfreopen(\"earthworm.out\", \"w\", stdout);\n\n    int n, m, k, u, v, t;\n\tscanf(\"%d %d %d %d %d %d\", &n, &m, &k, &u, &v, &t);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &len[i]);\n\tsort(len, len + n, cmp);\n\tfor (int i = 0; i < n; i++) q[0].push(len[i]);\n\n\tint d = 0, frt;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint j = getMax();\n\t\tfrt = q[j].front();\n\t\tq[j].pop();\n\t\tfrt += d;\n\n\t\tif (i % t == 0) printf(\"%d \", frt);\n\n\t\tint a = static_cast<long long>(frt) * u / v, b = frt - a;\n\t\td += k;\n\t\ta -= d, b -= d;\n\n\t\tq[1].push(a); q[2].push(b);\n\t}\n\n\tprintf(\"\\n\");\n\n\tfor (int i = 1; i <= n + m; i++) {\n\t\tint j = getMax();\n\t\tint ans = q[j].front(); q[j].pop();\n\t\tans += d;\n\n\t\tif (i % t == 0) printf(\"%d \", ans);\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n    return 0;\n}\n```","tags":["单调队列"],"categories":["OI"]},{"title":"组合数问题 - 组合数学，递推，二维前缀和","url":"%2FNOIP2016-problem%2F","content":"\n\n组合数表示的是从 $ n $ 个物品中选出 $ m $ 个物品的方案数。举个例子，从 $ (1, 2, 3) $ 三个物品中选择两个物品可以有 $ (1, 2) $，$ (1, 3) $，$ (2, 3) $ 这三种选择方法。\n\n根据组合数的定义，我们可以给出计算组合数的一般公式：\n\n$$ C_n ^ m = \\frac{n!}{m!(n - m)!} $$\n\n其中 $ n! = 1 \\times 2 \\times \\cdots \\times n $。\n\n小葱想知道如果给定 $ n $，$ m $ 和 $ k $，对于所有的 $ 0 \\leq i \\leq n $，$ 0 \\leq j \\leq \\min(i, m) $ 有多少对 $ (i, j) $ 满足是 $ k $ 的倍数。\n\n<!--more-->\n\n# 链接\n[LYOI#](https://ly.men.ci/problem/102)\n\n# 题解\n\n组合数递推，你们乐意叫Pascal定理就叫好了反正我叫杨辉三角。。。\n$$\nC_{n}^{m} = C_{n-1}^{m} + C_{n-1}^{m-1}\n$$\n\n递推过程中每次取模，若该位取模后为$0$则记该位答案为$1$，反之为$0$，对答案数组求二维前缀和，每次$O(1)$查询即可。\n\n总复杂度$O(2 \\times 2000^2 + T)$\n\n# 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 2000;\n\nint f[MAXN + 1][MAXN + 1], ans[MAXN + 1][MAXN + 1];\n\nint main () {\n    freopen(\"problem.in\", \"r\", stdin);\n    freopen(\"problem.out\", \"w\", stdout);\n\n    int t, k; scanf(\"%d %d\", &t, &k);\n    for (int i = 0; i <= MAXN; i++) f[i][0] = f[i][i] = 1;\n    for (int i = 2; i <= MAXN; i++) {\n        for (int j = 1; j < i; j++) {\n            f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % k;\n            if (f[i][j] == 0) ans[i][j]++;\n        }\n    }\n\n    for (int i = 1; i <= MAXN; i++) {\n        for (int j = 1; j <= MAXN; j++) {\n            ans[i][j] = ans[i - 1][j] + ans[i][j - 1] - ans[i - 1][j - 1] + ans[i][j];\n        }\n    }\n    \n    while (t--) {\n        int n, m; scanf(\"%d %d\", &n, &m);\n        printf(\"%d\\n\", ans[n][m]);\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```","tags":["前缀和"],"categories":["OI"]},{"title":"换教室 - NOIP2016，Floyd，概率与期望","url":"%2FNOIP2016-classroom%2F","content":"\n对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。\n\n在可以选择的课程中，有 $ 2n $ 节课程安排在 $ n $ 个时间段上。在第 $ i $ （$ 1 \\leq  i \\leq n $）个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室 $ c_i $ 上课，而另一节课程在教室 $ d_i $ 进行。\n\n在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的 $ n $ 节安排好的课程。如果学生想更换第i节课程的教室，则需要提出申请。若申请通过，学生就可以在第 $ i $ 个时间段去教室 $ d_i $ 上课，否则仍然在教室 $ c_i $ 上课。\n\n由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第 $ i $ 节课程的教室时，申请被通过的概率是一个已知的实数 $ k_i $，并且对于不同课程的申请，被通过的概率是互相独立的。\n\n学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多 $ m $ 节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请白己最希望更换教室的 $ m $ 门课程，也可以不用完这 $ m $ 个申请的机会，甚至可以一门课程都不申请。\n\n因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。\n\n牛牛所在的大学有 $ v $ 个教室，有 $ e $ 条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第 $ i $（$ 1 \\leq i \\leq n - 1 $）节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。\n\n现在牛牛想知道，申请哪几门课程可以使他因在教室问移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。\n\n<!--more-->\n\n# 链接\n[LYOI#101](https://ly.men.ci/problem/101/)\n\n# 题解\u0010\n这题说是考了期望，然而关于概率的内容只有期望的定义和概率的乘法计算，当然也考了十分冷门的 $ \\texttt{floyd} $。\n\n这道题只有 $ 300 $ 个教室，所以可以用 $ \\texttt{floyd} $ 求出多源最短路，在用 $ \\texttt{floyd} $ 的时候注意判断重边，而且要注意一个教室到它自己的距离为 $ 0 $ ，即邻接矩阵中 $ \\mathrm{g}(i,i) $ 应设为 $ 0 $ 而非常用的正无穷。\n\nDP：\n\n设状态 $ f(i,j,k) $ 表示在前 $ i $ 个阶段，已经用掉了 $ j $ 次申请机会，本次是否申请（$ k = 0 $ 表示本次不申请，$ k = 1 $ 表示本次申请），$ \\texttt{dist}(i,j) $ 表示教室 $i, j$ 之间的距离。\n\n考虑 $ f(i,j,0) $ 的转移，上一次可以申请，也可以不申请，反正本次一定不申请是确定的，则有：\n$$\nf(i, j, 0) = \\min\n\\begin{cases}\nf(i - 1, j, 0) + \\mathrm{dist}(c(i - 1), c(i)) \\\\ \\\\\n\\begin{aligned}\nf(i - 1, j, 1) & + \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\\\\n& + \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1))\n\\end{aligned}\n\\end{cases}\n$$\n\n$ f(i,j,1) $ 的转移要长一点：\n\n$$\nf(i, j, 1) = \\min\n\\begin{cases}\n\\begin{aligned}\nf(i - 1, j - 1, 0) &+ \\mathrm{dist}(c(i - 1), d(i)) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i))\n\\end{aligned}\n\\\\ \\\\\n\\begin{aligned}\nf(i - 1, j - 1, 1) &+ \\mathrm{dist}(d(i - 1), d(i)) \\times k(i - 1) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), d(i)) \\times (1 - k(i - 1)) \\times k(i) \\\\\n&+ \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\times (1 - k(i)) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1)) \\times (1 - k(i))\n\\end{aligned}\n\\end{cases}\n$$\n\n边界\n\n$$\n\\begin{aligned}\nf(i, 0, 1) &= +\\infty \\\\\nf(1, 0, 0) &= 0\n\\end{aligned}\n$$\n\n时间复杂度为 $ O(v ^ 3 + nm) $。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cfloat>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int MAXN = 2000;\nconst int MAXM = 2000;\nconst int MAXV = 300;\nconst int MAXE = 90000;\n\nint g[MAXV + 1][MAXV + 1], d[MAXN + 1], c[MAXN + 1], n, m, v, e;\ndouble k[MAXN + 1];\n\nvoid floyd () {\n\tfor (int a = 1; a <= v; a++) {\n\t\tfor (int b = 1; b <= v; b++) {\n\t\t\tfor (int c = 1; c <= v; c++) {\n\t\t\t\tif (g[b][a] != INT_MAX && g[a][c] != INT_MAX && g[b][c] > g[b][a] + g[a][c]) {\n\t\t\t\t\tg[b][c] = g[b][a] + g[a][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ndouble f[MAXN + 1][MAXM + 1][2];\n\nint main () {\n\tfreopen(\"classroom.in\", \"r\", stdin);\n\tfreopen(\"classroom.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d %d\", &n, &m, &v, &e);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &c[i]);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &d[i]);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lf\", &k[i]);\n\n\tfor (int i = 1; i <= v; i++) {\n\t\tfor (int j = 1; j <= v; j++) {\n\t\t\tg[i][j] = INT_MAX;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= e; i++) {\n\t\tint fr, to, w;\n\t\tscanf(\"%d %d %d\", &fr, &to, &w);\n\t\tg[fr][to] = g[to][fr] = min(w, g[fr][to]);\n\t}\n\n\tfloyd();\n\n\tfor (int i = 1; i <= v; i++) g[i][i] = 0;\n\n\tf[1][0][0] = 0;\n\tf[1][0][1] = DBL_MAX;\n\t\n\tfor (int i = 2; i <= n; i++) {\n\t\tf[i][0][0] = f[i - 1][0][0] + g[c[i - 1]][c[i]];\n\t\tf[i][0][1] = DBL_MAX;\n\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tf[i][j][0] = f[i][j][1] = DBL_MAX;\n\n\t\t\tif (f[i - 1][j][0] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = min(f[i][j][0], f[i - 1][j][0] \n\t\t\t\t\t\t + g[c[i - 1]][c[i]]);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j][1] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = min(f[i][j][0], f[i - 1][j][1] \n\t\t\t\t\t\t + (g[c[i - 1]][c[i]] * (1 - k[i - 1]))\n\t\t\t\t\t\t + (g[d[i - 1]][c[i]] * k[i - 1]));\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][0] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = min(f[i][j][1], f[i - 1][j - 1][0] \n\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * k[i]) \n\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i])));\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][1] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = min(f[i][j][1], f[i - 1][j - 1][1]\n\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i]))\n\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i]))\n\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i])\n\t\t\t\t\t\t+ (g[d[i - 1]][d[i]] * k[i - 1] * k[i]));\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\tdouble ans = DBL_MAX;\n\tfor (int j = 0; j <= m; j++) {\n\t\tans = min(ans, f[n][j][0]);\n\t\tans = min(ans, f[n][j][1]);\n\t}\n\n\tprintf(\"%.2lf\\n\", ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","tags":["数学期望"],"categories":["OI"]},{"title":"玩具迷题 - NOIP2016，模拟","url":"%2FNOIP2016-toy%2F","content":"\n小南有一套可爱的玩具小人，它们各有不同的职业。\n\n有一天，这些玩具小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外。\n\n这时 `singer` 告诉小南一个谜题：「眼镜藏在我左数第 3 3 个玩具小人的右数第 $1$ 个玩具小人的左数第 $2$ 个玩具小人那里。」\n\n小南发现，这个谜题中玩具小人的朝向非常关键， 因为朝内和朝外的玩具小人的左右方向是相反的：面朝圈内的玩具小人，它的左边是顺时针方向，右边是逆时针方向；而面向圈外的玩具小人，它的左边是逆时针方向，右边是顺时针方向。\n\n小南一边艰难地辨认着玩具小人，一边数着：\n\n`singer` 朝内，左数第 $3$ 个是 `archer`。\n`archer` 朝外，右数第 $1$ 个是 `thinker`。\n`thinker` 朝外，左数第 $2$ 个是 `writer`。\n\n所以眼镜藏在 `writer` 这里！\n\n虽然成功找回了眼镜，但小南并没有放心。如果下次有更多的玩具小人藏他的眼镜，或是谜题的长度更长，他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。这样的谜题具体可以描述为：\n\n有$ n $个玩具小人围成一圈，已知它们的职业和朝向。现在第 $1$ 个玩具小人告诉小南一个包含 $m$ 条指令的谜题。其中第 $i$ 条指令形如「左数/右数第 $s_i$ 个玩具小人」。你需要输出依次数完这些指令后，到达的玩具小人的职业。\n\n<!--more-->\n\n# 链接\n[LYOI#99](https://ly.men.ci/problem/99)\n\n# 题解\n模拟。\n\n根据朝向，顺加逆减，每次取模，防止越界\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nconst int MAXN = 100000;\n\nstring name[MAXN + 1]; int face[MAXN + 1];\n\nint main () {\n\tfreopen(\"toy.in\", \"r\", stdin);\n\tfreopen(\"toy.out\", \"w\", stdout);\n\t\n\tint n, m; scanf(\"%d %d\", &n, &m);\n\tfor (int i = n; i >= 1; i--) {\n\t\tscanf(\"%d\", &face[i]);\n\t\tcin >> name[i];\n\t}\n\t\n\tname[0] = name[n];\n\tface[0] = face[n];\n\t\n//\tfor (int i = n; i >= 1; i--) cout << face[i] << endl;\n\t\n\tint dirans = n;\n\t\n\tfor (int i = 0; i < m; i++) {\n\t\tint dir, vec; scanf(\"%d %d\", &dir, &vec);\n\t\tif (face[dirans] == 0 && dir == 0) {\n\t\t\tint mov = (dirans + vec) % n;\n\t\t\tdirans = mov;\n\t\t} else if (face[dirans] == 0 && dir == 1) {\n\t\t\tint mov = ((dirans - vec) + n) % n;\n\t\t\tdirans = mov;\n\t\t} else if (face[dirans] == 1 && dir == 0) {\n\t\t\tint mov = ((dirans - vec) + n) % n;\n\t\t\tdirans = mov;\n\t\t} else if (face[dirans] == 1 && dir == 1) {\n\t\t\tint mov = (dirans + vec) % n;\n\t\t\tdirans = mov;\n\t\t}\n\t}\n\t\n\tcout << name[dirans] << endl;\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```","tags":["模拟"],"categories":["OI"]},{"title":"石子归并，区间DP","url":"%2FmergeStone%2F","content":"\n有$n$堆石子排成一列，每堆石子有一个重量$w_i$, 每次合并可以合并相邻的两堆石子，一次合并的代价为两堆石子的重量和$w_i+w_{i+1}$，求怎样合并能使合并代价最小，输出最小代价。\n\n<!--more-->\n\n# 题解\n\n区间DP\n\n记合并$[l,r]$这段区间内的石子所需的代价为$f(l,r)$，则有:\n$$\nf(l,r)=\\min_{k=l}^{r-1}(f(l,r),\\ f(l,k) + f(k+1,r))+sum(l,r)\n$$\n\n记$sum(l,r)=\\sum\\limits_{i=l}^{r}w_i$\n\n那么接下来的工作就是确定递推顺序，这题的递推顺序是从短区间向长区间递推，因为我们发现状态中每次转移需要用到的状态只需要用到从之前的较短的区间中得到的值。\n\n# 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int MAXN = 100;\n\nint a[MAXN + 1], f[MAXN + 1][MAXN + 1];\n\nint main () {\n    int n; scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &a[i]);\n        a[i] = a[i] + a[i - 1];\n    }\n\n    for (int i = 1; i <= n; i++) f[i][i] = 0;\n\n    for (int len = 1; len < n; len++) {\n        int r;\n        for (int l = 1; l <= n - len; l++) {\n            r = l + len;\n            int minn = INT_MAX;\n            for (int k = l; k < r; k++) {\n                minn = min(f[l][k] + f[k + 1][r], minn);\n            }\n\n            f[l][r] = minn + a[r] - a[l - 1];\n        }\n    }\n\n    printf(\"%d\\n\", f[1][n]);\n    \n    return 0;\n}\n```\n","tags":["区间DP"],"categories":["OI"]},{"title":"火柴排队，贪心，逆序对，NOIP2013","url":"%2FSticks-NOIP%2F","content":"\n给定两个数列 $ a, b $，每个数列中相邻两个数可以交换，求使得 $ \\sum\\limits_{i = 1}^{n}(a_i - b_i) ^ 2 $ 最小的交换次数，答案对 $ 99999997 $ 取模\n\n<!--more-->\n\n# 题解\n当$|a-b|$尽可能小的时候，$(a-b)^2$最小，所以，这道题实际上就是让数列$a$中的元素与数列$b$中的元素，按照它们在两个数列中所在的大小位置对应排列，简单来说，比如某个元素$a_j$在数列$a$中是第三大的，那么满足题意的与他对应的$b_j$在数列$b$中也一定是第三大的。详细的证明过程不再赘述（其实是我自己证明困难QwQ）\n\n具体做法就是现将两个数列排序，这样我们就获得了两个数列中哪两个元素应该对应排列在一起，然而实际操作并不需要同时移动两列数，我们只需要固定一列数移动另一列使其满足该大小关系即可，所以我们记录每个元素本来的位置，问题转化为求一个序列中原位置关于另一个序列原位置的逆序对。。确实很绕，上代码理解吧。。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 100000;\nconst int MOD = 99999997;\n\nstruct Stick {\n\tint id, height;\n\n\tbool operator<(const Stick &other) const { return height < other.height; }\n} s1[MAXN + 1], s2[MAXN + 1];\n\nint t[MAXN + 1], tmp[MAXN + 1];\n\nint ans;\nvoid mergeSort (int *a, int l, int r) {\n\tif (l >= r) return;\n\tint mid = (l + r) / 2;\n\n\tmergeSort(a, l, mid);\n\tmergeSort(a, mid + 1, r);\n\n\tint i = l, j = mid + 1, k = l;\n\twhile (i <= mid && j <= r) {\n\t\tif (a[i] > a[j]) {\n\t\t\ttmp[k++] = a[j++];\n\t\t\tans = (ans + (mid - i + 1) % MOD) % MOD;\n\t\t} else {\n\t\t\ttmp[k++] = a[i++];\n\t\t}\n\t}\n\n\twhile (i <= mid) tmp[k++] = a[i++];\n\twhile (j <= r) tmp[k++] = a[j++];\n\n\tfor (int i = l; i <= r; i++) a[i] = tmp[i];\n\n\treturn;\n}\n\n\nint main () {\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) { scanf(\"%d\", &s1[i].height); s1[i].id = i; }\n\tfor (int i = 0; i < n; i++) { scanf(\"%d\", &s2[i].height); s2[i].id = i; }\n\n\tsort(s1, s1 + n);\n\tsort(s2, s2 + n);\n\n\tfor (int i = 0; i < n; i++) t[s2[i].id] = s1[i].id;\n\n\tmergeSort(t, 0, n - 1);\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","tags":["逆序对"],"categories":["OI"]},{"title":"花匠，最长波动子序列，NOIP","url":"%2FGavin-NicholasAndHisFlower%2F","content":"\n给定一个序列，求其中最长波动子序列\n\n# 题解\n据说这题可以动归，然而感觉动归爆炸，就贪了个心\n\n正解是枚举所有的拐点，将拐点加入子序列中一定比加入其他点更优，因为拐点比可以容纳更多的点在其中波动，最后特判起点和终点是否可以加入序列中即可\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint height[MAXN + 1];\n\nint main () {\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &height[i]);\n\t}\n\t\n\tbool isUping = true; int ans = 0;\n\tif (height[1] >= height[2]) isUping = false;\n\telse isUping = true;\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tif (isUping && height[i] > height[i + 1]) {\n\t\t\tisUping = false;\n\t\t\tans++;\n\t\t} else if (!isUping && height[i] < height[i + 1]) {\n\t\t\tisUping = true;\n\t\t\tans++;\n\t\t}\n\t}\n\n\tif (height[1] == height[2]) ans--;\n\tif (height[n - 1] == height[n]) ans--;\n\n\tans += 2;\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","tags":["贪心"],"categories":["OI"]},{"title":"飞扬的小鸟，DP，背包，NOIP2014","url":"%2FFlappy-Bird%2F","content":"\n* 给定一个长为$n$，高为$m$的二位平面，其中有$k$个管道（不计宽度）\n* 小鸟从平面最左边出发，到达平面最右边时游戏完成\n* 小鸟每单位时间沿横坐标方向右移距离为1，竖直移动距离由玩家控制，如果点击屏幕，小鸟会上升一定高度$X$，每单位时间内可以点击多次，效果叠加，如果不点击屏幕，小鸟会下降一定高度$Y$\n* 小鸟位于不同的横坐标位置时，上升高度$X$和下降高度$Y$可能互不相同\n* 小鸟高度为$m$时，无法再上升\n* 小鸟高度等于$0$或小鸟碰到管道时，游戏失败\n* 要求：\n\t* 如果能完成游戏，输出最少点击屏幕次数\n\t* 如果不能，输出最多能通过的水管\n\n<!--more-->\n\n# 题解\n由于每单位时间可以点击多次屏幕，所以对于上升的过程，可以看做一个完全背包。\n\n设$f(i,j)$表示到达坐标为$(i,j)$的点时，所需最少点击次数，这个状态由可以由前一个单位时间中点击若干次屏幕得到，也可以由前一个单位时间中不点击屏幕掉落一段高度得到，由此可得方程：\n$$\nf(i,j)=\\min\\limits_{k=1}^{j\\div X_{i-1}}(f(i-1,j-kX_{i-1})+k,f(i-1,j+Y_{i-1}))\n$$\n\n然而这种情况下每一次枚举的时间复杂度为$O(m)$，总时间复杂度为$O(nm^2)$，无法通过全部数据\n\n考虑**点击$k$次**和**点击$k-1$次**之间的联系，如果点击$k$次，则可以到达纵坐标为$j$的位置，点击$k-1$次，可以到达纵坐标为$j-X_{i-1}$的位置，由此可得方程（仅考虑点击时的情况）：\n$$\nf(i,j)=\\min(f(i-1,j-X_{i-1})+1,f(i,j-X_{i-1})+1)\n$$\n\n在上述仅考虑点击时的方程中，从$f(i,j-X_{i-1})$转移到$f(i,j)$的过程，可看做由$f(i-1,j-2X_{i-1})$转移到$f(i,j)$，得到$f(i,j-X_{i-1})$的过程同理，这样枚举是完整的完全背包，可以保证可点击多次\n\n在使用优化过的方程的时候，我们不能在处理点击的同时处理不点击，因为在同一时刻我们不能既点击又不点击，所以说对于不点击的处理应该放在处理完所有的点击之后。\n\n而且，由于我们的某个状态$f(i,j)$可能由$f(i,j-X_{i-1})$递推得来，而$(i,j-X_{i-1})$这个位置可能是障碍，所以我们不能直接将所有的障碍的答案设为`INT_MAX`（不可达到），而是递推得到某列的所有答案后，再将该列的水管位置的对应答案设为`INT_MAX`\n\n前面递推的答案只针对$(i,1) \\rightarrow (i,m-1)$，对于$(i,m)$，我们要做特殊处理\n\n最终输出答案时，对所有最右列的$f$值取最小，若最右列的值全部都为`INT_MAX`，则证明游戏不可完成，我们就从第$n-1$列向左寻找可以通过的某一列，记录包括这一列之前一共有多少个障碍，此为小鸟最终能通过的障碍数量\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <climits>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000;\n\nstruct Pipe {\n    bool exist;\n    int top, bot;\n} a[MAXN + 1];\n\nint n, m, k, X[MAXN + 1], Y[MAXN + 1];\n\ntemplate <typename T> bool cmin (T &a, const T &b) {\n    return (a > b) ? (a = b, true) : false;\n}\n\nint main () {\n    scanf(\"%d %d %d\", &n, &m, &k);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &X[i], &Y[i]);\n    }\n\n    for (int i = 0; i < k; i++) {\n        int x; scanf(\"%d\", &x);\n        a[x].exist = true;\n        scanf(\"%d %d\", &a[x].bot, &a[x].top);\n    }\n\n    static int f[MAXN + 1][MAXM + 1];\n\n    f[0][0] = INT_MAX;\n    for (int i = 1; i <= n; i++) {\n        f[i][0] = INT_MAX;\n        for (int j = 1; j < m; j++) {\n            f[i][j] = INT_MAX;\n            if (j >= X[i - 1]) {\n                if (f[i - 1][j - X[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j - X[i - 1]] + 1);\n                if (f[i][j - X[i - 1]] != INT_MAX) cmin(f[i][j], f[i][j - X[i - 1]] + 1);\n            }\n        }\n\n        for (int j = 1; j <= m - Y[i - 1]; j++) {\n            if (f[i - 1][j + Y[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + Y[i - 1]]);\n        }\n\n        f[i][m] = INT_MAX;\n        for (k = m - X[i - 1]; k <= m; k++) {\n            if (f[i - 1][k] != INT_MAX) cmin(f[i][m], f[i - 1][k] + 1);\n            if (f[i][k] != INT_MAX) cmin(f[i][m], f[i][k] + 1);\n        }\n\n        if (a[i].exist) for (int j = 1; j <= m; j++) if (j >= a[i].top || j <= a[i].bot) f[i][j] = INT_MAX;\n    }\n\n    int clicks = INT_MAX;\n    for (int i = 1; i <= m; i++) cmin(clicks, f[n][i]);\n    //printf(\"%d\\n\", clicks);\n    if (clicks != INT_MAX) {\n        printf(\"1\\n%d\\n\", clicks);\n    } else {\n        int pos = -1;\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = 1; j <= m; j++) {\n                if (f[i][j] != INT_MAX) {\n                    pos = i;\n                    break;\n                }\n            }\n            if (pos != -1) break;\n        }\n        int cnt = 0;\n        for (int i = 1; i <= pos; i++) if (a[i].exist) cnt++;\n\n        printf(\"0\\n%d\\n\", cnt);\n    }\n\n    return 0;\n}\n```\n","tags":["完全背包"],"categories":["OI"]},{"title":"挖矿，DP，扩展欧几里德","url":"%2Fmining-dp%2F","content":"\n* 有$m+1$个星球，从$0$到$m$编号，yqy最初在$0$号星球\n* 有$n$处矿体，第$i$出矿体有$a_i$单位原矿，在编号为$b_i$的星球上\n* 飞船每次只能从$x$号星球移动到$x+4$或$x+7$号星球，每到一个星球yqy会采走该星球上所有的原矿\n* 求yqy最多能采走多少原矿\n* 注意：\n\t* yqy不必最终到达$m$号星球\n\t* 对于$100\\%$的数据，$n\\leq 10^5, m\\leq 10^9$\n\n<!--more-->\n\n# 题解\n设$f(i)$表示走到第$i$个星球时最多可以得到的原矿数量，用$v_i$表示第$i$个星球上有的原矿数量，易得：\n$$\nf(i)=\\max(f(i-4),f(i-7))+w_i\n$$\n\n然而对于$100\\%$的数据，$m$很大，这样会超时超内存，所以我们需要做一些优化。\n\n首先扯一会Exgcd：\n对于一个方程$ax+by=c$，此方程有**整数解**的充要条件是$\\gcd(a,b)\\mid c$，对于本题中每一个想要到达的距离$d$，可以写成$4x+7y=d$的形式，由于$\\gcd(4,7)=1$所以$d$为任意正整数时，该方程都有**整数解**。\n\n然而，本题只有当所求$x,y$都为**正整数**时，才称对应$d$为可到达的。\n\n经过枚举，我们发现，当$d\\geq 18$时，对应的$x,y$都为整数，也就是说，如果某两个有矿物的星球之间距离大于等于$18$，我们可以将它们之间的距离压缩成$18$，这样的时间复杂度和空间复杂度就达到了$O(n\\times 18)$，极限数据$n=10^5$，轻松过\n\n# 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\n\nconst int MAXN = 1e5;\nconst int MAXM = 1e9;\n\nstruct Mine {\n    int pos, val;\n\n    bool operator<(const Mine &other) const { return pos < other.pos; }\n} a[MAXN];\n\nint main () {\n    freopen(\"mining.in\", \"r\", stdin);\n    freopen(\"mining.out\", \"w\", stdout);\n\n    int n, m; scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &a[i].val, &a[i].pos);\n    }\n\n    sort(a, a + n);\n\n    int Del = 0, Last = 0, maxPos = 0;\n    for (int i = 0; i < n; i++) {//压缩距离\n        a[i].pos -= Del;\n\n        int Gap = a[i].pos - Last;\n        if (Gap > 18) {\n            int t = Gap - 18;\n            a[i].pos -= t;\n            Del += t;\n        }\n\n        Last = a[i].pos;\n        maxPos = max(maxPos, a[i].pos);\n    }\n\n    static int w[MAXN * 18 + 1], f[MAXN * 18 + 1];\n    for (int i = 0; i < n; i++) w[a[i].pos] += a[i].val;\n    for (int i = 1; i <= maxPos; i++) f[i] = INT_MIN;\n\n    w[0] = f[0] = 0; int ans = INT_MIN;\n    for (int i = 1; i <= maxPos; i++) {\n        if (i >= 4) f[i] = max(f[i], f[i - 4] + w[i]);\n        if (i >= 7) f[i] = max(f[i], f[i - 7] + w[i]);\n\n        ans = max(ans, f[i]);\n    }\n\n    printf(\"%d\\n\", ans);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```","tags":["Exgcd"],"categories":["OI"]},{"title":"子串，DP，NOIP2015","url":"%2Fsubstring%2F","content":"\n* 有两个仅包含**小写英文字母**的字符串A和B\n* 现在要从字符串A中取出`k`个**互不重叠**的非空子串，然后把这`k`个子串按照其在**字符串A中出现的顺序**依次连接起来得到一个新的字符串\n* 求使得新串与B串相同的方案数\n* 子串取出的位置不同，认为是不同的方案。\n\n<!--more-->\n\n# 题解\n设$f(i,j,t)$表示使用从串A中前$i$位取出的$t$个子串匹配串B前$j$位（必选$A_i$）的方案数，$g(i,j,t)$表示使用串A中前$i$位取出的$t$个子串匹配串B的前$j$位（不必选$A_i$）的方案数。\n\n\n\n计算$f(i,j,t)$时，考虑$A_i$作为前一个子串的最后一位的方案数，即$f(i-1,j-1,t)$，与单独作为一个子串的方案数，即$g(i-1,j-1,t-1)$，则对于$f(i,j,t)$，有：\n$$\nf(i,j,t)=\n\\begin{cases}\nf(i-1,j-1,t)+g(i-1,j-1,t-1) & A_i = B_j \\\\\n0 & A_i\\neq B_j\n\\end{cases}\n$$\n对于$g(i,j,t)$，则有：\n$$\ng(i,j,t)=\n\\begin{cases}\ng(i-1,j,t)+f(i,j,t) & A_i=B_j \\\\\ng(i-1,j,t) & A_i\\neq B_j\n\\end{cases}\n$$\n\n需要滚动数组优化\n\n# 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 1000;\nconst int MAXM = 200;\nconst int MAXK = 200;\nconst int MOD = 1e9 + 7;\n\nint main () {\n\tstatic int f[2][MAXN + 1][MAXM + 1], g[2][MAXN + 1][MAXM + 1];\n\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tstatic char A[MAXN], B[MAXM];\n\tscanf(\"%s\\n%s\", A, B);\n\n\tg[0][0][0] = 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tconst int cur = i % 2, pre = !cur;\n\t\tmemset(f[cur], 0, sizeof(f[cur]));\n\t\tmemset(g[cur], 0, sizeof(g[cur]));\n\n\t\tg[cur][0][0] = f[cur][0][0] = 1;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int t = 1; t <= min(j, k); t++) {\n\t\t\t\tif (A[i - 1] == B[j - 1]) {\n\t\t\t\t\tf[cur][j][t] = ((f[pre][j - 1][t] % MOD) + (g[pre][j - 1][t - 1] % MOD)) % MOD;\n\t\t\t\t\tg[cur][j][t] = ((g[pre][j][t] % MOD) + (f[cur][j][t] % MOD)) % MOD;\n\t\t\t\t} else {\n\t\t\t\t\tf[cur][j][t] = 0;\n\t\t\t\t\tg[cur][j][t] = g[pre][j][t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[n % 2][m][k]);\n\n\treturn 0;\n}\n\n```\n","tags":["DP"],"categories":["OI"]},{"title":"选课，树形DP","url":"%2Fchose-class%2F","content":"\n* 给定$N$门课，每门课有自己的学分，可能有一门先修课\n* 不同的课程可能有共同的先修课\n* 求在学习课程项目限制$M$内，可能获得的最大学分\n\n<!--more-->\n\n# 存储\n这题使用类似邻接表的方式存储树，对每一个节点，记录它的一个孩子节点，对于其他直连它的节点，使用邻接表串起来，对于没有先修课的节点，我们设置一个虚拟$0$节点。\n* 代码实现：\n\n```c++\nstruct Tree {\n\tTree *child, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer(): solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w): w(w), next(parent->child) {}\n} trees[MAXN + 1];\n```\n\n# 树形DP\n* 设$f(i,m)$表示选择节点$i$，并为节点$i$的孩子节点和兄弟节点分配$m-1$门选课机会所能获得的学分最大值，则有:\n\t1. 枚举$k$，给节点$i$的孩子节点分配$k$门课，给节点$i$的兄弟节点分配$m-k-1$个节点，\n\t2. 不选择节点$i$及其孩子节点，全部$m$门课都分给它的兄弟节点\n\n$$\nf(i,m)=\\max(\\max\\limits_{k=0}^{m-1}(f(i.child,k)+f(i.next,m-k-1)), f(i,next,m))\n$$\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 300;\nconst int MAXM = 300;\n\nstruct Tree {\n\tTree *child, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer(): solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w): w(w), next(parent->child) {}\n} trees[MAXN + 1];\n\nint n, m;\n\nvoid addEdge(int parent, int child, int w) {\n\ttrees[parent].child = new (&trees[child]) Tree(&trees[parent], w);\n}\n\ninline int solve (Tree *t, int m) {\n\tif (!t || m < 0) return 0;\n\n\tif (!t->ans[m].solved) {\n\t\tt->ans[m].value = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tt->ans[m].value = max(t->ans[m].value, solve(t->child, i) + solve(t->next, m - i - 1) + t->w);\n\t\t}//枚举k\n\n\t\tt->ans[m].value = max(t->ans[m].value, solve(t->next, m));\n\n\t\tt->ans[m].solved = true;\n\t}\n\n\treturn t->ans[m].value;\n}\n\nint main () {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint parent, w;\n\t\tscanf(\"%d %d\", &parent, &w);\n\t\taddEdge(parent, i, w);\n\t}\n\n\tprintf(\"%d\\n\", solve(&trees[0], m + 1));//多了一门虚拟课，所以m+1\n\n\treturn 0;\n}\n\n```","tags":["codevs"],"categories":["OI"]},{"title":"生日蛋糕，DFS，POJ1190","url":"%2Fbirthday-cake%2F","content":"\n* 制作一个体积为$N\\pi$，共$M$层的蛋糕\n* 从上往下数第$i,(1\\leq i\\leq M)$的蛋糕是半径为$R_i$，高度为$H_i$的圆柱\n* 当$i<M$时，要求$R_i>R_{i+1}$且$H_i>H_{i+1}$\n* 使得蛋糕的表面积最小\n\n> 在这里本题需要输出的答案并不是最小的表面积，而是最小表面积除以$\\pi$之后的结果\n\n<!--more-->\n\n\n# 思路\n* 深搜\n\t* 模拟拼蛋糕\n\t* 暴力枚举下一层可能的蛋糕半径与高度\n\t* 只需记录更新侧面积，所有顶面积等于最底层蛋糕的底面积\n* 超时？\n\t* **剪枝！！！**\n\n# 如何剪枝\n> 在这里分可行性剪枝与最优性剪枝\n\n### 最优性剪枝\n1. 当前已拼成的蛋糕表面积比已经记录的最优解大\n\n### 可行性剪枝\n1. 无可用体积\n2. 拼成这些层最少体积大于当前需要拼的体积\n3. 目前枚举的高度半径不足以拼完蛋糕\n4. 当前可能拼成的最大体积比需要拼的体积少\n\n# 代码\n```c++\n#include <iostream>\n#include <vector>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\nint n, m;\nint minArea = 1 << 30;//记录最优解\nint area = 0;//记录当前解\nint minV[30], minA[30];//分别记录拼成i层最小可能的体积和表面积\n\nint MaxVforNRH (int n, int r, int h) {\n\tint v;\n\tfor (int i = 0; i < n; ++i) v += (r - i) * (r - i) * (h - i);\n\n\treturn v;\n}//计算在还有n层没拼完，当前一层的半径为r，高度为h时可能拼成的最大体积\n\nvoid dfs (int v, int n, int r, int h) {\n\tif (n == 0) {\n\t\tif (v) return;\n\t\telse {\n\t\t\tminArea = min(minArea, area);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (v <= 0) return;//可行1\n\tif (minV[n] > v) return;//可行2\n\tif (area + minA[n] >= minArea) return;//最优\n\tif (h < n || r < n) return;//可行3\n\tif (MaxVforNRH(n, r, h) < v) return;//可行4\n\n\tfor (int rr = r; rr >= n; --rr) {//爆搜\n\t\tif (n == m) area = rr * rr;\n\t\tfor (int hh = h; hh >= n; hh--) {\n\t\t\tarea += 2 * rr * hh;\n\t\t\tdfs (v - rr * rr * hh, n - 1, rr - 1, hh - 1);\n\t\t\tarea -= 2 * rr * hh;\n\t\t}\n\t}\n}\n\nint main () {\n\tcin >> n >> m;\n\tminA[0] = 0;\n\tminV[0] = 0;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tminV[i] = minV[i - 1] + i * i * i;\n\t\tminA[i] = minA[i - 1] + 2 * i * i;\n\t}\n\n\tif (minV[m] > n) cout << 0 << endl;\n\telse {//处理搜索边界\n\t\tint maxH = (n - minV[m - 1]) / (m * m) + 1;\n\t\tint maxR = sqrt(double(n - minV[m - 1]) / m) + 1;\n\t\tarea = 0;\n\t\tminArea = 1 << 30;\n\t\tdfs (n, m, maxR, maxH);\n\t\tif (minArea == 1 << 30) cout << 0 << endl;\n\t\telse cout << minArea << endl;\n\t}\n\n\treturn 0;\n}\n```","tags":["POJ"],"categories":["OI"]},{"title":"斗地主，DFS，状态压缩，记忆化搜索","url":"%2Flandlord-NOIP2015%2F","content":"\n\n* 给定一副扑克牌，牌面随机，按照斗地主的方式打出，求最少出完要多少次\n* 规则:\n\t* 单顺子五个起，最多到A，不包括2和王\n\t* 连对从三对起，最多到A，不包括2和王\n\t* 飞机两个起，最多到A，不包括2和王，不可带牌\n\t* 三张可以带一张也可以带一对，可以单打\n\t* 四张可以带两张或者两对，可以单打\n\t* 大小王可以当火箭出，但是打带牌的时候不能当对牌带\n\t* 一对和单牌和斗地主完全一样\n\n<!--more-->\n\n# 思路\n## DFS\n* 大暴力搜索\n* 考虑暴力枚举每一种出发，进行爆搜\n\n## 状态压缩优化\n最暴力的爆搜一定会T掉，考虑记忆化搜索:对于某种状态下的牌，如果已经搜过，就不再搜。\n\n所有的状态可以用一个五进制数存下来（因为每种点数的牌最多有四张），然后转化成十进制数，恰好可以用C++中的`unsigned long long`存下。\n\n接下来我们用一个哈希表（map也是滋磁的），来存储每一种状态，每次搜索前查表，如果已经搜过，则直接返回值，没搜过，在本次搜索结束返回值时记录本种状态下的答案。\n\n# 代码\n\n**我用了一个数组来存每种牌有几张，其中0，1表示大小王，2~10代表2~10的对应点数，11~13表示`J`~`K`，14表示`A`**\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <climits>\n\n#define MAXN 15\n#define update() ans = min(ans, dfs() + 1)\n\nusing namespace std;\n\ntypedef unsigned long long Status;\n\nint Hand[MAXN];\n\ninline Status zip () {\n\tStatus s = 0;\n\tfor (int i = 0; i < MAXN; i++) {\n\t\ts = s * 5 + Hand[i];\n\t}\n\treturn s;\n}\n\n/*inline void print(){\n\tfor(int i = 0; i < MAXN; i++){\n\t\tprintf(\"%d \", Hand[i]);\n\t}\n\tputchar('\\n');\n}*/\n\ntr1::unordered_map<Status, int> S;\n\nint dfs() {\n\t//print();\n\n\tStatus s = zip();\n\tif (s == 0) return 0;\n\tif (S.count(s)) return S[s];\n\n\tint ans = INT_MAX;\n\tbool SSingle = true;\n\n\t//Joker\n\tif (Hand[0] && Hand[1]) {\n\t\tHand[0] = Hand[1] = 0;\n\t\tupdate();\n\t\tHand[0] = Hand[1] = 1;\n\n\t\tSSingle = false;\n\t}//某玄学优化，有对王先出对王，好像这样会更快\n\n\t//34567\n\tfor (int i = 3; i < MAXN - 4; i++) {\n\t\tbool flag = false;\n\t\tfor (int d = 0; d < 5; d++) {\n\t\t\tif (!Hand[i + d]) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) continue;\n\n\t\tfor (int d = 0; d < 5; d++) Hand[i + d]--;\n\t\t\n\t\tupdate();\n\n\t\tint j;\n\t\tfor (j = i + 5; j < MAXN && Hand[j]; j++) {\n\t\t\tHand[j]--;\n\t\t\tupdate();\n\t\t}\n\t\t\n\t\tfor (int k = i; k < j; k++) Hand[k]++;\n\n\t\tSSingle = false;\n\t}\n\n\t//334455\n\tfor (int i = 3; i < MAXN - 2; i++) {\n\t\tbool flag = false;\n\t\tfor (int d = 0; d < 3; d++) \n\t\t\tif (Hand[i + d] < 2) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (flag) continue;\n\n\t\tfor (int d = 0; d < 3; d++) Hand[i + d] -= 2;\n\n\t\tupdate();\n\n\t\tint j;\n\t\tfor (j = i + 3; j < MAXN && Hand[j] >= 2; j++) {\n\t\t\tHand[j] -= 2;\n\t\t\tupdate();\n\t\t}\n\n\t\tfor (int k = i; k < j; k++) Hand[k] += 2;\n\n\t\tSSingle = false;\n\t}\n\n\t//333444\n\tfor (int i = 3; i < MAXN - 1; i++) {\n\t\tbool flag = false;\n\t\tfor (int d = 0; d < 2; d++)\n\t\t\tif (Hand[i + d] < 3) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (flag) continue;\n\n\t\tfor (int d = 0; d < 2; d++) Hand[i + d] -= 3;\n\n\t\tupdate();\n\n\t\tint j;\n\t\tfor (j = i + 2; j < MAXN && Hand[j] >= 3; j++) {\n\t\t\tHand[j] -= 3;\n\t\t\tupdate();\n\t\t}\n\n\t\tfor (int k = i; k < j; k++) Hand[k] += 3;\n\n\t\tSSingle = false;\n\t}\n\n\t//3 + x\n\tfor (int i = 2; i < MAXN; i++)\n\t\tif (Hand[i] >= 3) {\n\t\t\tHand[i] -= 3;\n\n\t\t\tupdate();\n\n\t\t\tfor (int j = 0; j < MAXN; j++)\n\t\t\t\tif (Hand[j] >= 1) {\n\t\t\t\t\tHand[j]--;\n\t\t\t\t\tupdate();\n\t\t\t\t\tHand[j]++;\n\t\t\t\t}\n\n\t\t\tfor (int j = 2; j < MAXN; j++)\n\t\t\t\tif (Hand[j] >= 2) {\n\t\t\t\t\tHand[j] -= 2;\n\t\t\t\t\tupdate();\n\t\t\t\t\tHand[j] += 2;\n\t\t\t\t}\n\n\t\t\tHand[i] += 3;\n\n\t\t\tSSingle = false;\n\t\t}\n\n\t//4 + x\n\tfor (int i = 2; i < MAXN; i++)\n\t\tif (Hand[i] == 4) {\n\t\t\tHand[i] -= 4;\n\n\t\t\tupdate();\n\n\t\t\tfor (int j = 0; j < MAXN; j++) if (Hand[j] >= 1){\n\t\t\t\tHand[j]--;\n\t\t\t\tfor (int k = 0; k < MAXN; k++) if (Hand[k] >= 1) {\n\t\t\t\t\tHand[k]--;\n\n\t\t\t\t\tupdate();\n\n\t\t\t\t\tHand[k]++;\n\t\t\t\t}\n\t\t\t\tHand[j]++;\n\t\t\t}\n\n\t\t\tfor (int j = 2; j < MAXN; j++) if (Hand[j] >= 2) {\n\t\t\t\tHand[j] -= 2;\n\t\t\t\tfor (int k = 2; k < MAXN; k++) if (Hand[k] >= 2) {\n\t\t\t\t\tHand[k] -= 2;\n\n\t\t\t\t\tupdate();\n\n\t\t\t\t\tHand[k] += 2;\n\t\t\t\t}\n\t\t\t\tHand[j] += 2;\n\t\t\t}\n\n\t\t\tHand[i] += 4;\n\n\t\t\tSSingle = false;\n\t\t}\n\n\t//2\n\tfor (int i = 2; i < MAXN; i++) if (Hand[i] >= 2) {\n\t\tHand[i] -= 2;\n\t\tupdate();\n\t\tHand[i] += 2;\n\n\t\tSSingle = false;\n\t}\n\n\t//1\n\tif (SSingle) {\n\t\tans = 0;\n\t\tfor (int i = 0; i < MAXN; i++) {\n\t\t\tans += Hand[i];\n\t\t}\n\t}\n\n\treturn S[s] = ans;\n}\n\nint main () {\n\tint T, n;\n\tscanf(\"%d %d\", &T, &n);\n\twhile (T--) {\n\t\tmemset(Hand, 0, sizeof(Hand));\n\t\tS.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x, y; scanf(\"%d %d\", &x, &y);\n\t\t\tif (x == 0) Hand[y - 1]++;\n\t\t\telse if (x == 1) Hand[14]++;\n\t\t\telse Hand[x]++;\n\t\t}\n\n\t\tprintf(\"%d\\n\", dfs());\n\t}\n\n\treturn 0;\n}\n\n```\n\n原来感觉难道爆炸的题，真正做完以后却感觉就是一道大暴力的题，想了很久也没有什么可写的。。最后说一句，tr1害死人。。\n","tags":["记忆化搜索"],"categories":["OI"]},{"title":"灌溉草场，线性DP，POJ2373","url":"%2Fpour-the-grass%2F","content":"\n* 一片草场上有长度为L$(1 \\leq L \\leq 10^6)$，且为偶数的线段\n* John的$N$头奶牛在操场上沿着这条线段吃草\n* 每头奶牛的活动范围是一个开区间$(S,E)$，$S,E$都是整数\n* 不同奶牛活动范围有重叠\n* 现在要安装若干个可调节的喷水头灌溉草场，每个喷水头的工作半径在可$[A,B]$中调节\n* 要求喷水头满足下列要求\n\t* 线段上每个整点恰好位于**一个**喷水头的喷洒范围内\n\t* 每头奶牛的活动范围要位于**一个**喷水头的喷洒范围\n\t* 任何喷水头的喷洒范围不得超过线段两端\n\n求John最少要安装多少个喷水头，若无法刚好安装则输出$-1$\n\n<!--more-->\n \n# 问题分析\n* 从左端点向右端点安装喷水头，设$F(X)$表示:所安装喷水头的喷洒范围恰好覆盖直线上的区间$[0,X]$时，最少需要多少个喷水头\n* 显然，X满足：\n\t* X为偶数\n\t* X所在位置不会出现奶牛，即$X$不属于任何一个$(S,E)$\n\t* $X\\geq2A$\n\t* 当$X>2B$时，存在$Y\\in [X-2B,X-2A]$且$Y$满足上述三个条件使得$F(X)=F(Y)+1$\n\n# 解题思路\n## 递推计算$F(X)$\n* $F(X)=\\infty:X$是奇数\n* $F(X)=\\infty:X<2A$\n* $F(X)=\\infty:X$处可能有奶牛出没\n* $F(X)=1:2A\\leq X \\leq 2B$，且$X$位于任何奶牛活动范围之外\n* $F(X)=1 +\\min\\limits_{Y=X-2B}^{X-2A} F(Y),Y$位于任何奶牛的活动范围之外，且X>2B\n## 优化\n$F(X)=1 +\\min\\limits_{Y=X-2B}^{X-2A} F(Y),Y$位于任何奶牛的活动范围之外，且X>2B。\n\n* 对于此转移中的每个$X$求$F(X)$都要便利区间$[X-2B,X-2A]$,太慢\n* 所以快速找到此区间使得$F(Y)$最小的元素是解题的关键。\n### 可以用堆来优化哦\n* 使用C++的STL中的priority_queue\n* 求$F(X)$时，我们维护一个小根堆，保证堆中包含所有的$i\\in [X-2B,X-2A]$所对应的$F(i)$值，这样操作时间就从扫区间的$O(N)$级别变成了$O(\\log_2N)$级别了\n* 求解$X$对应的$F(X)$时，不允许堆中出现坐标大于$X-2A$的点，这样的点不能用来转移$F(X)$，又不能抛弃之，因为它可能对求后续点的$F$值有用\n* 堆中可以出现坐标小于$X-2B$的点，若其出现在对头，则抛弃\n* 求出$X$点的$F$值后，将$(X-2A+2,(F(X-2A+2)))$放入堆，为求$F(X+2)$作准备\n* 堆中点坐标皆为偶数\n\n# 代码\n```c++\n#include <iostream>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconst int INF = 1 << 31;\nconst int MAXL = 1000010;\nconst int MAXN = 1010;\n\nint F[MAXL];\nint cowThere[MAXL];//用于记录某点是否有奶牛出没\nint n, l, a, b;\n\nstruct Fx {\n\tint x, f;\n\tbool operator<(const Fx &a) const {return f > a.f;}\n\tFx(int xx = 0, int ff = 0): x(xx), f(ff) {}\n};//优先队列用结构体\n\npriority_queue<Fx> q;\n\nint main () {\n\tcin >> n >> l;\n\tcin >> a >> b;\n\ta <<= 1; b <<= 1;//线性操作，所以先将半径处理成直径\n\tmemset(cowThere, 0, sizeof(cowThere));\n\tfor (int i = 0; i < n; i++) {\n\t\tint s, e;\n\t\tcin >> s >> e;\n\t\tcowThere[s + 1]++;\n\t\tcowThere[e]--;\n\t}\n\n\tint inCows = 0;\n\tfor (int i = 0; i <= l; i++) {\n\t\tF[i] = INF;\n\t\tinCows += cowThere[i];\n\t\tcowThere[i] = inCows > 0;\n\t}//利用差分思想实现快速记录某点是否有奶牛出没\n\n\tfor (int i = a; i <= b; i += 2) {\n\t\tif (!cowThere[i]) {\n\t\t\tF[i] = 1;\n\t\t\tif (i <= b + 2 - a) q.push(Fx(i, 1));//确保提前进堆的点可以用于首轮递推\n\t\t}\n\t}//首先初始化初始区间，为最开始的边界做准备\n\n\tfor (int i = b + 2; i <= l; i += 2) {//dp()\n\t\tif (!cowThere[i]) {\n\t\t\tFx fx;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tfx = q.top();\n\t\t\t\tif (fx.x < i - b) q.pop();//如果堆顶元素坐标小于X-2B，抛弃不用\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tif (!q.empty()) F[i] = fx.f + 1;//如果堆空了，说明原来所有堆中元素全部不可用\n\t\t}\n\t\tif (F[i - a + 2] != INF) q.push(Fx(i - a + 2, F[i - a + 2]));\n\t}\n\tif (F[l] == INF) cout << -1 << endl;\n\telse cout << F[l] << endl;\n\n\treturn 0;\n}\n```\n","tags":["线性DP"],"categories":["OI"]},{"title":"小机房的树，LCA，倍增","url":"%2Fgaogay%2F","content":"\n* 一棵$N$个节点的树，节点编号从$0$到$N-1$\n* 每条边有为$c$的边权\n* 求从两个不同的叶节点移动到同一节点最少花费\n* 共$M$次询问\n\n<!--more-->\n\n# 思路\n> 如果只有一次询问，可以用最短路算法，然而询问次数过多，使用堆优化迪杰斯特拉在极限数据下计算次数将会达到$10^{10}$级别\n\n因为这是一棵树，所以我们可以很容易想到让两个叶子节点在同一高度向上跳，第一次同时跳到的点，维护两个节点跳过的距离就是最小花费\n\n基于这种想法，我们成功引出了LCA——最近公共祖先\n\n# 做法\n## 求LCA\n* 倍增\n* ST表\n* Tarjan\n* ~~树链剖分~~\n针对我现在是一个NOIP选手的现实基础，我选择使用简单好写的倍增求解法。\n\n## 倍增求解\n### 朴素算法\n朴素LCA算法是先让更深的节点向上跳，跳到和深度较浅的点深度相同时，让两个节点同时向上跳，那么第一个跳到的同一个节点就是这两个节点的最近公共祖先。\n\n可是这样太慢了，极限情况遇到一条链的树就会变成$O(N)$。\n\n### 如何优化？\n> 既然一次跳一步太少了，那就一次多跳几步\n\n有一个神奇的东西叫做二进制拆分，就是可以把一个数拆成若干个$2^k$加和的形式，这样每个不大于它的正整数都可以用多项式中若干项的和来表示。\n\n所以，我们用二元组$f(i,j)$表示从编号为$i$的节点向上跳$2^j$步可以跳到的节点编号，用$g(i,j)$表示从编号为$i$的节点向上跳$2^j$步所需花费（即边权和）。\n\n那么对于每一个$f(i,j)$与$g(i,j)$，有\n$$\nf(i,j)=f(f(i,j-1),j-1)\n$$\n$$\ng(i,j)=g(i,j-1)+g(f(i,j-1),j-1)\n$$\n\n> 这里用到了倍增的思想，就是从第$i$个点往上跳$2^j$步相当于从第$i$个点往上跳两个$2^{j-1}$次方步，即先从$i$向上跳$2^j$步，再从跳到的点向上跳$2^j$步。\n\n### BFS预处理\n前面提到了一个操作，就是让两个点先到达同一深度，所以说我们需要用BFS预处理出深度。\n\n设根节点深度为$1$，然后一层一层向下广搜，每次广搜出的点的深度为当前深度加一。\n\n### 查询\n> qwq先上代码好了\n\n```c++\ninline int query (int u, int v) {\n\tif (N[u].depth < N[v].depth) std::swap(u, v); //保证u是较深的节点\n\n\tint ans = 0;\n\n\tif (N[u].depth > N[v].depth) {//使两个节点处在相同深度\n\t\tfor (int j = logn; j >= 0; j--) { \n\t\t\tif (N[f[u][j]].depth >= N[v].depth) {\n\t\t\t\tans += g[u][j];\n\t\t\t\tu = f[u][j];\n\t\t\t}\n\t\t}//从大到小枚举指数，保证对应二进制位正常不进位\n\t} \n\n\tif (u != v) {\n\t\tfor (int j = logn; j >= 0; j--) {//同时向上跳\n\t\t\tif (f[u][j] != f[v][j]) {\n\t\t\t\tans += g[u][j];\n\t\t\t\tans += g[v][j];\n\n\t\t\t\tu = f[u][j];\n\t\t\t\tv = f[v][j];\n\t\t\t}//让两个节点跳到LCA的儿子\n\t\t}\n\n\t\tans += g[u][0];\n\t\tans += g[v][0];\n\n\t\tu = f[u][0];\n\t}\n\n\treturn ans;//本题需要维护路径和\n}\n```\n\n# 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 50000;\nconst int MAXLOG = 16;\n\nint n, m, logn;\nint f[MAXN + 5][MAXLOG];\nint g[MAXN + 5][MAXLOG];\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tint depth;\n\tEdge *h;\n\tNode () :depth(0), h(NULL) {}\n} N[MAXN];\n\nstruct Edge {\n\tNode *fr, *to;\n\tint w;\n\tEdge *ne;\n\n\tEdge (Node *fr, Node *to, int w) : fr(fr), to(to), w(w) {\n\t\tne = fr->h;\n\t}\n};\n\ninline void addEdge (Node *u, Node *v, int w) {\n\tu->h = new Edge(u, v, w);\n\tv->h = new Edge(v, u, w);\n} //用于BFS的邻接表\n\ninline void bfs () {\n\tstd::queue <Node *> q;\n\tq.push(&N[0]);\n\tN[0].depth = 1;\n\tf[0][0] = 0;\n\tg[0][0] = 0;\n\n\twhile (!q.empty()) {\n\t\tNode *u = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = u->h; e != NULL; e = e->ne) {\n\t\t\tif (!e->to->depth) {\n\t\t\t\te->to->depth = u->depth + 1;\n\t\t\t\tf[e->to - N][0] = u - N;\n\t\t\t\tg[e->to - N][0] = e->w;\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void prepare () {\n\tbfs();\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i][j] = f[f[i][j - 1]][j - 1];\n\t\t\tg[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1];\n\t\t}\n\t}\n} //预处理出f,j数组\n\ninline int query (int u, int v) {\n\tif (N[u].depth < N[v].depth) std::swap(u, v);\n\n\tint ans = 0;\n\n\tif (N[u].depth > N[v].depth) {\n\t\tfor (int j = logn; j >= 0; j--) {\n\t\t\tif (N[f[u][j]].depth >= N[v].depth) {\n\t\t\t\tans += g[u][j];\n\t\t\t\tu = f[u][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (u != v) {\n\t\tfor (int j = logn; j >= 0; j--) {\n\t\t\tif (f[u][j] != f[v][j]) {\n\t\t\t\tans += g[u][j];\n\t\t\t\tans += g[v][j];\n\n\t\t\t\tu = f[u][j];\n\t\t\t\tv = f[v][j];\n\t\t\t}\n\t\t}\n\n\t\tans += g[u][0];\n\t\tans += g[v][0];\n\n\t\tu = f[u][0];\n\t}\n\n\treturn ans;\n}\n\nint main () {\n\tint m;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(&N[u], &N[v], w);\n\t\taddEdge(&N[v], &N[u], w);\n\t}\n\n\tprepare();\n\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tprintf(\"%d\\n\", query(u, v));\n\t}\n\treturn 0;\n}\n```\n为什么说倍增好写又好用呢？因为Tarjan和ST表不能维护瓶颈路径（比如最大边或最小边），而树链剖分又比较难，所以贴心的队长就只讲了倍增qwq。","tags":["倍增"],"categories":["OI"]},{"title":"迎接仪式，线性DP","url":"%2Fwelcome-ceremony%2F","content":"\n* 给定一个仅由`j`与`z`组成的的字符串\n* 允许最多交换$K$次字符串中字符\n* 使得字符串中`jz`子串尽量多\n\n<!--more-->\n\n# 思路\n> 看到这道题之后，我就想要暴力求解，然后。。就没有然后了\n\n思路的关键之处在于，交换$k$次，其实意味着$k$个`j`变成`z`，$k$个`z`变成`j`。\n\n于是，我们就开心的开始DP了\n\n# DP\n## 状态\n设$f(i,j,z)$表示前$i$位中有$j$个`j`变成了`z`，有$z$个`z`变成了`j`\n\n则，对于$f(i,j,z)$，有：\n$$\nf(i,j,z)=\\max(f(i-2,j-1,z),f(i-2,j,z-1),f(i-2,j-1,z-1),f(i-2,j,z))\n$$\n> 状态解释:\n> \n> $f(i-2,j-1,z)$:字符串第$i-1$位为`j`，第$i$位为`j`\n>\n> $f(i-2,j,z-1)$:字符串第$i-1$位为`z`，第$i$位为`z`\n>\n> $f(i-2,j-1,z-1)$:字符串第$i-1$位为`z`，第$i$位为`j`\n> \n> $f(i-2,j,z)$:字符串第$i-1$位为`j`，第$i$位为`z`。\n\n**只有在$f(i,j,z)$中$j=z$时才可更新答案，因为此时才满足题意中成对更新的意义**\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n\nconst int MAXN = 500;\nconst int MAXK = 100;\n\nchar a[MAXN + 1];\nint f[MAXN + 1][MAXK + 1][MAXK + 1];\n\nint n, k;\n\nint dp () {\n    f[0][0][0] = 0, f[1][0][0] = 0;\n    int ans = 0; int x, y;\n    for (int i = 2; i <= n; i++)\n        for (int j = 0; j <= k; j++)\n            for (int z = 0; z <= k; z++) {\n                f[i][j][z] = f[i - 1][j][z];\n                if (a[i - 1] == 'z') x = 1; else x = 0;\n                if (a[i] == 'j') y = 1; else y = 0; //小表，判断应该如何转移\n                if (j >= x && z >= y) f[i][j][z] = std::max(f[i][j][z], f[i - 2][j - x][z - y] + 1);\n                if (j == z) ans = std::max(ans, f[i][j][z]);//满足条件时更新答案\n            }\n    return ans;\n}\n\nint main () {\n    freopen(\"welcome.in\", \"r\", stdin);\n    freopen(\"welcome.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &k);\n    scanf(\"%s\", a + 1);\n\n    memset(f, -0x777f, sizeof(f));\n    printf(\"%d\\n\", dp());\n\n    fclose(stdin); fclose(stdout);\n    return 0;\n}\n```\n> 不得不说这题的转移实在是难想，果然我还是个小蒟蒻qwq","tags":["线性DP"],"categories":["OI"]},{"title":"线段树学习笔记","url":"%2Fsegment-tree%2F","content":"\n中国高级数据结构领导者，唐氏线段树！【雾\n\n其实并不是，下面即将介绍的是不会TLE的正版线段树哦\n\n\n<!--more-->\n\n# 引言\n在线段树之前我们已经学习过了多中维护区间操作的技巧与数据结构。\n\n* 维护区间最值:ST表\n* 区间更改转化为单点更改:差分数组\n* 区间和:前缀和\n\n但是，它们有一个共同的缺点，就是更适合离线操作，一旦操作与查询为动态的，它们的时间复杂度就会变成$O(\\texttt{TLE})$\n\n于是，我们开心的迎来了，线段树——$\\mathfrak {Segment Tree}$\n\n# 定义\n## 摘自百度百科\n\n线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。\n使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为$O(logN)$。而未优化的空间复杂度为$2N$，因此有时需要离散化让空间压缩。\n\n## 简而言之\n线段树会让你的动态区间操作不会TLE。~~有时会MLE~~\n\n# 具体构成\n对于这个二叉树，每一个节点可以维护一段$[L,R]$的区间内的信息，而对于它的左儿子，维护的是$[L,\\lfloor \\frac{R}{2} \\rfloor]$这段区间中的信息，右儿子则维护的是$[\\lfloor \\frac{R}{2} \\rfloor + 1,R]$这段区间内的信息。\n\n# Lazy Mark\n当我们对区间进行操作的时候，我们需要修改这段区间对应的所有后代的信息（因为他们算是这段区间的子集），但是我们并不需要对于每次操作都这样修改，因为有些时候我们并不会使用到它的后代记录的区间信息。\n就这样，Lazy Mark（懒标记）应运而生。\n\n```c++\nvoid cover(long long delta) {\n\tsum += delta * (r - l + 1);\n\ttag += delta;\n}\n\nvoid pushDown() {\n\tif (tag) {\n\t\tlc->cover(tag);\n\t\trc->cover(tag);\n\t\ttag = 0;\n\t}\n}\n//下放标记只下放一次，再向下查询再下放\n```\n\n# POJ3468\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 200000;\n\ntemplate<size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE], *cur;\n\n\tMemoryPool(): cur(buf) {}\n\n\tvoid init() {\n\t\tcur = buf;\n\t}\n\n\tvoid *alloc(const int &size) {\n\t\tchar *p = cur;\n\t\tcur += size;\n\t\treturn p;\n\t}\n};\n\nMemoryPool<(4 + 4 + 8 + 8 + 8 + 8) * MAXN * 5> pool;\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tlong long sum, tag;\n\n\tSegmentTree(int l, int r, SegmentTree *lc, SegmentTree *rc): l(l), r(r), lc(lc), rc(rc), sum(0), tag(0) {}\n\n\tvoid cover(long long delta) {\n\t\tsum += delta * (r - l + 1);\n\t\ttag += delta;\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag) {\n\t\t\tlc->cover(tag);\n\t\t\trc->cover(tag);\n\t\t\ttag = 0;\n\t\t}\n\t}\n\n\tvoid update(int l, int r, long long x) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(x);\n\t\telse pushDown(), lc->update(l, r, x), rc->update(l, r, x), sum = lc->sum + rc->sum;\n\t}\n\n\tlong long querySum(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse return pushDown(), lc->querySum(l, r) + rc->querySum(l, r);\n\t}\n} *root;\n\nSegmentTree *build(int l, int r) {\n\tif (l == r) return new (pool.alloc(sizeof(SegmentTree))) SegmentTree(l, r, NULL, NULL);\n\telse {\n\t\tint mid = l + (r - l) / 2;\n\t\treturn new (pool.alloc(sizeof(SegmentTree))) SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t}\n}\n\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d %d\", &n, &m) != EOF) {\n\t\troot = NULL;\n\t\tpool.init();\n\t\troot = build(1, n);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tlong long x;\n\t\t\tscanf(\"%lld\", &x);\n\t\t\troot->update(i, i, x);\n\t\t}\n\n\t\tchar s[2];\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tif (s[0] == 'Q') {\n\t\t\t\tint a, b;\n\t\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\t\tprintf(\"%lld\\n\", root->querySum(a, b));\n\t\t\t} else if (s[0] == 'C') {\n\t\t\t\tint l, r;\n\t\t\t\tlong long x;\n\t\t\t\tscanf(\"%d %d %lld\", &l, &r, &x);\n\t\t\t\troot->update(l, r, x);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n# 入门题\n* Codevs1080,1081,1082(线段树联系1，2，3)\n* 忠诚，忠诚S ~~%唐氏线段树~~\n* 数轴染色\n* 借教室(常数大，需要内存池优化)\n\n$\\mathfrak {Powered\\ by\\ Sulfur6}$\n\n","tags":["区间操作"],"categories":["OI"]},{"title":"Sudoku，暴力DFS，POJ2676","url":"%2Fsudoku%2F","content":"\n数独有趣，爆搜无脑。\n\n还有回不去的还记得的一张张写满算式的纸，和解不出的数独。\n\n<!--more-->\n\n# 题目大意\n标准 $ 9 \\times 9 $ 的数独游戏，由你填上空缺的数\n\n# 思路\n* 填满每个空格\n* 记录某一行，某一列，某一小格不能填的数\n* 开始爆搜\n\n# 搜索\n* 搜索过程中，依次往每个格子中填数\n* 简单Hash，$O(1)$判断某行某列某小格是否填写某数\n\n# 注意事项\n* 本题给定数据的数独矩阵，数和数之间没有空格，所以需要用字符处理。\n\n> 当然为了某不愿透露姓名的PC同学的幸福生活，交完题我就更改了一下qwq\n>\n> 同时@PC,@SJQ\n\n* 需要通过行号和列号确定所在小格号\n\n> ~~其实也可以打个表解决这种问题~~\n\n```c++\ninline int Getblock (int r, int c) { //r表示行，c表示列\n\tint rr = r / 3;\n\tint cc = c / 3;;\n\treturn rr * 3 + cc;\n}\n```\n\n# 代码\n```c++\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nshort r[9][10], c[9][10], block[9][10];//分别记录行、列、小格中填数的情况，r表示行，c表示列，block表示小格\nint board[9][9];\n\nstruct Pos {\n\tint r, c;\n\tPos(int rr, int cc): r(rr), c(cc) { }\n};\n\nvector<Pos> blank;//结构体+Vector记录空白格\n\ninline int Getblock (int r, int c) { \n\tint rr = r / 3;\n\tint cc = c / 3;;\n\treturn rr * 3 + cc;\n} //根据行列求小格\n\nvoid Setflag (int i, int j, int num, int f) {\n\tr[i][num] = f;\n\tc[j][num] = f;\n\tblock[Getblock(i, j)][num] = f;\n} //为某一个元素所在行、列、小格设置上使用过或未使用的标记\n\nbool ok (int i, int j, int num) {\n\treturn !r[i][num] && !c[j][num] && !block[Getblock(i, j)][num];\n} //询问当前位置某元素是否可用\n\nbool Dfs (int n) { //n表示现在要填的空格的编号\n\tif (n < 0) return true;\n\tint r = blank[n].r, c = blank[n].c;\n\tfor (int num = 1; num <= 9; ++num) {\n\t\tif (ok(r, c, num)) {\n\t\t\tboard[r][c] = num;\n\t\t\tSetflag(r, c, num, 1);\n\t\t\tif (Dfs(n - 1)) return true;\n\t\t\tSetflag(r, c, num, 0); //回溯\n\t\t}\n\t}\n\n\treturn false;\n} //Based on POJ的毒瘤数据，我们选择右下向左上搜，其实左上向右下搜也可以\n\nint main () {\n\tint t;\n\tcin >> t; //多组数据\n\twhile (t--) {\n\t\tmemset(r, 0, sizeof(r));\n\t\tmemset(c, 0, sizeof(c));\n\t\tmemset(block, 0, sizeof(block));\n\t\tblank.clear(); //每组数据都要重置\n\t\tfor (int i = 0; i < 9; ++i) {\n\t\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tboard[i][j] = c - '0'; //对付每空格的毒瘤数据\n\t\t\t\tif (board[i][j]) Setflag(i, j, board[i][j], 1);\n\t\t\t\telse blank.push_back(Pos(i, j));\n\t\t\t}\n\t\t}\n\n\t\tif (Dfs(blank.size() - 1)) {\n\t\t\tfor (int i = 0; i < 9; ++i) {\n\t\t\t\tfor (int j = 0; j < 9; ++j) cout << char(board[i][j] + '0');\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n```\n\n> 想想当时班里同学整日颓数独的日子，如果我做过这道题的话该是多么好的一个装逼机会啊T ^ T","tags":["POJ"],"categories":["OI"]},{"title":"矩阵乘法优化递推，NOIP%你赛","url":"%2Fmatrix-increase%2F","content":"\n给定一个坐标系，可以往左，右，上走，已经走过的点（单次访问中）不可以重复走，一共可以走$N$步，求一共有多少种走法。\n\n<!--more-->\n\n# 题目分析\n> 表神，各单位提供丰富成功地证明了递推公式，然而，不适合这样做的蒟蒻Sulfur6更喜欢打表找规律。\n\n这里我们就假装我们已经打完了这个表，然后发现它的前几项分别是：\n$$\nf(0) = 1, f(1) = 3, f(2) = 7, f(3) = 17, f(4) = 41, f(5) = 99\n$$\n后面不打了T ^ T，所以我们发现了一个递推公式：\n$$\nf(i) = f(i - 2) + 2 \\times f(i - 1)\n$$\n\n时间复杂度降至$O(n)$，但是极限数据高达$10^9$，这时$O(n)$不靠谱。~~而且会MLE~~\n\n# 矩阵\n> 说矩阵优化之前先说说矩阵\n\n形如\n$$ \\begin{gather*}\n\\begin{matrix} 0 & 1 \\\\\\\\ 1 & 0 \\end{matrix}\\quad\\\n\\begin{pmatrix} 0 & -i \\\\\\\\ i & 0 \\end{pmatrix}\\\n\\begin{bmatrix} 0 & -1 \\\\\\\\ 1 & 0 \\end{bmatrix}\\\n\\begin{Bmatrix} 1 & 0 \\\\\\\\ 0 & -1 \\end{Bmatrix}\\\n\\begin{vmatrix} a & b \\\\\\\\ c & d \\end{vmatrix}\\\n\\end{gather*} $$\n简而言之，矩阵是一坨数\n\n## 矩阵乘法\n对于两个大小为$N \\times M$和$P \\times N$的矩阵$A,B$，他们相乘后的结果矩阵$C$是一个大小为$M \\times P$的矩阵。\n对于矩阵$C$的每一位$C_{i,j}$，有:\n$$\nC_{i,j} = \\sum\\limits_{k = 1}^{N} A_{i,k} \\times B_{k,j}\n$$\n\n# 矩阵优化递推\n> 团长并不知道这种玄学方法的由来，只知道我们可以用这种技巧来转移\n\n$$\n\\begin{gather*}\n\\begin{bmatrix} 0 & 1 \\\\\\\\ 1 & 2 \\end{bmatrix} \\\n\\times\n\\begin{bmatrix} f(i - 2) & 0 \\\\\\\\ f(i - 1) & 0 \\end{bmatrix} \\\n\\end{gather*}\n$$\n\n这样相乘以后的结果:\n$$\n\\begin{bmatrix} f(i-1) & 0 \\\\\\\\ f(i) & 0 \\end{bmatrix} \\\n$$\n也就是说我们可以通过矩阵相乘的方式来求出某递推公式的某一项，即:\n$$\n\\begin{gather*}\n\\begin{bmatrix} f(0) & 0 \\\\\\\\ f(1) & 0 \\end{bmatrix}\\\n\\times\n\\begin{bmatrix} 0 & 1 \\\\\\\\ 1 & 2 \\end{bmatrix}^{n-1} \\\n\\end{gather*} = \\begin{bmatrix} f(n-1) & 0 \\\\\\\\ f(n) & 0 \\end{bmatrix}\\\n$$\n## 如何优化\n* 矩阵满足结合律\n既然如此，我们就可以出动大杀器，**快速幂**，这样就可以在$O(logn)$的时间内求得递推公式的某一项了。\n\n# 代码\n```c++\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nconst int maxn = 1e9;\nconst int mo = 1e9 + 7;\n\nstruct Mat {\n\tlong long a[2][2];\n\n\tMat (const bool unit = false) { //构造函数，初始化矩阵值\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < 2; i++) a[i][i] = i;//此处矩阵用于快速幂中作为单位矩阵承载答案\n\t}\n\n\tlong long &operator()(const int i, const int j = 0)\n\t\t{ return a[i][j]; }\n\tconst long long &operator()(const int i, const int j = 0)\n\t\tconst { return a[i][j]; } //重载运算符并引用，快速取得并修改某矩阵的值\n};\n\nMat operator*(const Mat &a, const Mat &b) { //重载运算符，矩阵乘法\n\tMat res(false);\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\t(res(i, j) += a(i, k) * b(k, j)) %= mo;\n\n\treturn res;\n}\n\nMat pow(Mat a, int n) { //矩阵快速幂\n\tMat res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main () {\n\tfreopen(\"coordinate.in\", \"r\", stdin);\n\tfreopen(\"coordinate.out\", \"w\", stdout);\n\n\tint n; scanf(\"%d\", &n);\n\t\n\tif (n == 0) printf(\"1\");\n\telse if (n == 1) printf(\"3\");\n\telse {\n\t\tMat init(false); //初始矩阵\n\t\tinit(0) = 1;\n\t\tinit(1) = 3;\n\n\t\tMat mat(false); //转移矩阵\n\t\tmat(0, 0) = 0;\n\t\tmat(0, 1) = 1;\n\t\tmat(1, 0) = 1;\n\t\tmat(1, 1) = 2;\n\n\t\tMat res = pow(mat, n - 1) * init; //此处转移矩阵的位置和初始矩阵的位置不可颠倒，因为矩阵不满足交换律\n\t\tprintf(\"%lld\\n\", res(1));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n# 最后说几句\n* 这题中使用的矩阵特性就是满足结合律但是不满足交换律\n* 因为是考试的题所以说我还是打了文件输入输出\n* LaTeX公式和Markdown不兼容真是见鬼了\n* 公式打起来好麻烦\n* 这道题是可以分块打表的\n* 再次%表神cyr\n","tags":["矩阵乘法"],"categories":["OI"]},{"title":"拯救少林神棍，POJ1011，DFS","url":"%2Fbuddhas-sticks%2F","content":"\n一般的，在碰到搜索题的时候，我的反应是：woc，这也能搜索？事实证明，我还是too young.\n\n这是一道重在剪枝的神奇DFS题。\n\n<!--more-->\n\n# 题面\n* 据说,少林寺的镇寺之宝,是救秦王李世民的十三棍僧留下的若干根一样长的棍子。\n* 在民国某年,少林寺被军阀炮轰,这些棍子被炸成$ N $节长度各异的小木棒。\n* 战火过后,少林方丈想要用这些木棒拼回原来的棍子。可他记不得原来到底有几根棍子了,只知道古人比较矮,且为了携带方便,棍子一定比较短。他想知道这些棍子最短可能有多短。\n\n>看到这个题面之后，我整个人都不好了qwq\n\n# 题目大意\n* 给定$N$节长度各异的小木棒，不剩余地拼成若干节长度相等的少林神棍，求神棍最短可以有多短。\n\n# 解题思路\n\n## 枚举\n* 可能拼成的棍子长度\n* 长度从最长的那根木棒开始枚举到木棒总长的一半\n* 若枚举到的长度不能整除木棒总长度，则不去搜索\n\n## 搜索\n>搜索的过程，就是我们尝试着拼神棍的过程\n\n* 如何拼完这一组神棍呢？\n  * 一根一根的拼棍子\n  * 如果拼完第$i$根棍子之后，发现第$i+1$根棍子拼不成了，那就推翻第$i$根棍子的拼法\n  * 有可能一直向前推翻第一根的拼法\n\n## 搜索状态\n>发现能搜索以后，就要确定搜索状态了\n\n* 我们设状态为一个二元组$(R,M)$。\n  * $R$表示还没有用的木棒数\n  * $M$表示当前拼的这根棍子剩余未填满的长度\n* 本题的初始状态和结束状态是什么？\n* 假设共有$N$根木棒，当前枚举到的长度为$L$。\n  * 初始状态：$(N,L)$ \n  * 结束状态：$(0,0)$\n\n## 开始搜索\n>我也不废话了，伪代码参上\n\n```c++\nDfs的基本递推关系:bool Dfs(int R, int M) {\n\tif( R == 0 && M == 0)\treturn true; //拼接任务完成 \n\t如果能找到一根长为S(S <= M)的木棒,拼在当前棍子上,然后\tDfs(R – 1,M - S);\t如果找不到:return false; \n}\n```\n>这里要注意的是我们首先要对长度排序，从大到小枚举\n\n## 剪枝\n>如果按照之前的搜法，那么一定会TLE\n>\n>所以，我们需要出动暴力大杀器——剪枝\n\n### 剪枝1\n* 如果在当前状态下确定了一根不能使用的木棒，那么当我们弃用它以后，当前状态下和它长度同的木棒都不再使用。\n* 正确性显然\n\n### 剪枝2\n* 由于拼接失败，我们需要拆掉某根棍子时，如果我们一直拆解到它的第一根木棒，那么我们就不再动它，去看它的上一根棍子，如果它没有上一根棍子，则此长度不合法\n* 如果拆掉第一根木棒，我们假设它在之后能被使用，而现在已知序列是有序的，那么如果之后某种拼法能使得当前第一根棍子被用到，那么它在之前序列一定不会被拆掉。\n\n### 剪枝3\n* 当我们需要拆解某根已经拼好的棍子时，不要拆掉最后的那根木棒反而用更小的木棒来代替。\n* 如果这样就能拼上，那么我们用用来代替最后长木棒的几根短木棒来代替那根长木棒也能拼上。\n\n### 剪枝4\n* 如果当前需要加的木棒不是当前棍子的第一根，那么我们不能从最长的木棒往下枚举，而是从最近使用过的那根之后的一根开始向下枚举。\n* 这样可以避免先使用长的后使用短的的情况。\n\n# 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint n, l; bool used[65];\nvector <int> len;\n\nint last;\nbool dfs (int r, int m) {\n\tif (r == 0 && m == 0) return true;//搜索停止，达到条件返回true，表示枚举的长度可行\n\tif (m == 0) m = l;//如果已经拼完一根，那么就再接着往下拼\n\tint S = 0;\n\tif (m != l) S = last + 1;//剪枝4，保证递减拼\n\tfor (int i = S; i < n; i++) {\n\t\tif (!used[i] && len[i] <= m) {\n\t\t\tif (i > 0) {\n\t\t\t\tif (!used[i - 1] && len[i] == len[i - 1]) continue;//剪枝1，保证相同长度的木棒不在同一位置多次用\n\t\t\t}\n\t\t\tused[i] = true; last = i;//标记此根为使用过，记录本次加入的木棒\n\t\t\tif (dfs(r - 1, m - len[i])) return true;\n\t\t\telse {\n\t\t\t\tused[i] = 0;//回溯，有可能之后还能用到这根木棒\n\t\t\t\tif (len[i] == m || m == l) return false;//剪枝2，3\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main () {\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n == 0) break;//Blocks of datas, 读入0终止\n\t\tlen.clear();//每次清一遍储存长度的数组\n\t\tint totallen = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x; cin >> x;\n\t\t\tlen.push_back(x);\n\t\t\ttotallen += x;\n\t\t}\n\n\t\tsort (len.begin(), len.end(), greater<int>());//从小到大排序\n\n\t\tfor (l = len[0]; l <= totallen / 2; l++) {\n\t\t\tif (totallen % l) continue;\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(n, l)) {cout << l << endl; break;}//因为是从小到大枚举，所以验证一个答案正确就可以输出了\n\t\t}\n\n\t\tif (l > totallen / 2) cout << totallen << endl;\n\t}\n\n\treturn 0;\n}\n\n```\n\n团长在POJ和HDU上都成功拯救了少林神棍，但是原题并不叫拯救少林神棍，而是叫Sticks，很无聊的题面，某不远透露姓名的薛定谔同学竟然告诉我这是一道POJ上的中文题，害的我一阵好找。。。。","tags":["剪枝"],"categories":["OI"]},{"title":"杨威利与莱因哈特的爱恨情仇","url":"%2Fywl%2F","content":"\n\n蒟蒻Sulfur6在第一次看见这道题的时候感觉它好水啊，然后五分钟打了个自以为是的正解。。肯定是错的太离谱了，那天晚上的代码带崩了我的三个系统。。。\n\n刚刚学习并查集的时候就见过那个题，当时连最水的家族都做不出，真的是连题面都没看就跳过去了。\n\n<!--more-->\n\n# 题目大意\n给定一个最多有30000艘船的船队，初始状态一字排开。\n接下来你要读入 $ T $ 个指令 ($1 \\leq T  \\leq 500000$)：\n若为$M i j$，则将$i$所在的舰队移动到$j$所在舰队的后面（即将第$i$艘舰船所在的战舰队列全部移动到第$j$列舰船所在战舰队列的后面）；\n若为$C i j$，如果第$i,j$艘舰船在同一列中，则输出它们中间有的舰船数，如果不在同一列中，则输出$-1$。\n\n>这里要注意的是（可能只有我一个人这么智障），就是给定合并操作的$i j$可能只是一列舰船中间或末尾的那个，不一定就是某列舰船的第一个。【天真的以为一定给定第一艘的蒟蒻就这么WA挺了。\n\n# 压缩路径\n* 分析完题目大意之后我们会自然而然的想到一种做法，那就是记录每一列舰船所在的位置\n* 但是这样显然不靠谱，因为不路径压缩的UFS会爆炸。\n* 怎么在压缩路径的基础上维护战舰所在位置的信息呢？\n## 某优化\n如果说大家和我一样记得并查集路径压缩的代码的话，我们会发现，在路径压缩之前并没有维护什么信息，所以我们尝试着来搞一些事情\n\n```c++\nint a[MAXN];//某列战舰现有的战舰数，初始化为1\nint b[MAXN];/*某列战舰现在在本列战舰内的深度，初始化为0*/\nint fa[MAXN];//UFS中用的father数组\n\nint find (int x) {\n\tint t;\n\tif (x != fa[x]) {\n\t\tt = find(fa[x]);\n\t\tb[x] += b[fa[x]];//这一句包括上面一句类似于递归求解确定x战舰在本列中的位置\n\t\tfa[x] = t;\n\t}\n\treturn fa[x];\n}\n```\n\n# 完整代码\n\n```c++\n#include <cstdio>\n#include <cstdlib>\n\nconst int maxn = 30000;\nconst int maxt = 500000;\n\nint fa[maxn + 5], a[maxn + 5], b[maxn + 5];\nint ans;\n\nint find (int x) {\n\tint t;\n\tif (x != fa[x]) {\n\t\tt = find(fa[x]);\n\t\tb[x] += b[fa[x]];\n\t\tfa[x] = t;\n\t}\n\treturn fa[x];\n}\n\nint T;\nint main () {\n\tscanf(\"%d\", &T);\n\tfor (int i = 1; i <= maxn + 1; i++) {\n\t\tfa[i] = i;\n\t\ta[i] = 1;\n\t}\n\tchar c; int x, y;\n\twhile (T--) {\n\t\tscanf(\"\\n%c %d %d\", &c, &x, &y);\n\t\tint f1 = find(x); int f2 = find(y);\n\t\tif (c == 'M') {//合并操作\n\t\t\tfa[f1] = f2;//修改战舰头\n\t\t\tb[f1] = a[f2];//修改战舰层数\n\t\t\ta[f2] += a[f1];//增加合并后该列的战舰数\n\t\t} else {\n\t\t\tif (f1 == f2) {\n\t\t\t\tans = abs(b[x] - b[y]) - 1;//这里要记得-1，因为编号从0开始\n\t\t\t\tprintf(\"%d\\n\", ans);\n\t\t\t} else printf(\"-1\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n```\n\n看这个难度也知道是NOI的一道水题，毕竟我这样的蒟蒻都能A。。\n当年看着唐氏Pascal学并查集就死活学不会了，思想都不懂，这里要感谢教会我并查集的神犇Menci和Gty.","tags":["NOI"],"categories":["OI"]},{"title":"Friend","url":"%2FFriends%2Findex.html","content":"\n# Friends list\n\n## LYOI2015\n\n## Other OIers\n"},{"url":"%2Fcategories%2Findex.html"},{"url":"%2Ftags%2Findex.html"}]