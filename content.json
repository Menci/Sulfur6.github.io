{"meta":{"title":"Sulfur6_L8972","subtitle":"Abandoned Sulfur","description":"A Kind Father","author":"Sulfur6","url":"http://sulfur6.top"},"pages":[],"posts":[{"title":"小机房的树，LCA，倍增","slug":"小机房的树，LCA，倍增","date":"2016-10-26T09:14:34.000Z","updated":"2016-10-26T09:16:56.000Z","comments":true,"path":"小机房的树，LCA，倍增/","link":"","permalink":"http://sulfur6.top/小机房的树，LCA，倍增/","excerpt":"终于学会了三个多月前学习的倍增求LCA，最近几年经常出很恶心的带LCA的题。。看看就浑身难受。。","text":"终于学会了三个多月前学习的倍增求LCA，最近几年经常出很恶心的带LCA的题。。看看就浑身难受。。 题目大意 一棵NNN个节点的树，节点编号从000到N−1N-1N−1 每条边有为ccc的边权 求从两个不同的叶节点移动到同一节点最少花费 共MMM次询问 思路 如果只有一次询问，可以用最短路算法，然而询问次数过多，使用堆优化迪杰斯特拉在极限数据下计算次数将会达到101010^{10}10​10​​级别 因为这是一棵树，所以我们可以很容易想到让两个叶子节点在同一高度向上跳，第一次同时跳到的点，维护两个节点跳过的距离就是最小花费 基于这种想法，我们成功引出了LCA——最近公共祖先 做法求LCA 倍增 ST表 Tarjan 树链剖分 针对我现在是一个NOIP选手的现实基础，我选择使用简单好写的倍增求解法。 倍增求解朴素算法朴素LCA算法是先让更深的节点向上跳，跳到和深度较浅的点深度相同时，让两个节点同时向上跳，那么第一个跳到的同一个节点就是这两个节点的最近公共祖先。 可是这样太慢了，极限情况遇到一条链的树就会变成O(N)O(N)O(N)。 如何优化？ 既然一次跳一步太少了，那就一次多跳几步 有一个神奇的东西叫做二进制拆分，就是可以把一个数拆成若干个2k2^k2​k​​加和的形式，这样每个不大于它的正整数都可以用多项式中若干项的和来表示。 所以，我们用二元组f(i,j)f(i,j)f(i,j)表示从编号为iii的节点向上跳2j2^j2​j​​步可以跳到的节点编号，用g(i,j)g(i,j)g(i,j)表示从编号为iii的节点向上跳2j2^j2​j​​步所需花费（即边权和）。 那么对于每一个f(i,j)f(i,j)f(i,j)与g(i,j)g(i,j)g(i,j)，有 f(i,j)=f(f(i,j−1),j−1) f(i,j)=f(f(i,j-1),j-1) f(i,j)=f(f(i,j−1),j−1)g(i,j)=g(i,j−1)+g(f(i,j−1),j−1) g(i,j)=g(i,j-1)+g(f(i,j-1),j-1) g(i,j)=g(i,j−1)+g(f(i,j−1),j−1) 这里用到了倍增的思想，就是从第iii个点往上跳2j2^j2​j​​步相当于从第iii个点往上跳两个2j−12^{j-1}2​j−1​​次方步，即先从iii向上跳2j2^j2​j​​步，再从跳到的点向上跳2j2^j2​j​​步。 BFS预处理前面提到了一个操作，就是让两个点先到达同一深度，所以说我们需要用BFS预处理出深度。 设根节点深度为111，然后一层一层向下广搜，每次广搜出的点的深度为当前深度加一。 查询 qwq先上代码好了 123456789101112131415161718192021222324252627282930313233inline int query (int u, int v) &#123; if (N[u].depth &lt; N[v].depth) std::swap(u, v); //保证u是较深的节点 int ans = 0; if (N[u].depth &gt; N[v].depth) &#123;//使两个节点处在相同深度 for (int j = logn; j &gt;= 0; j--) &#123; if (N[f[u][j]].depth &gt;= N[v].depth) &#123; ans += g[u][j]; u = f[u][j]; &#125; &#125;//从大到小枚举指数，保证对应二进制位正常不进位 &#125; if (u != v) &#123; for (int j = logn; j &gt;= 0; j--) &#123;//同时向上跳 if (f[u][j] != f[v][j]) &#123; ans += g[u][j]; ans += g[v][j]; u = f[u][j]; v = f[v][j]; &#125;//让两个节点跳到LCA的儿子 &#125; ans += g[u][0]; ans += g[v][0]; u = f[u][0]; &#125; return ans;//本题需要维护路径和&#125; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;const int MAXN = 50000;const int MAXLOG = 16;int n, m, logn;int f[MAXN + 5][MAXLOG];int g[MAXN + 5][MAXLOG];struct Node;struct Edge;struct Node &#123; int depth; Edge *h; Node () :depth(0), h(NULL) &#123;&#125;&#125; N[MAXN];struct Edge &#123; Node *fr, *to; int w; Edge *ne; Edge (Node *fr, Node *to, int w) : fr(fr), to(to), w(w) &#123; ne = fr-&gt;h; &#125;&#125;;inline void addEdge (Node *u, Node *v, int w) &#123; u-&gt;h = new Edge(u, v, w); v-&gt;h = new Edge(v, u, w);&#125; //用于BFS的邻接表inline void bfs () &#123; std::queue &lt;Node *&gt; q; q.push(&amp;N[0]); N[0].depth = 1; f[0][0] = 0; g[0][0] = 0; while (!q.empty()) &#123; Node *u = q.front(); q.pop(); for (Edge *e = u-&gt;h; e != NULL; e = e-&gt;ne) &#123; if (!e-&gt;to-&gt;depth) &#123; e-&gt;to-&gt;depth = u-&gt;depth + 1; f[e-&gt;to - N][0] = u - N; g[e-&gt;to - N][0] = e-&gt;w; q.push(e-&gt;to); &#125; &#125; &#125;&#125;inline void prepare () &#123; bfs(); while ((1 &lt;&lt; logn) &lt;= n) logn++; logn--; for (int j = 1; j &lt;= logn; j++) &#123; for (int i = 0; i &lt; n; i++) &#123; f[i][j] = f[f[i][j - 1]][j - 1]; g[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1]; &#125; &#125;&#125; //预处理出f,j数组inline int query (int u, int v) &#123; if (N[u].depth &lt; N[v].depth) std::swap(u, v); int ans = 0; if (N[u].depth &gt; N[v].depth) &#123; for (int j = logn; j &gt;= 0; j--) &#123; if (N[f[u][j]].depth &gt;= N[v].depth) &#123; ans += g[u][j]; u = f[u][j]; &#125; &#125; &#125; if (u != v) &#123; for (int j = logn; j &gt;= 0; j--) &#123; if (f[u][j] != f[v][j]) &#123; ans += g[u][j]; ans += g[v][j]; u = f[u][j]; v = f[v][j]; &#125; &#125; ans += g[u][0]; ans += g[v][0]; u = f[u][0]; &#125; return ans;&#125;int main () &#123; int m; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n - 1; i++) &#123; int u, v, w; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); addEdge(&amp;N[u], &amp;N[v], w); addEdge(&amp;N[v], &amp;N[u], w); &#125; prepare(); scanf(\"%d\", &amp;m); while (m--) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); printf(\"%d\\n\", query(u, v)); &#125; return 0;&#125; 为什么说倍增好写又好用呢？因为Tarjan和ST表不能维护瓶颈路径（比如最大边或最小边），而树链剖分又比较难，所以贴心的队长就只讲了倍增qwq。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://sulfur6.top/tags/学习笔记/"},{"name":"倍增","slug":"倍增","permalink":"http://sulfur6.top/tags/倍增/"},{"name":"LCA","slug":"LCA","permalink":"http://sulfur6.top/tags/LCA/"}],"keywords":[]},{"title":"迎接仪式，线性DP","slug":"迎接仪式，线性DP","date":"2016-10-25T12:07:34.000Z","updated":"2016-10-26T07:33:05.000Z","comments":true,"path":"迎接仪式，线性DP/","link":"","permalink":"http://sulfur6.top/迎接仪式，线性DP/","excerpt":"这种DP让人不知所措，果然我还是Too young.. 多做题多积累。。","text":"这种DP让人不知所措，果然我还是Too young.. 多做题多积累。。 题目大意 给定一个仅由j与z组成的的字符串 允许最多交换KKK次字符串中字符 使得字符串中jz子串尽量多 思路 看到这道题之后，我就想要暴力求解，然后。。就没有然后了 思路的关键之处在于，交换kkk次，其实意味着kkk个j变成z，kkk个z变成j。 于是，我们就开心的开始DP了 DP状态设f(i,j,z)f(i,j,z)f(i,j,z)表示前iii位中有jjj个j变成了z，有zzz个z变成了j 则，对于f(i,j,z)f(i,j,z)f(i,j,z)，有： f(i,j,z)=max(f(i−2,j−1,z),f(i−2,j,z−1),f(i−2,j−1,z−1),f(i−2,j,z)) f(i,j,z)=\\max(f(i-2,j-1,z),f(i-2,j,z-1),f(i-2,j-1,z-1),f(i-2,j,z)) f(i,j,z)=max(f(i−2,j−1,z),f(i−2,j,z−1),f(i−2,j−1,z−1),f(i−2,j,z)) 状态解释: f(i−2,j−1,z)f(i-2,j-1,z)f(i−2,j−1,z):字符串第i−1i-1i−1位为j，第iii位为j f(i−2,j,z−1)f(i-2,j,z-1)f(i−2,j,z−1):字符串第i−1i-1i−1位为z，第iii位为z f(i−2,j−1,z−1)f(i-2,j-1,z-1)f(i−2,j−1,z−1):字符串第i−1i-1i−1位为z，第iii位为j f(i−2,j,z)f(i-2,j,z)f(i−2,j,z):字符串第i−1i-1i−1位为j，第iii位为z。 只有在f(i,j,z)f(i,j,z)f(i,j,z)中j=zj=zj=z时才可更新答案，因为此时才满足题意中成对更新的意义 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;const int MAXN = 500;const int MAXK = 100;char a[MAXN + 1];int f[MAXN + 1][MAXK + 1][MAXK + 1];int n, k;int dp () &#123; f[0][0][0] = 0, f[1][0][0] = 0; int ans = 0; int x, y; for (int i = 2; i &lt;= n; i++) for (int j = 0; j &lt;= k; j++) for (int z = 0; z &lt;= k; z++) &#123; f[i][j][z] = f[i - 1][j][z]; if (a[i - 1] == 'z') x = 1; else x = 0; if (a[i] == 'j') y = 1; else y = 0; //小表，判断应该如何转移 if (j &gt;= x &amp;&amp; z &gt;= y) f[i][j][z] = std::max(f[i][j][z], f[i - 2][j - x][z - y] + 1); if (j == z) ans = std::max(ans, f[i][j][z]);//满足条件时更新答案 &#125; return ans;&#125;int main () &#123; freopen(\"welcome.in\", \"r\", stdin); freopen(\"welcome.out\", \"w\", stdout); scanf(\"%d %d\", &amp;n, &amp;k); scanf(\"%s\", a + 1); memset(f, -0x777f, sizeof(f)); printf(\"%d\\n\", dp()); fclose(stdin); fclose(stdout); return 0;&#125; 不得不说这题的转移实在是难想，果然我还是个小蒟蒻qwq","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://sulfur6.top/tags/学习笔记/"},{"name":"DP","slug":"DP","permalink":"http://sulfur6.top/tags/DP/"},{"name":"线性DP","slug":"线性DP","permalink":"http://sulfur6.top/tags/线性DP/"}],"keywords":[]},{"title":"线段树学习笔记","slug":"线段树学习笔记","date":"2016-10-24T08:27:26.000Z","updated":"2016-10-26T07:34:27.000Z","comments":true,"path":"线段树学习笔记/","link":"","permalink":"http://sulfur6.top/线段树学习笔记/","excerpt":"中国高级数据结构领导者，唐氏线段树！【雾 其实并不是，下面即将介绍的是不会TLE的正版线段树哦","text":"中国高级数据结构领导者，唐氏线段树！【雾 其实并不是，下面即将介绍的是不会TLE的正版线段树哦 引言在线段树之前我们已经学习过了多中维护区间操作的技巧与数据结构。 维护区间最值:ST表 区间更改转化为单点更改:差分数组 区间和:前缀和 但是，它们有一个共同的缺点，就是更适合离线操作，一旦操作与查询为动态的，它们的时间复杂度就会变成 于是，我们开心的迎来了，线段树——SegmentTree\\mathfrak {Segment Tree}SegmentTree 定义摘自百度百科线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN)O(logN)O(logN)。而未优化的空间复杂度为2N2N2N，因此有时需要离散化让空间压缩。 简而言之线段树会让你的动态区间操作不会TLE。有时会MLE 具体构成对于这个二叉树，每一个节点可以维护一段[L,R][L,R][L,R]的区间内的信息，而对于它的左儿子，维护的是[L,⌊R2⌋][L,\\lfloor \\frac{R}{2} \\rfloor][L,⌊​2​​R​​⌋]这段区间中的信息，右儿子则维护的是[⌊R2⌋+1,R][\\lfloor \\frac{R}{2} \\rfloor + 1,R][⌊​2​​R​​⌋+1,R]这段区间内的信息。 Lazy Mark当我们对区间进行操作的时候，我们需要修改这段区间对应的所有后代的信息（因为他们算是这段区间的子集），但是我们并不需要对于每次操作都这样修改，因为有些时候我们并不会使用到它的后代记录的区间信息。 就这样，Lazy Mark（懒标记）应运而生。 123456789101112void cover(int delta) &#123; sum += delta * (r - l + 1); //此处维护区间和 tag += delta;&#125; //打标记 void pushDown() &#123; if (tag) &#123; //有标记就下放 lc-&gt;cover(tag); rc-&gt;cover(tag); tag = 0; &#125;&#125; //下放标记只下放一次，再向下查询再下放 某完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define mid (this-&gt;l + this-&gt;r &gt;&gt; 1)const int maxn = 200000;long long a[maxn + 1];struct Segtree &#123; int l, r; Segtree *lc, *rc; long long sum, lazy; Segtree (int l, int r) &#123; this-&gt;l = l, this-&gt;r = r; sum = lazy = 0; &#125; //构造函数 void addTag (int delta) &#123; lazy += delta; sum += delta * (r - l); &#125; //打标记 void pushDown () &#123; if (lazy) &#123; lc-&gt;addTag(lazy); rc-&gt;addTag(lazy); lazy = 0; &#125; &#125; //下放标记 void update () &#123; sum = lc-&gt;sum + rc-&gt;sum; &#125; //从儿子更新自己的信息 void build () &#123; if (r - l == 1) sum = a[l]; else &#123; lc = new Segtree(l, mid), lc-&gt;build(); rc = new Segtree(mid, r), rc-&gt;build(); update(); &#125; &#125; void modify (int index, long long delta) &#123; if (r - l == 1) sum += delta; else &#123; if (index &lt; mid) lc-&gt;modify(index, delta); else rc-&gt;modify(index, delta); update(); &#125; &#125; //单点修改 void modify2 (int l, int r, long long delta) &#123; if (l == this-&gt;l &amp;&amp; r == this-&gt;r) addTag(delta); else &#123; pushDown(); if (l &lt; mid) lc-&gt;modify2(l, min(r, mid), delta); if (r &gt; mid) rc-&gt;modify2(max(l, mid), r, delta); update(); &#125; &#125; //区间修改 int query (int i) &#123; if (r - l == 1) return sum; else &#123; pushDown(); if (i &lt; mid) return lc-&gt;query(i); else return rc-&gt;query(i); &#125; &#125; //单点查询 long long Query (int l, int r) &#123; if (l == this-&gt;l &amp;&amp; r == this-&gt;r) return sum; else &#123; pushDown(); long long ans = 0; if (l &lt; mid) ans += lc-&gt;Query(l, min(r, mid)); if (r &gt; mid) ans += rc-&gt;Query(max(l, mid), r); return ans; &#125; &#125; //区间查询 &#125;;int main () &#123; int n, m; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%lld\", &amp;a[i]); static Segtree *Hellc = new Segtree(1, n + 1); Hellc-&gt;build(); return 0;&#125; 入门题 Codevs1080,1081,1082(线段树联系1，2，3) 忠诚，忠诚S %唐氏线段树 数轴染色 借教室(常数大，需要内存池优化) Powered by Sulfur6\\mathfrak {Powered\\ by\\ Sulfur6}Powered by Sulfur6","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://sulfur6.top/tags/学习笔记/"},{"name":"区间操作","slug":"区间操作","permalink":"http://sulfur6.top/tags/区间操作/"},{"name":"线段树","slug":"线段树","permalink":"http://sulfur6.top/tags/线段树/"}],"keywords":[]},{"title":"Sudoku，暴力DFS，POJ2676","slug":"Sudoku，暴力DFS，POJ2676","date":"2016-10-23T11:53:10.000Z","updated":"2016-10-26T07:31:46.000Z","comments":true,"path":"Sudoku，暴力DFS，POJ2676/","link":"","permalink":"http://sulfur6.top/Sudoku，暴力DFS，POJ2676/","excerpt":"数独有趣，爆搜无脑。 还有回不去的还记得的一张张写满算式的纸，和解不出的Sudoku。","text":"数独有趣，爆搜无脑。 还有回不去的还记得的一张张写满算式的纸，和解不出的Sudoku。 题目大意标准9×99\\times 99×9的数独游戏，由你填上空缺的数 思路 填满每个空格 记录某一行，某一列，某一小格不能填的数 开始爆搜 搜索 搜索过程中，依次往每个格子中填数 简单Hash，O(1)O(1)O(1)判断某行某列某小格是否填写某数 注意事项 本题给定数据的数独矩阵，数和数之间没有空格，所以需要用字符处理。 当然为了某不愿透露姓名的PC同学的幸福生活，交完题我就更改了一下qwq 同时@PC,@SJQ 需要通过行号和列号确定所在小格号 其实也可以打个表解决这种问题 12345inline int Getblock (int r, int c) &#123; //r表示行，c表示列 int rr = r / 3; int cc = c / 3;; return rr * 3 + cc;&#125; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;short r[9][10], c[9][10], block[9][10];//分别记录行、列、小格中填数的情况，r表示行，c表示列，block表示小格int board[9][9];struct Pos &#123; int r, c; Pos(int rr, int cc): r(rr), c(cc) &#123; &#125;&#125;;vector&lt;Pos&gt; blank;//结构体+Vector记录空白格inline int Getblock (int r, int c) &#123; int rr = r / 3; int cc = c / 3;; return rr * 3 + cc;&#125; //根据行列求小格void Setflag (int i, int j, int num, int f) &#123; r[i][num] = f; c[j][num] = f; block[Getblock(i, j)][num] = f;&#125; //为某一个元素所在行、列、小格设置上使用过或未使用的标记bool ok (int i, int j, int num) &#123; return !r[i][num] &amp;&amp; !c[j][num] &amp;&amp; !block[Getblock(i, j)][num];&#125; //询问当前位置某元素是否可用bool Dfs (int n) &#123; //n表示现在要填的空格的编号 if (n &lt; 0) return true; int r = blank[n].r, c = blank[n].c; for (int num = 1; num &lt;= 9; ++num) &#123; if (ok(r, c, num)) &#123; board[r][c] = num; Setflag(r, c, num, 1); if (Dfs(n - 1)) return true; Setflag(r, c, num, 0); //回溯 &#125; &#125; return false;&#125; //Based on POJ的毒瘤数据，我们选择右下向左上搜，其实左上向右下搜也可以int main () &#123; int t; cin &gt;&gt; t; //多组数据 while (t--) &#123; memset(r, 0, sizeof(r)); memset(c, 0, sizeof(c)); memset(block, 0, sizeof(block)); blank.clear(); //每组数据都要重置 for (int i = 0; i &lt; 9; ++i) &#123; for (int j = 0; j &lt; 9; ++j) &#123; char c; cin &gt;&gt; c; board[i][j] = c - '0'; //对付每空格的毒瘤数据 if (board[i][j]) Setflag(i, j, board[i][j], 1); else blank.push_back(Pos(i, j)); &#125; &#125; if (Dfs(blank.size() - 1)) &#123; for (int i = 0; i &lt; 9; ++i) &#123; for (int j = 0; j &lt; 9; ++j) cout &lt;&lt; char(board[i][j] + '0'); cout &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 想想当时班里同学整日颓数独的日子，如果我做过这道题的话该是多么好的一个装逼机会啊T\\^T","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://sulfur6.top/tags/学习笔记/"},{"name":"DFS","slug":"DFS","permalink":"http://sulfur6.top/tags/DFS/"},{"name":"POJ","slug":"POJ","permalink":"http://sulfur6.top/tags/POJ/"}],"keywords":[]},{"title":"矩阵乘法优化递推，NOIP%你赛","slug":"矩阵乘法优化递推，NOIP-你赛","date":"2016-10-23T07:27:35.000Z","updated":"2016-10-26T07:29:32.000Z","comments":true,"path":"矩阵乘法优化递推，NOIP-你赛/","link":"","permalink":"http://sulfur6.top/矩阵乘法优化递推，NOIP-你赛/","excerpt":"今天的欢乐%你赛，由于第一题是大水题，第二题良心出题人良心部分分，第三题不严格卡迪杰斯特拉，让人心神愉悦，话虽如此，第二题想要拿满分还是很麻烦的（我才不要分块打表），所以，我们要请出矩阵乘法来优化递推","text":"今天的欢乐%你赛，由于第一题是大水题，第二题良心出题人良心部分分，第三题不严格卡迪杰斯特拉，让人心神愉悦，话虽如此，第二题想要拿满分还是很麻烦的（我才不要分块打表），所以，我们要请出矩阵乘法来优化递推 题目大意给定一个坐标系，可以往左，右，上走，已经走过的点（单次访问中）不可以重复走，一共可以走NNN步，求一共有多少种走法。 题目分析 表神，各单位提供丰富成功地证明了递推公式，然而，不适合这样做的蒟蒻Sulfur6更喜欢打表找规律。 这里我们就假装我们已经打完了这个表，然后发现它的前几项分别是： f(0)=1,f(1)=3,f(2)=7,f(3)=17,f(4)=41,f(5)=99 f(0) = 1, f(1) = 3, f(2) = 7, f(3) = 17, f(4) = 41, f(5) = 99 f(0)=1,f(1)=3,f(2)=7,f(3)=17,f(4)=41,f(5)=99后面不打了T ^ T，所以我们发现了一个递推公式： f(i)=f(i−2)+2×f(i−1) f(i) = f(i - 2) + 2 \\times f(i - 1) f(i)=f(i−2)+2×f(i−1)时间复杂度降至O(n)O(n)O(n)，但是极限数据高达10910^910​9​​，这时O(n)O(n)O(n)不靠谱。而且会MLE 矩阵 说矩阵优化之前先说说矩阵 形如 简而言之，矩阵是一坨数 矩阵乘法对于两个大小为N×MN \\times MN×M和P×NP \\times NP×N的矩阵A,BA,BA,B，他们相乘后的结果矩阵CCC是一个大小为M×PM \\times PM×P的矩阵。 对于矩阵CCC的每一位Ci,jC_{i,j}C​i,j​​，有: Ci,j=∑k=1NAi,k×Bk,j C_{i,j} = \\sum\\limits_{k = 1}^{N} A_{i,k} \\times B_{k,j} C​i,j​​=​k=1​∑​N​​A​i,k​​×B​k,j​​矩阵优化递推 团长并不知道这种玄学方法的由来，只知道我们可以用这种技巧来转移 这样相乘以后的结果: 也就是说我们可以通过矩阵相乘的方式来求出某递推公式的某一项，即: 如何优化 矩阵满足结合律 既然如此，我们就可以出动大杀器，快速幂，这样就可以在O(logn)O(logn)O(logn)的时间内求得递推公式的某一项了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1e9;const int mo = 1e9 + 7;struct Mat &#123; long long a[2][2]; Mat (const bool unit = false) &#123; //构造函数，初始化矩阵值 memset(a, 0, sizeof(a)); if (unit) for (int i = 0; i &lt; 2; i++) a[i][i] = i;//此处矩阵用于快速幂中作为单位矩阵承载答案 &#125; long long &amp;operator()(const int i, const int j = 0) &#123; return a[i][j]; &#125; const long long &amp;operator()(const int i, const int j = 0) const &#123; return a[i][j]; &#125; //重载运算符并引用，快速取得并修改某矩阵的值&#125;;Mat operator*(const Mat &amp;a, const Mat &amp;b) &#123; //重载运算符，矩阵乘法 Mat res(false); for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) (res(i, j) += a(i, k) * b(k, j)) %= mo; return res;&#125;Mat pow(Mat a, int n) &#123; //矩阵快速幂 Mat res(true); for (; n; n &gt;&gt;= 1, a = a * a) if (n &amp; 1) res = res * a; return res;&#125;int main () &#123; freopen(\"coordinate.in\", \"r\", stdin); freopen(\"coordinate.out\", \"w\", stdout); int n; scanf(\"%d\", &amp;n); if (n == 0) printf(\"1\"); else if (n == 1) printf(\"3\"); else &#123; Mat init(false); //初始矩阵 init(0) = 1; init(1) = 3; Mat mat(false); //转移矩阵 mat(0, 0) = 0; mat(0, 1) = 1; mat(1, 0) = 1; mat(1, 1) = 2; Mat res = pow(mat, n - 1) * init; //此处转移矩阵的位置和初始矩阵的位置不可颠倒，因为矩阵不满足交换律 printf(\"%lld\\n\", res(1)); &#125; fclose(stdin); fclose(stdout); return 0;&#125; 最后说几句 这题中使用的矩阵特性就是满足结合律但是不满足交换律 因为是考试的题所以说我还是打了文件输入输出 LaTeX公式和Markdown不兼容真是见鬼了 公式打起来好麻烦 这道题是可以分块打表的 再次%表神cyr","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://sulfur6.top/tags/学习笔记/"},{"name":"递推","slug":"递推","permalink":"http://sulfur6.top/tags/递推/"},{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"http://sulfur6.top/tags/矩阵乘法/"}],"keywords":[]},{"title":"拯救少林神棍，POJ1011，DFS","slug":"拯救少林神棍，POJ1011，DFS","date":"2016-10-22T00:34:21.000Z","updated":"2016-10-26T09:20:12.000Z","comments":true,"path":"拯救少林神棍，POJ1011，DFS/","link":"","permalink":"http://sulfur6.top/拯救少林神棍，POJ1011，DFS/","excerpt":"一般的，在碰到搜索题的时候，我的反应是：woc，这也能搜索？事实证明，我还是too young. 这是一道重在剪枝的神奇DFS题。","text":"一般的，在碰到搜索题的时候，我的反应是：woc，这也能搜索？事实证明，我还是too young. 这是一道重在剪枝的神奇DFS题。 题面 据说,少林寺的镇寺之宝,是救秦王李世民的十三棍僧留下的若干根一样长的棍子。 在民国某年,少林寺被军阀炮轰,这些棍子被炸成N N N节长度各异的小木棒。 战火过后,少林方丈想要用这些木棒拼回原来的棍子。可他记不得原来到底有几根棍子了,只知道古人比较矮,且为了携带方便,棍子一定比较短。他想知道这些棍子最短可能有多短。 看到这个题面之后，我整个人都不好了qwq 题目大意 给定NNN节长度各异的小木棒，不剩余地拼成若干节长度相等的少林神棍，求神棍最短可以有多短。 解题思路枚举 可能拼成的棍子长度 长度从最长的那根木棒开始枚举到木棒总长的一半 若枚举到的长度不能整除木棒总长度，则不去搜索 搜索 搜索的过程，就是我们尝试着拼神棍的过程 如何拼完这一组神棍呢？ 一根一根的拼棍子 如果拼完第iii根棍子之后，发现第i+1i+1i+1根棍子拼不成了，那就推翻第iii根棍子的拼法 有可能一直向前推翻第一根的拼法 搜索状态 发现能搜索以后，就要确定搜索状态了 我们设状态为一个二元组(R,M)(R,M)(R,M)。 RRR表示还没有用的木棒数 MMM表示当前拼的这根棍子剩余未填满的长度 本题的初始状态和结束状态是什么？ 假设共有NNN根木棒，当前枚举到的长度为LLL。 初始状态：(N,L)(N,L)(N,L) 结束状态：(0,0)(0,0)(0,0) 开始搜索 我也不废话了，伪代码参上 1234Dfs的基本递推关系:bool Dfs(int R, int M) &#123; if( R == 0 &amp;&amp; M == 0) return true; //拼接任务完成 如果能找到一根长为S(S &lt;= M)的木棒,拼在当前棍子上,然后 Dfs(R – 1,M - S); 如果找不到:return false; &#125; 这里要注意的是我们首先要对长度排序，从大到小枚举 剪枝 如果按照之前的搜法，那么一定会TLE 所以，我们需要出动暴力大杀器——剪枝 剪枝1 如果在当前状态下确定了一根不能使用的木棒，那么当我们弃用它以后，当前状态下和它长度同的木棒都不再使用。 正确性显然 剪枝2 由于拼接失败，我们需要拆掉某根棍子时，如果我们一直拆解到它的第一根木棒，那么我们就不再动它，去看它的上一根棍子，如果它没有上一根棍子，则此长度不合法 如果拆掉第一根木棒，我们假设它在之后能被使用，而现在已知序列是有序的，那么如果之后某种拼法能使得当前第一根棍子被用到，那么它在之前序列一定不会被拆掉。 剪枝3 当我们需要拆解某根已经拼好的棍子时，不要拆掉最后的那根木棒反而用更小的木棒来代替。 如果这样就能拼上，那么我们用用来代替最后长木棒的几根短木棒来代替那根长木棒也能拼上。 剪枝4 如果当前需要加的木棒不是当前棍子的第一根，那么我们不能从最长的木棒往下枚举，而是从最近使用过的那根之后的一根开始向下枚举。 这样可以避免先使用长的后使用短的的情况。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int n, l; bool used[65];vector &lt;int&gt; len;int last;bool dfs (int r, int m) &#123; if (r == 0 &amp;&amp; m == 0) return true;//搜索停止，达到条件返回true，表示枚举的长度可行 if (m == 0) m = l;//如果已经拼完一根，那么就再接着往下拼 int S = 0; if (m != l) S = last + 1;//剪枝4，保证递减拼 for (int i = S; i &lt; n; i++) &#123; if (!used[i] &amp;&amp; len[i] &lt;= m) &#123; if (i &gt; 0) &#123; if (!used[i - 1] &amp;&amp; len[i] == len[i - 1]) continue;//剪枝1，保证相同长度的木棒不在同一位置多次用 &#125; used[i] = true; last = i;//标记此根为使用过，记录本次加入的木棒 if (dfs(r - 1, m - len[i])) return true; else &#123; used[i] = 0;//回溯，有可能之后还能用到这根木棒 if (len[i] == m || m == l) return false;//剪枝2，3 &#125; &#125; &#125; return false;&#125;int main () &#123; while (1) &#123; cin &gt;&gt; n; if (n == 0) break;//Blocks of datas, 读入0终止 len.clear();//每次清一遍储存长度的数组 int totallen = 0; for (int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; len.push_back(x); totallen += x; &#125; sort (len.begin(), len.end(), greater&lt;int&gt;());//从小到大排序 for (l = len[0]; l &lt;= totallen / 2; l++) &#123; if (totallen % l) continue; memset(used, 0, sizeof(used)); if (dfs(n, l)) &#123;cout &lt;&lt; l &lt;&lt; endl; break;&#125;//因为是从小到大枚举，所以验证一个答案正确就可以输出了 &#125; if (l &gt; totallen / 2) cout &lt;&lt; totallen &lt;&lt; endl; &#125; return 0;&#125; 团长在POJ和HDU上都成功拯救了少林神棍，但是原题并不叫拯救少林神棍，而是叫Sticks，很无聊的题面，某不远透露姓名的薛定谔同学竟然告诉我这是一道POJ上的中文题，害的我一阵好找。。。。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://sulfur6.top/tags/学习笔记/"},{"name":"DFS","slug":"DFS","permalink":"http://sulfur6.top/tags/DFS/"},{"name":"POJ","slug":"POJ","permalink":"http://sulfur6.top/tags/POJ/"},{"name":"剪枝","slug":"剪枝","permalink":"http://sulfur6.top/tags/剪枝/"}],"keywords":[]},{"title":"杨威利与莱因哈特的爱恨情仇","slug":"ywl","date":"2016-10-20T13:05:09.000Z","updated":"2016-10-26T09:20:21.000Z","comments":true,"path":"ywl/","link":"","permalink":"http://sulfur6.top/ywl/","excerpt":"蒟蒻Sulfur6在第一次看见这道题的时候感觉它好水啊，然后五分钟打了个自以为是的正解。。肯定是错的太离谱了，那天晚上的代码带崩了我的三个系统。。。 刚刚学习并查集的时候就见过那个题，当时连最水的家族都做不出，真的是连题面都没看就跳过去了。","text":"蒟蒻Sulfur6在第一次看见这道题的时候感觉它好水啊，然后五分钟打了个自以为是的正解。。肯定是错的太离谱了，那天晚上的代码带崩了我的三个系统。。。 刚刚学习并查集的时候就见过那个题，当时连最水的家族都做不出，真的是连题面都没看就跳过去了。 题目大意给定一个最多有30000艘船的船队，初始状态一字排开。 接下来你要读入 T T T 个指令 (1≤T≤5000001 \\leq T \\leq 5000001≤T≤500000)： 若为MijM i jMij，则将iii所在的舰队移动到jjj所在舰队的后面（即将第iii艘舰船所在的战舰队列全部移动到第jjj列舰船所在战舰队列的后面）； 若为CijC i jCij，如果第i,ji,ji,j艘舰船在同一列中，则输出它们中间有的舰船数，如果不在同一列中，则输出−1-1−1。 这里要注意的是（可能只有我一个人这么智障），就是给定合并操作的iji jij可能只是一列舰船中间或末尾的那个，不一定就是某列舰船的第一个。【天真的以为一定给定第一艘的蒟蒻就这么WA挺了。 压缩路径 分析完题目大意之后我们会自然而然的想到一种做法，那就是记录每一列舰船所在的位置 但是这样显然不靠谱，因为不路径压缩的UFS会爆炸。 怎么在压缩路径的基础上维护战舰所在位置的信息呢？某优化如果说大家和我一样记得并查集路径压缩的代码的话，我们会发现，在路径压缩之前并没有维护什么信息，所以我们尝试着来搞一些事情 12345678910111213int a[MAXN];//某列战舰现有的战舰数，初始化为1int b[MAXN];/*某列战舰现在在本列战舰内的深度，初始化为0*/int fa[MAXN];//UFS中用的father数组int find (int x) &#123; int t; if (x != fa[x]) &#123; t = find(fa[x]); b[x] += b[fa[x]];//这一句包括上面一句类似于递归求解确定x战舰在本列中的位置 fa[x] = t; &#125; return fa[x];&#125; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;const int maxn = 30000;const int maxt = 500000;int fa[maxn + 5], a[maxn + 5], b[maxn + 5];int ans;int find (int x) &#123; int t; if (x != fa[x]) &#123; t = find(fa[x]); b[x] += b[fa[x]]; fa[x] = t; &#125; return fa[x];&#125;int T;int main () &#123; scanf(\"%d\", &amp;T); for (int i = 1; i &lt;= maxn + 1; i++) &#123; fa[i] = i; a[i] = 1; &#125; char c; int x, y; while (T--) &#123; scanf(\"\\n%c %d %d\", &amp;c, &amp;x, &amp;y); int f1 = find(x); int f2 = find(y); if (c == 'M') &#123;//合并操作 fa[f1] = f2;//修改战舰头 b[f1] = a[f2];//修改战舰层数 a[f2] += a[f1];//增加合并后该列的战舰数 &#125; else &#123; if (f1 == f2) &#123; ans = abs(b[x] - b[y]) - 1;//这里要记得-1，因为编号从0开始 printf(\"%d\\n\", ans); &#125; else printf(\"-1\\n\"); &#125; &#125; return 0;&#125; 看这个难度也知道是NOI的一道水题，毕竟我这样的蒟蒻都能A。。 当年看着唐氏Pascal学并查集就死活学不会了，思想都不懂，这里要感谢教会我并查集的神犇Menci和Gty.","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://sulfur6.top/tags/学习笔记/"},{"name":"并查集","slug":"并查集","permalink":"http://sulfur6.top/tags/并查集/"},{"name":"路径压缩","slug":"路径压缩","permalink":"http://sulfur6.top/tags/路径压缩/"},{"name":"NOI","slug":"NOI","permalink":"http://sulfur6.top/tags/NOI/"}],"keywords":[]}]}