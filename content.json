{"meta":{"title":"Sulfur6's Blog","subtitle":"但行好事，莫问前程","description":"A Kind Father","author":"Sulfur6","url":"http://sulfur6.github.io"},"pages":[{"title":"Friend","date":"2017-01-12T23:54:55.000Z","updated":"2017-01-12T23:56:10.000Z","comments":true,"path":"Friends/index.html","permalink":"http://sulfur6.github.io/Friends/index.html","excerpt":"","text":"Friends listLYOI2015Other OIers"},{"title":"","date":"2017-06-20T06:38:43.000Z","updated":"2016-12-23T14:01:36.000Z","comments":false,"path":"categories/index.html","permalink":"http://sulfur6.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-06-20T06:38:43.000Z","updated":"2016-12-23T13:58:16.000Z","comments":false,"path":"tags/index.html","permalink":"http://sulfur6.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"「JSOI2007」麻将","slug":"bzoj-1028","date":"2017-07-07T00:54:30.000Z","updated":"2017-07-07T07:13:20.000Z","comments":true,"path":"bzoj-1028/","link":"","permalink":"http://sulfur6.github.io/bzoj-1028/","excerpt":"麻将是中国传统的娱乐工具之一。麻将牌的牌可以分为字牌（共有东、南、西、北、中、发、白七种）和序数牌（分为条子、饼子、万子三种花色，每种花色各有一到九的九种牌），每种牌各四张。在麻将中，通常情况下一组和了的牌（即完成的牌）由十四张牌组成。十四张牌中的两张组成对子（即完全相同的两张牌），剩余的十二张组成三张一组的四组，每一组须为顺子（即同花色且序数相连的序数牌，例如条子的三、四、五）或者是刻子（即完全相同的三张牌）。一组听牌的牌是指一组十三张牌，且再加上某一张牌就可以组成和牌。那一张加上的牌可以称为等待牌。在这里，我们考虑一种特殊的麻将。在这种特殊的麻将里，没有字牌，花色也只有一种。但是，序数不被限制在一到九的范围内，而是在 1 1 1 到 n n n 的范围内。同时，也没有每一种牌四张的限制。一组和了的牌由 3m+2 3m + 2 3m+2 张牌组成，其中两张组成对子，其余 3m 3m 3m 张组成三张一组的 m m m 组，每组须为顺子或刻子。现给出一组 3m+1 3m + 1 3m+1 张的牌，要求判断该组牌是否为听牌（即还差一张就可以和牌）。如果是的话，输出所有可能的等待牌。","text":"麻将是中国传统的娱乐工具之一。麻将牌的牌可以分为字牌（共有东、南、西、北、中、发、白七种）和序数牌（分为条子、饼子、万子三种花色，每种花色各有一到九的九种牌），每种牌各四张。在麻将中，通常情况下一组和了的牌（即完成的牌）由十四张牌组成。十四张牌中的两张组成对子（即完全相同的两张牌），剩余的十二张组成三张一组的四组，每一组须为顺子（即同花色且序数相连的序数牌，例如条子的三、四、五）或者是刻子（即完全相同的三张牌）。一组听牌的牌是指一组十三张牌，且再加上某一张牌就可以组成和牌。那一张加上的牌可以称为等待牌。在这里，我们考虑一种特殊的麻将。在这种特殊的麻将里，没有字牌，花色也只有一种。但是，序数不被限制在一到九的范围内，而是在 1 1 1 到 n n n 的范围内。同时，也没有每一种牌四张的限制。一组和了的牌由 3m+2 3m + 2 3m+2 张牌组成，其中两张组成对子，其余 3m 3m 3m 张组成三张一组的 m m m 组，每组须为顺子或刻子。现给出一组 3m+1 3m + 1 3m+1 张的牌，要求判断该组牌是否为听牌（即还差一张就可以和牌）。如果是的话，输出所有可能的等待牌。 题解一开始的时候我考虑暴搜和DP，但是没想到DP该怎么设计状态（这么乱的状态不好用DP表示啊），也考虑了暴搜，但是看看数据范围十分不靠谱，没想到是暴力 + 贪心。 看看数据范围，发现 n n n 很小，考虑枚举序数 i i i 作为等待牌，然后暴力判断 i i i 作为等待牌是否可行。 在判断的时候，从 1 1 1 枚举到 n n n 枚举，首先考虑枚举到的序数作为刻子，剩下的同后两位连成顺子。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAX_N = 400;const int MAX_M = 1000;int n, m;int s[MAX_N + 1], f[MAX_N + 1];int ans[MAX_N + 1], cnt;inline bool judge() &#123; for (int i = 1; i &lt;= n; i++) &#123; if (s[i] &gt;= 2) &#123; s[i] -= 2; for (int j = 1; j &lt;= n + 2; j++) f[j] = s[j]; bool flag = true; for (int j = 1; j &lt;= n + 2; j++) &#123; if (f[j] &lt; 0) &#123; flag = false; break; &#125; f[j] %= 3; f[j + 1] -= f[j], f[j + 2] -= f[j]; &#125; s[i] += 2; if (flag) return true; &#125; &#125; return false;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m * 3 + 1; i++) &#123; int x; scanf(\"%d\", &amp;x); s[x]++; &#125; bool flag = false; for (int i = 1; i &lt;= n; i++) &#123; s[i]++; if (judge()) ans[cnt++] = i, flag = true; s[i]--; &#125; if (flag) for (int i = 0; i &lt; cnt; i++) &#123; printf(\"%d\", ans[i]); if (i != cnt - 1) printf(\" \"); &#125; else printf(\"NO\"); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://sulfur6.github.io/tags/贪心/"},{"name":"暴力","slug":"暴力","permalink":"http://sulfur6.github.io/tags/暴力/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「JSOI2007」合金 - 计算几何，Floyd","slug":"bzoj-1027","date":"2017-07-05T00:47:58.000Z","updated":"2017-07-05T07:02:06.000Z","comments":true,"path":"bzoj-1027/","link":"","permalink":"http://sulfur6.github.io/bzoj-1027/","excerpt":"某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 现在，用户给出了 n n n 种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。","text":"某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 现在，用户给出了 n n n 种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。 题解像我这种菜鸡看了题目描述就开始往网络流和DP上去考虑。。结果发现好像网络流很难这样做，然后DP我死活设计不出状态，打开题解以后发现这题原来是十分巧妙的计算几何。。 首先，由于 a+b+c=1 a + b + c = 1 a+b+c=1，所以我们只需要知道其中两个值就可以，并不需要准确了解第三个值，体现在算法中就是只记录 a,b a, b a,b。这样我们就可以把一种材料或者合金抽象成一个平面上的点，每个点的坐标为 (a,b) (a, b) (a,b)。 对于两个点 (x1,y1),(x2,y2) (x_1, y_1), (x_2, y_2) (x​1​​,y​1​​),(x​2​​,y​2​​) 所代表的原料，他们能够合成的合金一定在这两点之间的线段上，其坐标为 (ax1+bx2,ay1+by2) (ax_1 + bx_2, ay_1 + by_2) (ax​1​​+bx​2​​,ay​1​​+by​2​​)，其中 a+b=1 a + b = 1 a+b=1。 而对于三个点即以上代表的原料，他们能够合成的合金一定在这些点的凸包上。 记代表原料的点集为 A A A，代表合金的点集 B B B，问题实际上就是求出 A A A 的一个子集，使得其中点的凸包能够完全覆盖 B B B 中的所有点。 讲实话这个东西我不会求。。我不知道用传统的方法该怎么做，所以就学了人家巧妙的转化成最短路的方法。 首先，我们 O(n2) O(n ^ 2) O(n​2​​) 枚举 A A A 中的两个点 N,M N, M N,M，对于 ，如果 B B B 中所有点都在 的同侧（左侧或右侧，按下文判断方法应该是右侧顺时针）或是在 上，则连接一条 N→M N \\rightarrow M N→M 的边。 判断方法如下： 对于枚举到的点 N,M N, M N,M，枚举 B B B 中的点 K K K，若所有 K K K 满足 则连接一条 N→M N \\rightarrow M N→M 的边，最后用 Floyd 求最小环即可。 注：程序中的 K K K 为小写，N,M N, M N,M 分别为 i,j i, j i,j，这里是为了表述美观而更改。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cfloat&gt;#include &lt;algorithm&gt;const int MAX_N = 500;const int MAX_M = 500;const double EPS = 1e-7;const int INF = 0x3f3f3f3f;struct Point &#123; double x, y; Point() &#123;&#125; Point(double x, double y) : x(x), y(y) &#123;&#125; friend inline Point operator-(const Point &amp;a, const Point &amp;b) &#123; return Point(a.x - b.x, a.y - b.y); &#125; friend inline double operator*(const Point &amp;a, const Point &amp;b) &#123; return a.x * b.y - a.y * b.x; &#125; friend inline double dot(const Point &amp;a, const Point &amp;b) &#123; return a.x * b.x + a.y * b.y; &#125;&#125; a[MAX_M + 1], b[MAX_N + 1];int m, n, map[MAX_N + 1][MAX_N + 1], f[MAX_N + 1][MAX_N + 1];inline int floyd() &#123; int res = INF; memcpy(f, map, sizeof(f)); for (int k = 1; k &lt;= m; k++) &#123; for (int i = 1; i &lt;= m; i++) &#123; if (f[i][k] &lt; INF) &#123; for (int j = 1; j &lt;= m; j++) &#123; f[i][j] = std::min(f[i][j], f[i][k] + f[k][j]); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= m; i++) res = std::min(res, f[i][i]); return res;&#125;int main() &#123; memset(map, 0x3f, sizeof(map)); scanf(\"%d %d\", &amp;m, &amp;n); for (int i = 1; i &lt;= m; i++) scanf(\"%lf%lf%*lf\", &amp;a[i].x, &amp;a[i].y); for (int i = 1; i &lt;= n; i++) scanf(\"%lf%lf%*lf\", &amp;b[i].x, &amp;b[i].y); for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; int k; for (k = 1; k &lt;= n; k++) &#123; double det = (a[i] - b[k]) * (a[j] - b[k]); if (det &gt; EPS) break; if (fabs(det) &lt; EPS &amp;&amp; dot(a[i] - b[k], a[j] - b[k]) &gt; EPS) break; &#125; if (k == n + 1) map[i][j] = 1; &#125; &#125; int ans = floyd(); if (ans == INF) puts(\"-1\"); else printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"Floyd","slug":"Floyd","permalink":"http://sulfur6.github.io/tags/Floyd/"},{"name":"计算几何","slug":"计算几何","permalink":"http://sulfur6.github.io/tags/计算几何/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「SCOI2009」游戏 - DP，线性筛，置换","slug":"bzoj-1025","date":"2017-07-04T06:48:54.000Z","updated":"2017-07-05T09:35:21.000Z","comments":true,"path":"bzoj-1025/","link":"","permalink":"http://sulfur6.github.io/bzoj-1025/","excerpt":"对于一个长度为 n n n 的序列 A A A，记其置换集合为 G G G，对于 f∈G f \\in G f∈G，记使得 的嵌套次数为其排数，求对于所有 f∈G f \\in G f∈G 共有多少种不同的排数。","text":"对于一个长度为 n n n 的序列 A A A，记其置换集合为 G G G，对于 f∈G f \\in G f∈G，记使得 的嵌套次数为其排数，求对于所有 f∈G f \\in G f∈G 共有多少种不同的排数。 题解将置换改写成轮换，一个很显然的结论是：对于一个置换，所求排数为改写成轮换后所有环的点数的最小公倍数 + 1 1 1。 所以问题变为，把 n n n 分成 k k k 个数 满足 ∑ai=n \\sum a_i = n ∑a​i​​=n，求 lcm(ai) \\text{lcm}(a_i) lcm(a​i​​) 的不同取值个数。 首先要说明一个性质，就是若干个数的最小公倍数一定可以改写成若干个素数的幂的最小公倍数。 以两个数的情况为例：设 k1=a1p1a2p2a3p3 k_1 = a_1 ^ {p_1} a_2 ^ {p_2} a_3 ^ {p_3} k​1​​=a​1​p​1​​​​a​2​p​2​​​​a​3​p​3​​​​，k2=a1p4a2p5a3p6 k_2 = a_1 ^ {p_4} a_2 ^ {p_5} a_3 ^ {p_6} k​2​​=a​1​p​4​​​​a​2​p​5​​​​a​3​p​6​​​​，并且 p1&gt;p4,p2&lt;p5,p3&gt;p6 p_1 &gt; p_4, p_2 &lt; p_5, p_3 &gt; p_6 p​1​​&gt;p​4​​,p​2​​&lt;p​5​​,p​3​​&gt;p​6​​，那么 lcm(k1,k2)=a1p1a2p5a3p3=lcm(a1p1,a2p5,a3p3) \\text{lcm}(k_1, k_2) = a_1 ^ {p_1} a_2 ^ {p_5} a_3 ^ {p_3} = \\text{lcm}(a_1 ^ {p_1}, a_2 ^ {p_5}, a_3 ^ {p_3}) lcm(k​1​​,k​2​​)=a​1​p​1​​​​a​2​p​5​​​​a​3​p​3​​​​=lcm(a​1​p​1​​​​,a​2​p​5​​​​,a​3​p​3​​​​)。 当然这个证明不是很严谨啦我也知道不要喷我啦。。这不算是证明只是个说明啦。。其他情况和这种情况也都差不多，所以我们知道，只考虑素数的幂就可以取得所有的不同取值。 考虑DP，以使用不同的素数为阶段，可以满足无后效性，设 f(i,j) f(i, j) f(i,j) 表示目前使用了前 i i i 个素数，这些素数的幂的和为 j j j 时的不同最小公倍数个数，用类似背包的形式转移，具体转移见代码。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAX_N = 1000;const int MAX_CNT = 168;bool isNotPrime[MAX_N + 1];int primes[MAX_N + 1], cnt;inline void sieve(int n) &#123; isNotPrime[1] = true; for (int i = 2; i &lt;= n; i++) &#123; if (!isNotPrime[i]) primes[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; primes[j] * i &lt;= n; j++) &#123; int p = primes[j]; isNotPrime[i * p] = true; if (i % p == 0) break; &#125; &#125;&#125;unsigned long long f[MAX_CNT + 1][MAX_N + 1];int main() &#123; int n; scanf(\"%d\", &amp;n); sieve(n); for (int i = 0; i &lt;= cnt; i++) f[i][0] = 1; for (int j = 0; j &lt;= n; j++) f[0][j] = 1; for (int i = 1; i &lt;= cnt; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; f[i][j] = f[i - 1][j]; for (int k = primes[i]; k &lt;= j; k *= primes[i]) &#123; f[i][j] += f[i - 1][j - k]; &#125; &#125; &#125; printf(\"%llu\\n\", f[cnt][n]); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.github.io/tags/DP/"},{"name":"线性筛","slug":"线性筛","permalink":"http://sulfur6.github.io/tags/线性筛/"},{"name":"置换","slug":"置换","permalink":"http://sulfur6.github.io/tags/置换/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「SCOI2009」生日快乐","slug":"bzoj-1024","date":"2017-07-04T02:39:29.000Z","updated":"2017-07-04T03:19:35.000Z","comments":true,"path":"bzoj-1024/","link":"","permalink":"http://sulfur6.github.io/bzoj-1024/","excerpt":"现有一块长为 X X X，宽为 Y Y Y 的蛋糕，切 N−1 N - 1 N−1 刀，分成 N N N 块，在保证每块蛋糕面积相等的前提下使得 N N N 块切好的蛋糕长边比短边的最大值最小，求这个最小值。","text":"现有一块长为 X X X，宽为 Y Y Y 的蛋糕，切 N−1 N - 1 N−1 刀，分成 N N N 块，在保证每块蛋糕面积相等的前提下使得 N N N 块切好的蛋糕长边比短边的最大值最小，求这个最小值。 题解乍一看感觉除了搜好像没有什么更好的做法，但是想了想感觉 X,Y X, Y X,Y 的范围看起来让人发虚。。 于是就咸鱼的看了题解。。才注意到 N≤10 N \\leq 10 N≤10 这个可爱的条件。 首先，对于需要被等分成 N N N 块的长为 X X X，宽为 Y Y Y 的蛋糕，若横切，则分成的两块的宽度必须为 ⌊YN⌋ \\lfloor \\frac Y N \\rfloor ⌊​N​​Y​​⌋ 的整数倍，否则一定无法满足等分，纵切情况类似。 由于 N N N 很小，可以直接暴搜，设当前状态为面对一块长为 x x x，宽为 y y y，需要被分成 d d d 块的蛋糕，分横切纵切枚举分成的两块的长或宽，搜出来最大的长宽比更新答案即可。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;double dfs(double x, double y, int d) &#123; double res = 100000.0; if (d == 1) &#123; if (x &lt; y) std::swap(x, y); return x / y; &#125; double xx = x / d; for (int i = 1; i &lt;= d / 2; i++) &#123; double temp = std::max(dfs(xx * i, y, i), dfs(x - xx * i, y, d - i)); res = std::min(res, temp); &#125; double yy = y / d; for (int i = 1; i &lt;= d / 2; i++) &#123; double temp = std::max(dfs(x, yy * i, i), dfs(x, y - yy * i, d - i)); res = std::min(res, temp); &#125; return res;&#125;int main() &#123; int x, y, n; scanf(\"%d %d %d\", &amp;x, &amp;y, &amp;n); printf(\"%.6lf\\n\", dfs(x, y, n)); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://sulfur6.github.io/tags/搜索/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「SHOI2008」仙人掌图 - 仙人掌DP，单调队列","slug":"bzoj-1023","date":"2017-07-03T13:04:21.000Z","updated":"2017-07-04T02:40:40.000Z","comments":true,"path":"bzoj-1023/","link":"","permalink":"http://sulfur6.github.io/bzoj-1023/","excerpt":"给定一个仙人掌图，求其直径。","text":"给定一个仙人掌图，求其直径。 题解仙人掌什么的好难呀，看了好长时间的题解才理解究竟要怎么做，不过感觉还是蛮有趣的，处理树上和环上的方式也很巧妙，那么我就简单口胡一下。。 选一个点为根，DFS 整棵树，设 f(i) f(i) f(i) 表示DFS树中以节点 i i i 为根的子树的点集在原图中的诱导子图中以 i i i 开始的最长路径。 若不考虑环，记 Si S_i S​i​​ 为节点 i i i 的儿子集合，则有 f(i)=maxj∈Si(f(j)+1) f(i) = \\max\\limits_{j \\in S_i}(f(j) + 1) f(i)=​j∈S​i​​​max​​(f(j)+1)。 然而由于环的存在，会使得某些点之间的距离变小，从而影响维护到的 f f f 值的正确性，所以我们在转移 f(i) f(i) f(i) 时需要满足转移到他的节点 j j j 不和 i i i 处在同一个环上，即不在同一个环上转移 f f f。 判断环的问题，只需要在 DFS 的时候按照 Tarjan 算法的流程记录每个点的 low \\text{low} low 和 dfn \\text{dfn} dfn 即可。 由于仙人掌的特性，以及 DFS 的过程，对于每个环都可以找到一个深度最小的点，我们称这个点为 最高点，显然的，这个环的祖先的 f f f 值的更新需要且仅需要用到最高点的 f f f 值，所以对于整个环，在用环上的节点的不在环上的子节点更新过自身的 f f f 后，只需要再更新最高点的 f f f 值即可。 设最高点为 u u u，则 f(u) f(u) f(u) 由环上节点转移的方式为 f(u)=f(v)+dist(u,v) f(u) = f(v) + \\text{dist}(u, v) f(u)=f(v)+dist(u,v) ，其中 v v v 和 u u u 在同一环上， 以上内容全部是关于 f f f 值的更新，接下来要说的是更新答案的方式。 对于桥上的答案，我们在 DFS 过程中更新 f f f 值的同时更新答案，设答案为 ans \\text{ans} ans，目前正在更新 f f f 值的节点为 i i i，则此时有 ans=f(i)+f(j)+1,j∈Si \\text{ans} = f(i) + f(j) + 1, j \\in S_i ans=f(i)+f(j)+1,j∈S​i​​。注意要在尝试从节点 j j j 转移 f f f 值之前更新答案，否则不能涵盖所有情况，还可能导致状态出现错误。 显然地，环上的节点也可以用来更新答案。对于环上的节点 i,j i, j i,j 来说，其导致的答案的形式应该是 f(i)+f(j)+dist(i,j) f(i) + f(j) + \\text{dist}(i, j) f(i)+f(j)+dist(i,j)。设 s(i) s(i) s(i) 为节点 i i i 在环上的编号（编号按照 DFS树 上的深度为顺序），则原式可以改写成为 f(i)+f(j)+∣s(i)−s(j)∣ f(i) + f(j) + |s(i) - s(j)| f(i)+f(j)+∣s(i)−s(j)∣。如果按照深度为顺序转移答案，并且保证在枚举到节点 i i i 时转移区间连续并且长度不超过环长度的一半，就可以使用单调队列维护 f(j)−s(j) f(j) - s(j) f(j)−s(j) 的值来优化转移。 具体细节详见代码。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;const int MAX_N = 50000;struct Node;struct Edge;struct Node &#123; Edge *e; Node *fa; int dfn, low; int len; bool vis;&#125; N[MAX_N + 1];struct Edge &#123; Node *fr, *to; Edge *ne; Edge(Node *fr, Node *to) : fr(fr), to(to), ne(fr-&gt;e) &#123;&#125;&#125;;inline void addEdge(int fr, int to) &#123; N[fr].e = new Edge(&amp;N[fr], &amp;N[to]); N[to].e = new Edge(&amp;N[to], &amp;N[fr]);&#125;inline void circle(Node *top, Node *u, int &amp;ans) &#123; static Node *v[MAX_N * 2]; int cnt = 0; while (true) &#123; v[cnt++] = u; if (u == top) break; u = u-&gt;fa; &#125; std::reverse(v, v + cnt); std::copy(v, v + cnt, v + cnt); int half = cnt / 2; static int q[MAX_N * 2]; int *l = q, *r = q; *r = 0; for (int i = 1; i &lt; cnt * 2; i++) &#123; while (i - *l &gt; half) l++; ans = std::max(ans, v[*l]-&gt;len + v[i]-&gt;len + i - *l); while (l &lt;= r &amp;&amp; v[i]-&gt;len - i &gt; v[*r]-&gt;len - *r) r--; *++r = i; &#125; int res = 0; for (int i = 1; i &lt; cnt; i++) &#123; res = std::max(res, v[i]-&gt;len + std::min(i, cnt - i)); &#125; top-&gt;len = std::max(top-&gt;len, res);&#125;int ans = 0;void tarjan(Node *v) &#123; static int ts = 0; v-&gt;dfn = v-&gt;low = ++ts; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;to != v-&gt;fa) &#123; if (!e-&gt;to-&gt;dfn) &#123; e-&gt;to-&gt;fa = v; tarjan(e-&gt;to); v-&gt;low = std::min(v-&gt;low, e-&gt;to-&gt;low); &#125; else v-&gt;low = std::min(v-&gt;low, e-&gt;to-&gt;dfn); if (v-&gt;dfn &lt; e-&gt;to-&gt;low) &#123; ans = std::max(ans, v-&gt;len + e-&gt;to-&gt;len + 1); v-&gt;len = std::max(v-&gt;len, e-&gt;to-&gt;len + 1); &#125; &#125; &#125; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;to-&gt;fa != v &amp;&amp; e-&gt;to-&gt;dfn &gt; v-&gt;dfn) &#123; circle(v, e-&gt;to, ans); &#125; &#125;&#125;int main() &#123; int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int k, u; scanf(\"%d %d\", &amp;k, &amp;u); for (int j = 2; j &lt;= k; j++) &#123; int v; scanf(\"%d\", &amp;v); addEdge(u, v); u = v; &#125; &#125; tarjan(&amp;N[1]); printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"单调队列","slug":"单调队列","permalink":"http://sulfur6.github.io/tags/单调队列/"},{"name":"DP","slug":"DP","permalink":"http://sulfur6.github.io/tags/DP/"},{"name":"仙人掌图","slug":"仙人掌图","permalink":"http://sulfur6.github.io/tags/仙人掌图/"},{"name":"仙人掌DP","slug":"仙人掌DP","permalink":"http://sulfur6.github.io/tags/仙人掌DP/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「SHOI2008」循环的债务 - DP","slug":"bzoj-1021","date":"2017-06-19T03:34:29.000Z","updated":"2017-06-19T09:39:42.000Z","comments":true,"path":"bzoj-1021/","link":"","permalink":"http://sulfur6.github.io/bzoj-1021/","excerpt":"A，B，C 三个人之间互相有一些债务，每个人有面值为 1,5,10,20,50,100 1, 5, 10, 20, 50, 100 1,5,10,20,50,100 的钞票若干，求出他们之间钞票交换次数最少的交换方式。","text":"A，B，C 三个人之间互相有一些债务，每个人有面值为 1,5,10,20,50,100 1, 5, 10, 20, 50, 100 1,5,10,20,50,100 的钞票若干，求出他们之间钞票交换次数最少的交换方式。 题解最开始看到这道题的时候，我还以为这题是网络流。。现在看看我还是 too young.. 好吧可以说团长的DP是真的好差。。 这道题的初始状态就像题目描述中说的那样，终止状态应该是 A，B，C 各自还清债务又收回欠款，由于欠款可以用一个 DAG 来描述（若成环则去掉环中权值最小的边），所以终止状态下 A，B，C 拥有的钱的数目是一定的，所以尝试使用钱数作为状态。 设 f(i,a,b) f(i, a, b) f(i,a,b) 为使用前 i i i 种面值的钞票，使得 A A A 有 a a a 元，B B B 有 b b b 元的最小交换次数。 枚举交换方式，有如下几种交换： 其中 a→b a \\rightarrow b a→b 意为 a a a 把钱给 b b b。 代码#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAX_M = 1000;const int VAL[] = &#123; -1, 1, 5, 10, 20, 50, 100 &#125;;int sum[3], own[3][6 + 1];int tot;int f[6 + 1][MAX_M + 1][MAX_M + 1];int main() &#123; int a, b, c; scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); if (a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; c &gt; 0) &#123; int min = std::min(std::min(a, b), c); a -= min, b -= min, c -= min; &#125; else if (a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; c &gt; 0) &#123; int max = std::max(std::max(a, b), c); a -= max, b -= max, c -= max; &#125; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 6; j++) &#123; scanf(\"%d\", &amp;own[i][6 - j]); sum[i] += own[i][6 - j] * VAL[6 - j]; &#125; tot += sum[i]; &#125; for (int i = 0; i &lt;= 6; i++) for (int j = 0; j &lt;= MAX_M; j++) for (int k = 0; k &lt;= MAX_M; k++) f[i][j][k] = INT_MAX; f[0][sum[0]][sum[1]] = 0; for (int i = 0; i &lt; 6; i++) &#123; for (int a = 0; a &lt;= tot; a++) &#123; for (int b = 0; b &lt;= tot - a; b++) &#123; int c = tot - a - b; if (f[i][a][b] == INT_MAX) continue; // a -&gt; b, c for (int tb = 0; tb &lt;= own[0][i + 1]; tb++) &#123; for (int tc = 0; tc &lt;= own[0][i + 1] - tb; tc++) &#123; if (tb + tc == 0) continue; int _a = a - VAL[i + 1] * (tb + tc); int _b = b + VAL[i + 1] * tb; int _c = c + VAL[i + 1] * tc; f[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + tb + tc); &#125; &#125; // b -&gt; a, c for (int ta = 0; ta &lt;= own[1][i + 1]; ta++) &#123; for (int tc = 0; tc &lt;= own[1][i + 1] - ta; tc++) &#123; if (ta + tc == 0) continue; int _a = a + VAL[i + 1] * ta; int _b = b - VAL[i + 1] * (ta + tc); int _c = c + VAL[i + 1] * tc; f[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tc); &#125; &#125; // c -&gt; a, b for (int ta = 0; ta &lt;= own[2][i + 1]; ta++) &#123; for (int tb = 0; tb &lt;= own[2][i + 1] - ta; tb++) &#123; if (ta + tb == 0) continue; int _a = a + VAL[i + 1] * ta; int _b = b + VAL[i + 1] * tb; int _c = c - VAL[i + 1] * (ta + tb); f[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tb); &#125; &#125; // a, b -&gt; c for (int fa = 0; fa &lt;= own[0][i + 1]; fa++) &#123; for (int fb = 0; fb &lt;= own[1][i + 1]; fb++) &#123; if (fa + fb == 0) continue; int _a = a - VAL[i + 1] * fa; int _b = b - VAL[i + 1] * fb; int _c = c + VAL[i + 1] * (fa + fb); f[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fb); &#125; &#125; // a, c -&gt; b for (int fa = 0; fa &lt;= own[0][i + 1]; fa++) &#123; for (int fc = 0; fc &lt;= own[2][i + 1]; fc++) &#123; if (fa + fc == 0) continue; int _a = a - VAL[i + 1] * fa; int _b = b + VAL[i + 1] * (fa + fc); int _c = c - VAL[i + 1] * fc; f[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fc); &#125; &#125; // b, c -&gt; a for (int fb = 0; fb &lt;= own[1][i + 1]; fb++) &#123; for (int fc = 0; fc &lt;= own[2][i + 1]; fc++) &#123; if (fb + fc == 0) continue; int _a = a + VAL[i + 1] * (fb + fc); int _b = b - VAL[i + 1] * fb; int _c = c - VAL[i + 1] * fc; f[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fb + fc); &#125; &#125; f[i + 1][a][b] = std::min(f[i + 1][a][b], f[i][a][b]); &#125; &#125; &#125; int resA = sum[0] - a + c, resB = sum[1] - b + a, resC = sum[2] - c + b; if (resA &lt; 0 || resB &lt; 0 || resC &lt; 0 || f[6][resA][resB] == INT_MAX) puts(\"impossible\"); else printf(\"%d\\n\", f[6][resA][resB]); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.github.io/tags/DP/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「SHOI2008」汉诺塔 - DP","slug":"bzoj-1019","date":"2017-06-13T06:49:15.000Z","updated":"2017-06-19T03:33:16.000Z","comments":true,"path":"bzoj-1019/","link":"","permalink":"http://sulfur6.github.io/bzoj-1019/","excerpt":"用 A,B,C A, B, C A,B,C 分别表示汉诺塔问题中的三根柱子。 用两个字母描述一个操作，例如 AB 就是把柱子 A A A 最上面圆盘挪动到柱子 B B B 上。 我们为所有的 6 6 6 种操作赋予一个优先级，并且利用以下规则进行游戏： 选择一种操作，这种操作是所有合法操作中优先级最高的。 本次操作需要移动的圆盘不是上一次操作移动的圆盘。 可以证明，上述策略一定能完成汉诺塔游戏。 计算给定操作优先级时将 A A A 柱子上的 n n n 个圆盘全部移动到另一根上所需的操作数。","text":"用 A,B,C A, B, C A,B,C 分别表示汉诺塔问题中的三根柱子。 用两个字母描述一个操作，例如 AB 就是把柱子 A A A 最上面圆盘挪动到柱子 B B B 上。 我们为所有的 6 6 6 种操作赋予一个优先级，并且利用以下规则进行游戏： 选择一种操作，这种操作是所有合法操作中优先级最高的。 本次操作需要移动的圆盘不是上一次操作移动的圆盘。 可以证明，上述策略一定能完成汉诺塔游戏。 计算给定操作优先级时将 A A A 柱子上的 n n n 个圆盘全部移动到另一根上所需的操作数。 题解由于优先级的限制，不能像传统的汉诺塔问题一样解决，考虑DP。 设 f(j,i) f(j, i) f(j,i) 表示将 i i i 号柱子最上面的 j j j 个盘子（不考虑下面的盘子），移动到编号为 g(j,i) g(j, i) g(j,i) 的柱子上所需要的最小移动次数。 显然的，当 j=1 j = 1 j=1 时，g(j,i) g(j, i) g(j,i) 由题目给定的优先级确定。按照 j j j 从小到大划分阶段，则 j&gt;1 j &gt; 1 j&gt;1 时 g(j,i) g(j, i) g(j,i) 的值由前一阶段确定。 转移 f(j,i) f(j, i) f(j,i) 时，考虑 f(j−1,i) f(j - 1, i) f(j−1,i) 和 g(j−1,i) g(j - 1, i) g(j−1,i)。 记 g(j−1,i)=a g(j - 1, i) = a g(j−1,i)=a，则按照传统的汉诺塔问题的思路应该移动到除了柱子 i i i 和柱子 a a a 的另一根柱子，记作 b b b，而且有 b=3−a−i b = 3 - a - i b=3−a−i。 若 g(j−1,a)=b g(j - 1, a) = b g(j−1,a)=b，则我们需要做的只有将柱子 i i i 上的第 j j j 个盘子移动到 b b b 上，然后把柱子 a a a 上的 j−1 j - 1 j−1 个柱子移动到柱子 b b b 上。 此时对于 f(j,i) f(j, i) f(j,i) 有： f(j,i)=f(j−1,i)+1+f(j−1,a) f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) f(j,i)=f(j−1,i)+1+f(j−1,a)而对于 g(j,i) g(j, i) g(j,i) 有： g(j,i)=b g(j, i) = b g(j,i)=b若 g(j−1,a)=i g(j - 1, a) = i g(j−1,a)=i，则此时的最优解决方案是先将第 j j j 个盘子移动到 b b b 上，再将柱子 a a a 上的 j j j 个盘子移动到第 i i i 根柱子上，再将盘子 j j j 移动到柱子 a a a 上，最后将柱子 i i i 上的 j−1 j - 1 j−1 个盘子移动到柱子 a a a 上。 此时对于 f(j,i) f(j, i) f(j,i) 有： f(j,i)=f(j−1,i)+1+f(j−1,a)+1+f(j−1,i) f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) + 1 + f(j - 1, i) f(j,i)=f(j−1,i)+1+f(j−1,a)+1+f(j−1,i)对于 g(j,i) g(j, i) g(j,i) 有： g(j,i)=a g(j, i) = a g(j,i)=a对于这种奇怪的转移可以通过对于只移动一根柱子的特殊情况的思考来理解。 代码#include &lt;cstdio&gt;const int MAX_N = 30;int g[MAX_N + 1][3];long long f[MAX_N + 1][3];int main() &#123; int n; scanf(\"%d\", &amp;n); g[1][0] = g[1][1] = g[1][2] = -1; for (int i = 0; i &lt; 6; i++) &#123; char rule[4]; scanf(\"%s\", rule); int fr = rule[0] - 'A', to = rule[1] - 'A'; if (g[1][fr] == -1) g[1][fr] = to; // Good to own a BRAIN.. &#125; f[1][0] = f[1][1] = f[1][2] = 1; for (int j = 2; j &lt;= n; j++) &#123; for (int i = 0; i &lt; 3; i++) &#123; const int a = g[j - 1][i], b = 3 - a - i; if (g[j - 1][a] == b) &#123; f[j][i] = f[j - 1][i] + 1 + f[j - 1][a]; g[j][i] = b; &#125; else &#123; f[j][i] = f[j - 1][i] + 1 + f[j - 1][a] + 1 + f[j - 1][i]; g[j][i] = a; &#125; &#125; &#125; printf(\"%lld\\n\", f[n][0]); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.github.io/tags/DP/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「SHOI2008」堵塞的交通 - 线段树","slug":"bzoj-1018","date":"2017-06-11T00:24:44.000Z","updated":"2017-06-12T03:45:42.000Z","comments":true,"path":"bzoj-1018/","link":"","permalink":"http://sulfur6.github.io/bzoj-1018/","excerpt":"在一个有 2C 2C 2C 个点，3C−2 3C - 2 3C−2 条边的 2 2 2 行 C C C 列的网格图中，相邻两个节点有连边，给定以下三种操作。 Open r1 c1 r2 c2 连接节点 (r1, c1), (r2, c2) 的边连通。 Close r1 c1 r2 c2 连接节点 (r1, c1), (r2, c2) 的边断开。 Ask r1 c1 r2 c2 查询节点 (r1, c1), (r2, c2) 之间的连通性。 开始时每条边都是断开的状态。","text":"在一个有 2C 2C 2C 个点，3C−2 3C - 2 3C−2 条边的 2 2 2 行 C C C 列的网格图中，相邻两个节点有连边，给定以下三种操作。 Open r1 c1 r2 c2 连接节点 (r1, c1), (r2, c2) 的边连通。 Close r1 c1 r2 c2 连接节点 (r1, c1), (r2, c2) 的边断开。 Ask r1 c1 r2 c2 查询节点 (r1, c1), (r2, c2) 之间的连通性。 开始时每条边都是断开的状态。 题解为什么这种特殊的要死的图我第一时间想到的是 LCT，怕不是我失了智。。 但是看了题解的线段树做法，我感觉我整个人都没有智商了。。怕不是我变成了大傻子。。 原图中有上下两行，这里用 (i,0) (i, 0) (i,0) 表示第 i i i 列上面的城市，用 (i,1) (i, 1) (i,1) 表示第 i i i 列下面的城市。 对于线段树中的一个代表区间 [l,r] [l, r] [l,r] 的节点，其中维护的是 (l,0),(l,1) (l, 0), (l, 1) (l,0),(l,1) 分别与 (r,0),(r,1) (r, 0), (r, 1) (r,0),(r,1) 的连通性。 对于某个区间 [l=i,r=i] [l = i, r = i] [l=i,r=i]，我们认为这个区间中的 (l,0),(r,0) (l, 0), (r, 0) (l,0),(r,0) 是连通的，同样的 (l,1),(r,1) (l, 1), (r, 1) (l,1),(r,1) 也是连通的。 若该位置上下连通，则认为 (l,0),(r,1) (l, 0), (r, 1) (l,0),(r,1) 连通，同时 (r,0),(l,1) (r, 0), (l, 1) (r,0),(l,1) 连通。 合并两个区间 [l,m],[m+1,r] [l, m], [m + 1, r] [l,m],[m+1,r]，枚举 m↔m+1 m \\leftrightarrow m + 1 m↔m+1 经过的是上面的还是下面的路径。 回答询问时，假设 c1 c1 c1 在 c2 c2 c2 左边，二分 c1 c1 c1 能够达到的最左位置以及 c2 c2 c2 能够达到的最右位置，枚举回答。假如 (r1, c1) 不和 (r2, c2) 直接连通，那么这样做可以包含到 (r1, c1) 先向左走以及 (r2, c2) 先向右走的情况。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int MAX_C = 100000;int n;bool right[MAX_C][2], uad[MAX_C + 1];struct Connectivity &#123; bool a[2][2]; Connectivity(bool init) &#123; a[0][0] = a[0][1] = a[1][0] = a[1][1] = init; &#125; bool &amp;operator()(const int i, const int j) &#123; return a[i][j]; &#125; bool operator()(const int i, const int j) const &#123; return a[i][j]; &#125; operator bool() const &#123; return a[0][0] || a[0][1] || a[1][0] || a[1][1]; &#125;&#125;;inline Connectivity merge(Connectivity a, Connectivity b, int mid) &#123; Connectivity res(false); for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 2; j++) &#123; for (int k = 0; k &lt; 2; k++) &#123; res(i, j) |= a(i, k) &amp;&amp; right[mid][k] &amp;&amp; b(k, j); &#125; &#125; &#125; return res;&#125;struct Segt &#123; int l, r, mid; Segt *lc, *rc; // con(0, 0) : (l, 0) &lt;-&gt; (r, 0) // con(0, 1) : (l, 0) &lt;-&gt; (r, 1) // con(1, 0) : (l, 1) &lt;-&gt; (r, 0) // con(1, 1) : (l, 1) &lt;-&gt; (r, 1) Connectivity con; Segt(int l, int r, Segt *lc, Segt *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), con(l == r) &#123;&#125; void modify(int l, int r) &#123; if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (this-&gt;l == this-&gt;r) &#123; con(0, 0) = con(1, 1) = true; con(0, 1) = con(1, 0) = uad[mid]; return; &#125; else lc-&gt;modify(l, r), rc-&gt;modify(l, r); con = merge(lc-&gt;con, rc-&gt;con, mid); &#125; Connectivity query(int l, int r) &#123; if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return this-&gt;con; else if (r &lt;= mid) return lc-&gt;query(l, r); else if (l &gt; mid) return rc-&gt;query(l, r); else return merge(lc-&gt;query(l, r), rc-&gt;query(l, r), mid); &#125; static Segt *build(int l, int r) &#123; if (l &gt; r) return NULL; if (l == r) return new Segt(l, r, NULL, NULL); else &#123; int mid = l + (r - l) / 2; return new Segt(l, r, build(l, mid), build(mid + 1, r)); &#125; &#125;&#125; *segt;inline void modify(int r1, int c1, int r2, int c2, bool state) &#123; if (r1 == r2) &#123; right[std::min(c1, c2)][r1] = state; &#125; else if (c1 == c2) &#123; uad[c1] = state; &#125; segt-&gt;modify(std::min(c1, c2), std::max(c1, c2));&#125;inline bool query(int r1, int c1, int r2, int c2) &#123; int l, r; l = 1, r = c1; while (l &lt; r) &#123; int mid = l + (r - l) / 2; Connectivity res = segt-&gt;query(mid, c1); if (res(0, r1) || res(1, r1)) r = mid; else l = mid + 1; &#125; const int lpos = l; Connectivity lcon = segt-&gt;query(lpos, c1); l = c2, r = n; while (l &lt; r) &#123; int mid = l + (r - l) / 2 + 1; Connectivity res = segt-&gt;query(c2, mid); if (res(r2, 0) || res(r2, 1)) l = mid; else r = mid - 1; &#125; const int rpos = l; Connectivity rcon = segt-&gt;query(c2, rpos); Connectivity con = segt-&gt;query(lpos, rpos); for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 2; j++) &#123; if (lcon(i, r1) &amp;&amp; rcon(r2, j) &amp;&amp; con(i, j)) return true; &#125; &#125; return false;&#125;int main() &#123; scanf(\"%d\", &amp;n); segt = Segt::build(1, n); char cmd[5]; while (scanf(\"%s\", cmd) != EOF) &#123; if (cmd[0] == 'E') break; else &#123; int r1, c1, r2, c2; scanf(\"%d %d %d %d\", &amp;r1, &amp;c1, &amp;r2, &amp;c2); r1--, r2--; if (cmd[0] == 'O') modify(r1, c1, r2, c2, true); else if (cmd[0] == 'C') modify(r1, c1, r2, c2, false); else &#123; if (c1 &gt; c2) std::swap(r1, r2), std::swap(c1, c2); puts(query(r1, c1, r2, c2) ? \"Y\" : \"N\"); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://sulfur6.github.io/tags/线段树/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「JSOI2008」魔兽地图 - 树形DP，多重背包","slug":"bzoj-1017","date":"2017-06-03T11:30:33.000Z","updated":"2017-06-03T12:29:46.000Z","comments":true,"path":"bzoj-1017/","link":"","permalink":"http://sulfur6.github.io/bzoj-1017/","excerpt":"给定 n n n 件物品，m m m 个金币，每个物品有自己的价值。低级物品可以直接购买，高级物品需要若干件较低级的物品来合成，并且具有合成的数量限制，求能够获得的最大价值。","text":"给定 n n n 件物品，m m m 个金币，每个物品有自己的价值。低级物品可以直接购买，高级物品需要若干件较低级的物品来合成，并且具有合成的数量限制，求能够获得的最大价值。 题解很不错的树形DP，反正我一开始是没想出来。 设 pi,ci,wi p_i, c_i, w_i p​i​​,c​i​​,w​i​​ 分别表示物品 i i i 的价值，合成数量限制和价格。 高级装备的 w,c w, c w,c 用子树的信息合并一下就好。 设 f(i,j,k) f(i, j, k) f(i,j,k) 为合成 j j j 件物品 i i i 贡献给父节点，花费了 k k k 个金币所能获得的最大价值。记 soni son_i son​i​​ 为节点 i i i 的子节点集合。 枚举合成 a a a 件 i i i 物品，余下的钱用来购买一些子树中的物品来获得价值。 对于枚举到的合成数目 a a a，设 g(t,j) g(t, j) g(t,j) 表示在某个节点的前 t t t 棵子树花费 j j j 个金币所能获得的最大收益，qi(k) q_i(k) q​i​​(k) 表示合成物品 i i i 所需物品 k k k 的数量。 g(t,j)=maxk=0j{g(t,j),g(t−1,j−k)+f(soni(t),a×qi(soni(t)),j)} g(t, j) = \\max\\limits_{k = 0}^{j}\\{g(t, j), g(t - 1, j - k) + f(son_i(t), a \\times q_i(son_i(t)), j)\\} g(t,j)=​k=0​max​j​​{g(t,j),g(t−1,j−k)+f(son​i​​(t),a×q​i​​(son​i​​(t)),j)}从合成的 a a a 件中挑选 j j j 件贡献给父节点，由此转移 f(i,j,k) f(i, j, k) f(i,j,k)。 f(i,j,k)=max{g(∣soni∣,k)+pi×(a−j)} f(i, j, k) = \\max\\{ g(|son_i|, k) + p_i \\times (a - j) \\} f(i,j,k)=max{g(∣son​i​​∣,k)+p​i​​×(a−j)}这道题最巧妙的决策点在确定合成一件物品时用来获得价值的数目和拿来合成更高级物品的数目。 然后，如果没有任何高级装备的话，需要另写一个多重背包来特判。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;const int MAX_N = 51;const int MAX_M = 2000;const int MAX_K = 100;int n, m;struct Node;struct Edge;struct Node &#123; Edge *e; int cnt, cost, p, d; int f[MAX_K + 1][MAX_M + 1]; bool basic;&#125; N[MAX_N + 1];struct Edge &#123; Node *fr, *to; Edge *ne; int w; Edge(Node *fr, Node *to, int w) : fr(fr), to(to), ne(fr-&gt;e), w(w) &#123;&#125;&#125;;inline void addEdge(int fr, int to, int w) &#123; N[to].d++; N[fr].e = new Edge(&amp;N[fr], &amp;N[to], w);&#125;int g[MAX_N + 1][MAX_M + 1], h[MAX_N + 1][MAX_M + 1];inline void dp(Node *v) &#123; int (&amp;f)[MAX_K + 1][MAX_M + 1] = v-&gt;f; if (v-&gt;basic) &#123; v-&gt;cnt = std::min(v-&gt;cnt, m / v-&gt;cost); for (int i = 0; i &lt;= v-&gt;cnt; i++) for (int j = i; j &lt;= v-&gt;cnt; j++) f[i][j * v-&gt;cost] = (j - i) * v-&gt;p; return; &#125; else &#123; v-&gt;cnt = INT_MAX; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; dp(e-&gt;to); v-&gt;cnt = std::min(v-&gt;cnt, e-&gt;to-&gt;cnt / e-&gt;w); v-&gt;cost += e-&gt;w * e-&gt;to-&gt;cost; &#125; v-&gt;cnt = std::min(v-&gt;cnt, m / v-&gt;cost); memset(g, -0x3f3f3f3f, sizeof(g)); g[0][0] = 0; for (int a = v-&gt;cnt; a &gt;= 0; a--) &#123; int id = 0; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; id++; for (int j = 0; j &lt;= m; j++) for (int k = 0; k &lt;= j; k++) g[id][j] = std::max(g[id][j], g[id - 1][j - k] + e-&gt;to-&gt;f[e-&gt;w * a][k]); &#125; for (int i = 0; i &lt;= a; i++) for (int k = 0; k &lt;= m; k++) f[i][k] = std::max(f[i][k], g[id][k] + v-&gt;p * (a - i)); &#125; &#125;&#125;inline void solveTree() &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= MAX_K; j++) for (int k = 0; k &lt;= MAX_M; k++) N[i].f[j][k] = -100000000; &#125; int tot = 0; for (int x = 1; x &lt;= n; x++) &#123; Node *v = &amp;N[x]; if (!v-&gt;d) &#123; dp(v); tot++; for (int i = 0; i &lt;= m; i++) for (int j = 0; j &lt;= i; j++) for (int k = 0; k &lt;= v-&gt;cnt; k++) h[tot][i] = std::max(h[tot][i], h[tot - 1][j] + v-&gt;f[k][i - j]); &#125; &#125; int ans = INT_MIN; for (int j = 0; j &lt;= m; j++) ans = std::max(ans, h[tot][j]); printf(\"%d\\n\", ans);&#125;template&lt;class T&gt;struct MonoQueue &#123; std::deque&lt;T&gt; data, aux; void push(const T &amp;x) &#123; data.push_back(x); while (!aux.empty() &amp;&amp; aux.back() &lt; x) aux.pop_back(); aux.push_back(x); &#125; void pop() &#123; if (data.front() == aux.front()) aux.pop_front(); data.pop_front(); &#125; int size() &#123; return data.size(); &#125; T max() &#123; return aux.front(); &#125;&#125;;int f[MAX_M + 1];inline void multiplePack(int cost, int w, int cnt) &#123; cnt = std::min(cnt, m / cost); for (int d = 0; d &lt; cost; d++) &#123; MonoQueue&lt;int&gt; q; for (int k = 0; k * cost + d &lt;= m; k++) &#123; q.push(f[k * cost + d] - k * w); if (q.size() == cnt + 2) q.pop(); f[k * cost + d] = q.max() + k * w; &#125; &#125;&#125;inline void solveMultiplePack() &#123; for (int i = 1; i &lt;= n; i++) &#123; multiplePack(N[i].cost, N[i].p, N[i].cnt); &#125; int ans = INT_MIN; for (int i = 0; i &lt;= m; i++) &#123; ans = std::max(ans, f[i]); &#125; printf(\"%d\\n\", ans);&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;N[i].p); char ch[5]; scanf(\"%s\", ch); if (ch[0] == 'B') &#123; scanf(\"%d %d\", &amp;N[i].cost, &amp;N[i].cnt); N[i].basic = true; &#125; else &#123; int c; scanf(\"%d\", &amp;c); while (c--) &#123; int v, w; scanf(\"%d %d\", &amp;v, &amp;w); addEdge(i, v, w); &#125; &#125; &#125; bool flag = false; for (int i = 1; i &lt;= n; i++) if (N[i].d) flag = true; if (flag) solveTree(); else solveMultiplePack(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"单调队列","slug":"单调队列","permalink":"http://sulfur6.github.io/tags/单调队列/"},{"name":"树形DP","slug":"树形DP","permalink":"http://sulfur6.github.io/tags/树形DP/"},{"name":"多重背包","slug":"多重背包","permalink":"http://sulfur6.github.io/tags/多重背包/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「JSOI2008」最小生成树计数 - 状压，kruskal","slug":"bzoj-1016","date":"2017-05-29T07:01:31.000Z","updated":"2017-06-04T09:31:42.000Z","comments":true,"path":"bzoj-1016/","link":"","permalink":"http://sulfur6.github.io/bzoj-1016/","excerpt":"给定一个无向图，求其最小生成树个数。","text":"给定一个无向图，求其最小生成树个数。 题解尝试证明一个奇奇怪怪的定理：一个无向图的所有最小生成树中某种权值的边的数目相同。 按照 kruskal 算法的流程，我们会在对边排序之后尝试从小到大尝试加入某种权值的所有边，我们设权值最小的边的权值为 w w w，原图中权值为 w w w 的边有 c c c 条，出现在最小生成树中的权值为 w w w 的边有 a a a 条。那么任何一个加入 a a a 条边权为 w w w 的边而不使图成环的方案都可以使原图到达相同的连通性。 假设加入能够加入的 a a a 条边以后得到若干个连通块，记其中一个连通块为 G G G，其余连通块同理，那么去掉 G G G 中一条边，得到两个连通块 A,B A, B A,B，现在尝试添加一条不同于原来在 G G G 中任意一条边的边，那么此时这条边 (u,v) (u, v) (u,v) 有两种情况： u∈A,v∈B u \\in A, v \\in B u∈A,v∈B，那么添加这条边后仍然得到连通块 G G G。 (u∈A,v∈A)∧(u∈B,v∈B) (u \\in A, v \\in A) \\wedge (u \\in B, v \\in B) (u∈A,v∈A)∧(u∈B,v∈B) 那么添加这条边势必成环，此时不允许添加这条边。 在添加第二小的边的时候，将添加最小的边之后得到的若干个连通块缩点，这时已经没有可以加进最小生成树的权值最小的边，所以权值最第二小的边变成新的权值最小的边，此时尝试加边之后得到的图的连通性的性质同上述情况。 以添加进最小生成树的边的权值划分阶段，那么每个阶段中添加的边的数量是固定的，这也就意味着某种权值的边的数目是完全相同的。 以上内容借鉴如下博客。。 BZOJ1016 [JSOI2008]最小生成树计数 贴上 sengxian 更加严谨的证明： BZOJ 1016 - [JSOI2008]最小生成树计数 得到了这个结论以后，就可以枚举选择每种边权的边了，如果在节点间连上枚举到的边不成环，那么这就是一种可行的最小生成树方案。利用状压枚举，统计每种边权的方案数，最后乘法原理即可。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;const int MAX_N = 100;const int MAX_M = 1000;const int MOD = 31011;struct Edge &#123; int u, v, w; bool vis; bool operator&lt;(const Edge &amp;other) const &#123; return w &lt; other.w; &#125;&#125; E[MAX_M + 1];struct UFS &#123; int fa[MAX_N + 1]; void init(int n) &#123; for (int i = 0; i &lt;= n; i++) fa[i] = i; &#125; int find(int x) &#123; return x == fa[x] ? fa[x] : fa[x] = find(fa[x]); &#125; void merge(int x, int y) &#123; int f1 = find(x), f2 = find(y); fa[f1] = f2; &#125; bool check(int x, int y) &#123; return find(x) == find(y); &#125;&#125; ufs;struct EdgeGroup &#123; int cnt; std::vector&lt;Edge&gt; e;&#125;;int n, m;bool g[MAX_N + 1][MAX_N + 1];std::map&lt;int, EdgeGroup&gt; groups;inline bool kruskal() &#123; std::sort(E, E + m); ufs.init(n); int cnt = 0; for (int i = 0; i &lt; m; i++) &#123; if (!ufs.check(E[i].u, E[i].v)) &#123; E[i].vis = true; ufs.merge(E[i].u, E[i].v); groups[E[i].w].cnt++; cnt++; &#125; groups[E[i].w].e.push_back(E[i]); &#125; return cnt == n - 1;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; scanf(\"%d %d %d\", &amp;E[i].u, &amp;E[i].v, &amp;E[i].w); &#125; if (!kruskal()) &#123; puts(\"0\"); &#125; else &#123; long long ans = 1; for (int i = 0; i &lt; m; i++) if (E[i].vis) g[E[i].u][E[i].v] = g[E[i].v][E[i].u] = true; for (std::map&lt;int, EdgeGroup&gt;::const_iterator it = groups.begin(); it != groups.end(); it++) &#123; if (it-&gt;second.cnt == 0) continue; int t = 0; for (unsigned int s = 1; s &lt; (1 &lt;&lt; it-&gt;second.e.size()); s++) &#123; int tot = 0; for (unsigned int i = 0; i &lt; it-&gt;second.e.size(); i++) if (s &amp; (1 &lt;&lt; i)) tot++; if (tot != it-&gt;second.cnt) continue; for (std::vector&lt;Edge&gt;::const_iterator e = it-&gt;second.e.begin(); e != it-&gt;second.e.end(); e++) &#123; g[e-&gt;u][e-&gt;v] = g[e-&gt;v][e-&gt;u] = false; &#125; for (unsigned int i = 0; i &lt; it-&gt;second.e.size(); i++) &#123; if (s &amp; (1 &lt;&lt; i)) g[it-&gt;second.e[i].u][it-&gt;second.e[i].v] = g[it-&gt;second.e[i].v][it-&gt;second.e[i].u] = true; &#125; ufs.init(n); for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; if (g[i][j]) &#123; if (ufs.check(i, j)) goto Continue; ufs.merge(i, j); &#125; &#125; &#125; t++;Continue:; &#125;// printf(\"t = %d\\n\", t); (ans *= t) %= MOD; for (std::vector&lt;Edge&gt;::const_iterator e = it-&gt;second.e.begin(); e != it-&gt;second.e.end(); e++) &#123; g[e-&gt;u][e-&gt;v] = g[e-&gt;v][e-&gt;u] = e-&gt;vis; &#125; &#125; printf(\"%lld\\n\", ans); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://sulfur6.github.io/tags/搜索/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「Codeforces Round 416 (Div. 2)」 C - DP","slug":"cf811c","date":"2017-05-28T03:05:48.000Z","updated":"2017-06-02T13:41:54.000Z","comments":true,"path":"cf811c/","link":"","permalink":"http://sulfur6.github.io/cf811c/","excerpt":"给定一个序列，每个位置上有一种颜色，要求把这个序列分成可以不连续的若干段，所有颜色相同的要么全部不选要么全部分到一段中，最终选取出的每一段的价值等于段中不同颜色编号的异或和，求最大价值。","text":"给定一个序列，每个位置上有一种颜色，要求把这个序列分成可以不连续的若干段，所有颜色相同的要么全部不选要么全部分到一段中，最终选取出的每一段的价值等于段中不同颜色编号的异或和，求最大价值。 题解一开始我想处理区间之间的嵌套关系和交集关系，然后根据最终区间的嵌套关系来做树形DP，但是处理着处理着我发现区间的嵌套盒交集有一万种关系。 绝望的我选择去翻AC代码，发现了一种新奇的DP思路。 记原序列为 a a a，设 f(i) f(i) f(i) 为处理到前 i i i 位的最大价值。 f(i) f(i) f(i) 可以从两种方式转移来，一种是 f(i)=f(i−1) f(i) = f(i - 1) f(i)=f(i−1)，表示 ai a_i a​i​​ 所在的段目前不可选，或不选 ai a_i a​i​​ 颜色所在的段，另一种是考虑合并后的 ai a_i a​i​​ 所在的区间，记其左端点为 j j j，有 。 区间的合并可以在转移 f(i) f(i) f(i) 时，从 i i i 到 1 1 1 枚举 j j j 的过程中动态转移。注意一种颜色只需要被异或一次。 代码#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAX_N = 5000;int a[MAX_N + 1], l[MAX_N + 1], r[MAX_N + 1], dp[MAX_N + 1], vis[MAX_N + 1];int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt;= MAX_N; i++) &#123; l[i] = n + 1; r[i] = -1; &#125; for (int i = 1; i &lt;= n; i++) &#123; int x; scanf(\"%d\", &amp;x); a[i] = x; l[x] = std::min(l[x], i); r[x] = std::max(r[x], i); &#125; dp[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; int sum = 0, lb = n; dp[i] = dp[i - 1]; for (int j = i; j &gt;= 1; j--) &#123; lb = std::min(lb, j); int x = a[j]; if (r[x] &gt; i) break; lb = std::min(lb, l[x]); if (vis[x] != i) &#123; vis[x] = i; sum ^= x; &#125; if (lb == j) &#123; dp[i] = std::max(dp[i], dp[j - 1] + sum); &#125; &#125; &#125; printf(\"%d\\n\", dp[n]); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.github.io/tags/DP/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「JSOI2008」火星人Prefix - Splay，Hash","slug":"bzoj1014","date":"2017-05-28T02:47:01.000Z","updated":"2017-06-02T13:40:46.000Z","comments":true,"path":"bzoj1014/","link":"","permalink":"http://sulfur6.github.io/bzoj1014/","excerpt":"给定一个字符串，要求支持修改串中某个字符，在指定位置添加字符，以及求指定两个后缀的 LCP LCP LCP 长度。","text":"给定一个字符串，要求支持修改串中某个字符，在指定位置添加字符，以及求指定两个后缀的 LCP LCP LCP 长度。 题解提到LCP当然会想到后缀家族，不过我才疏学浅，并不知道后缀家族怎么支持修改和插入。 所以，Hash 大法好！ 话说回来当时在长乐的时候写字符串哈希的暴力，可能是我姿势不太对？模数一直取不对。。这道题没有卡自然溢出，感觉还是很良心的。 好啦言归正传，对这个字符串建立一棵Splay，保证其中序遍历结果为原字符串。这样每一个Splay的节点都可以代表一个字串。如果要获得某个指定字串的哈希值，用Splay提区间就可以了。。 合并左右子树信息的时候，不知诸君喜欢以左为高位还是右为高位啊。。这里就不引战啦哈哈。 提示一个细节，这里为了Splay操作方便引入的左右端点节点会对某些节点的哈希值产生影响，但是由于Splay提取区间以后提取出来的区间对应的子树不会包括左右端点节点，而且这道题只需要用到提取区间，所以这样写没有错误。如果要让它的哈希值是正确的特判一下就好啦。 还有讲实话哈希那一套理论我真的是不怎么懂啊 T^T 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAX_N = 100000;const int MAX_M = 150000;const unsigned long long BASE = 233;unsigned long long base[MAX_N + 1];struct Splay &#123; struct Node &#123; Node *fa, *c[2], **root; int size; char val; unsigned long long hash; Node(Node *fa, Node **root, char val) : fa(fa), root(root), size(1), val(val), hash(val) &#123; c[0] = c[1] = NULL; &#125; void maintain() &#123; size = (c[0] ? c[0]-&gt;size : 0) + (c[1] ? c[1]-&gt;size : 0) + 1; hash = val; if (c[1]) hash += c[1]-&gt;hash * BASE; if (c[0]) hash = hash * base[c[0]-&gt;size] + c[0]-&gt;hash; &#125; int lsize() &#123; return c[0] ? c[0]-&gt;size : 0; &#125; int relation() &#123; return this == fa-&gt;c[1]; &#125; void rotate() &#123; Node *old = fa; int x = relation(); fa = old-&gt;fa; if (old-&gt;fa) old-&gt;fa-&gt;c[old-&gt;relation()] = this; old-&gt;c[x] = c[x ^ 1]; if (c[x ^ 1]) c[x ^ 1]-&gt;fa = old; c[x ^ 1] = old; old-&gt;fa = this; old-&gt;maintain(), maintain(); if (!fa) *root = this; &#125; Node *splay(Node *target = NULL) &#123; while (fa != target) &#123; if (fa-&gt;fa == target) rotate(); else if (fa-&gt;relation() == relation()) fa-&gt;rotate(), rotate(); else rotate(), rotate(); &#125; return this; &#125; &#125; *root; Splay() : root(NULL) &#123;&#125; Node *build(const char *begin, const char *end, Node *par) &#123; if (begin &gt; end) return NULL; else if (begin == end) return new Node(par, &amp;root, *begin); else &#123; const char *mid = begin + (end - begin) / 2; Node *v = new Node(par, &amp;root, *mid); v-&gt;c[0] = build(begin, mid - 1, v); v-&gt;c[1] = build(mid + 1, end, v); v-&gt;maintain(); return v; &#125; &#125; void buildBound(int x) &#123; Node *v = root; while (v-&gt;c[x]) v = v-&gt;c[x]; v-&gt;c[x] = new Node(v, &amp;root, 0); Node *u = v; do &#123; u-&gt;maintain(); u = u-&gt;fa; &#125; while (u); v-&gt;c[x]-&gt;splay(); &#125; void build(const char *begin, const char *end) &#123; root = build(begin, end, NULL); buildBound(0); buildBound(1); &#125; Node *select(int k) &#123; int x = k + 1; Node *v = root; while (x != v-&gt;lsize() + 1) &#123; if (x &lt;= v-&gt;lsize()) v = v-&gt;c[0]; else x -= v-&gt;lsize() + 1, v = v-&gt;c[1]; &#125; return v-&gt;splay(); &#125; Node *select(int l, int r) &#123; Node *u = select(l - 1), *v = select(r + 1); u-&gt;splay(); v-&gt;splay(u); return v-&gt;c[0]; &#125; Node *insert(int pos, char val) &#123; Node *u = select(pos), *v = select(pos + 1); u-&gt;splay(); v-&gt;splay(u); v-&gt;c[0] = new Node(v, &amp;root, val); Node *q = v-&gt;c[0]; do &#123; q-&gt;maintain(); q = q-&gt;fa; &#125; while (q); return v-&gt;c[0]-&gt;splay(); &#125; void modify(int pos, char val) &#123; Node *v = select(pos); v-&gt;val = val; v-&gt;maintain(); &#125; unsigned long long query(int l, int r) &#123; return select(l, r)-&gt;hash; &#125; int size() &#123; return root-&gt;size - 2; &#125;&#125; splay;inline int lcp(int a, int b) &#123; int l = 0, r = std::min(splay.size() - a + 1, splay.size() - b + 1); while (l != r) &#123; int mid = l + (r - l) / 2 + 1; if (splay.query(a, a + mid - 1) == splay.query(b, b + mid - 1)) l = mid; else r = mid - 1; &#125; return l;&#125;char s[MAX_N + 1];int main() &#123; base[0] = 1; for (int i = 1; i &lt;= MAX_N; i++) base[i] = base[i - 1] * BASE; scanf(\"%s\", s); int n = strlen(s); splay.build(s, s + n - 1); int m; scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; char cmd[2]; scanf(\"%s\", cmd); if (cmd[0] == 'Q') &#123; int a, b; scanf(\"%d %d\", &amp;a, &amp;b); printf(\"%d\\n\", lcp(a, b)); &#125; else if (cmd[0] == 'R') &#123; int pos; char val[2]; scanf(\"%d %s\", &amp;pos, val); splay.modify(pos, val[0]); &#125; else if (cmd[0] == 'I') &#123; int pos; char val[2]; scanf(\"%d %s\", &amp;pos, val); splay.insert(pos, val[0]); &#125; &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"Splay","slug":"Splay","permalink":"http://sulfur6.github.io/tags/Splay/"},{"name":"Hash","slug":"Hash","permalink":"http://sulfur6.github.io/tags/Hash/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「HNOI2008」GT考试 - DP，矩阵乘法，KMP","slug":"bzoj1009","date":"2017-05-27T13:20:05.000Z","updated":"2017-06-02T13:39:54.000Z","comments":true,"path":"bzoj1009/","link":"","permalink":"http://sulfur6.github.io/bzoj1009/","excerpt":"阿申准备报名参加GT考试，准考证号为 N N N 位数 ，他不希望准考证号上出现不吉利的数字。他的不吉利数字 有 M M M 位，不出现是指 中没有恰好一段等于 ， 特别地 A1 A_1 A​1​​ 和 x1 x_1 x​1​​ 可以为 0 0 0","text":"阿申准备报名参加GT考试，准考证号为 N N N 位数 ，他不希望准考证号上出现不吉利的数字。他的不吉利数字 有 M M M 位，不出现是指 中没有恰好一段等于 ， 特别地 A1 A_1 A​1​​ 和 x1 x_1 x​1​​ 可以为 0 0 0 题解首先这题数据范围非常可爱， 1≤N≤109,1≤m≤20 1 \\leq N \\leq 10 ^ 9, 1 \\leq m \\leq 20 1≤N≤10​9​​,1≤m≤20，这个数据范围会让人不自觉的想起矩乘。 设 f(i,j) f(i, j) f(i,j) 表示已经确定了准考证号的前 i i i 位，在这 i i i 位的末尾出现了不吉利数字的 j j j 个。 枚举 0∼9 0 \\sim 9 0∼9 转移，考虑在第 i+1 i + 1 i+1 位上添上某一个数字，可能转移到 。 用语言来描述的话，就是新添加的这个数字可能会让最后的不吉利数字延长，或者让末位的某几位变为原来出现的连续不吉利数字的前缀。 其实这个东西随便暴力啦，毕竟 m m m 只有 20 20 20。。 剩下的事情就是构造转移矩阵了，由于每次转移只和 j j j 有关，所以可以轻松预处理转移矩阵。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAX_N = 1e9;const int MAX_M = 20;struct Matrix &#123; int a[MAX_M + 5][MAX_M + 5]; int n, m; Matrix(int n, int m, bool unit = false) &#123; this-&gt;n = n; this-&gt;m = m; memset(a, 0, sizeof(a)); if (unit) &#123; for (int i = 0; i &lt;= n; i++) a[i][i] = 1; &#125; &#125;&#125;;int n, m, mod;char s[MAX_M + 1];int next[MAX_M + 1];Matrix operator*(const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix res(a.n, b.m, false); for (int i = 0; i &lt; a.n; i++) &#123; for (int j = 0; j &lt; b.m; j++) &#123; for (int k = 0; k &lt; a.m; k++) &#123; (res.a[i][j] += a.a[i][k] * b.a[k][j]) %= mod; &#125; &#125; &#125; return res;&#125;Matrix pow(Matrix a, int n) &#123; Matrix res(a.n, a.n, true); for (; n; n &gt;&gt;= 1, a = a * a) if (n &amp; 1) res = res * a; return res;&#125;inline void getNext() &#123; int j = 0; for (int i = 2; i &lt;= m; i++) &#123; while (j &gt; 0 &amp;&amp; s[j + 1] != s[i]) j = next[j]; if (s[j + 1] == s[i]) j++; next[i] = j; &#125;&#125;int main() &#123; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;mod); scanf(\"%s\", s + 1); getNext(); Matrix shift(m, m, false); Matrix origin(m, 1, false); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt;= 9; j++) &#123; int k = i; while (k &gt; 0 &amp;&amp; s[k + 1] - '0' != j) k = next[k]; if (s[k + 1] - '0' == j) k++; (shift.a[k][i] += 1) %= mod; &#125; &#125; origin.a[0][0] = 1; Matrix res = pow(shift, n) * origin; int ans = 0; for (int i = 0; i &lt; m; i++) (ans += res.a[i][0]) %= mod; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.github.io/tags/DP/"},{"name":"KMP","slug":"KMP","permalink":"http://sulfur6.github.io/tags/KMP/"},{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"http://sulfur6.github.io/tags/矩阵乘法/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"英雄难度「卡拉赞之夜」通关记","slug":"HearthStone-Karazhan","date":"2017-05-27T07:03:30.000Z","updated":"2017-05-27T08:47:18.000Z","comments":true,"path":"HearthStone-Karazhan/","link":"","permalink":"http://sulfur6.github.io/HearthStone-Karazhan/","excerpt":"团长通关卡拉赞辣！","text":"团长通关卡拉赞辣！ 宴会厅镀银魔像&amp;魔镜 第一关镀银魔像，起手要找AOE，保证二费的时候能够清掉四个盘子，这里推荐前期AOE用复仇打击（如果带的话），因为对面抢血飞快，等到养奴隶主的时候如果复仇打击黄了就GG了。 起手最好有小斧子，手里有解有过牌就很舒服。 尽量能够尽早上奴隶主，奴隶主上去以后镀银魔像不怎么会主动来解，生一场奴隶主跟他耗就是。不过暴乱狂现在已经不能斩杀了，所以他对我来说是一个极高攻击力的嘲讽，哈哈。 第二关能用奴隶战的原因主要是BOSS复制出来的随从全部是 1/1 1/1 1/1，这套奴隶战一血的AOE能够很好的解决那些复制的小杂毛。 魔镜手里还有不少法术的，他召出来的随从一般都是带法强的。BOSS的奥秘我记得有法反镜像和复制，复制不怕，复制进去的东西，像科学家哀绿和狗头一般我们都解的掉，注意不要复制到什么大法师就好了。我记得BOSS还有个安东尼达斯，要留解牌。镜像的话，这套卡组里面的随从好像没有什么复制到就崩盘的。。不过能试还是尽量试一下，毕竟对面场上多个暴乱狂你也不舒服。最讨厌的应该是法反，可能也和我过牌量不足有关，手里没有合适的能够破法反的法术，有好几次AOE或者斩杀这样的关键法术被反掉导致我重开。。 这里要做一个补充说明，这套卡组并不是当时我用来通关的卡组，当时的卡组和现在的卡组的区别在于两张战斗怒火被我换成了一张凶暴猿猴一张腐肉食尸鬼，因为因为缺少过牌，所以我有几个回合只能靠右手第一张。。 国际象棋象棋应该是我打的时间最长的一关，一开始看攻略，想不清楚就瞎打，卡关卡了几个小时。。那天真的是打吐了。说说我的体会吧。 其实这关并不是很难，找一个比较好的起手，想清楚一点打得贪一点肯定能赢。 我是用的网上说的那种「一费不下子，二费下一个，三费接城堡」的套路，然后四费下骑士，配合城堡吃掉主教，后面的就以清掉黑棋的场然后等皇后来为主。核心思想在于皇后在场的时候尽量多的让皇后抢血，因为后面你没有子了，而对面还有，还可以作弊。打不到脸的时候就输了。想的细一点，一回合想两回合的东西，别瞎打，就能过。 歌剧院歌剧院，确实是非常戏剧性的一层。。 朱丽叶 这关其实我利用了一个AI上的缺陷，就是在朱丽叶场功比你高时一般不会主动解你的随从，所以两只复活的铠甲帮我把对面的几十点场功降到七点，带烈焰喷涌其实是因为我玩的比较晚没有奥冲，我们的任务就是要解决掉罗密欧这只两血随从。。 大灰狼 这一关赢得惊心动魄，我一开始就把三个慈祥的外婆破了，如果不是伊瑟拉给了我张苏醒那一局就打不过去了。总之这一关的BOSS的特点就是只有你手牌中的随从才是 1/1/1 1/1/1 1/1/1，所有召唤出的东西，或者是从牌库中直接召唤的随从（比如亚煞极拉出来），都是原身材，所以我才有了用青玉的想法，不过前期BOSS铺的场到底怎么解决我也没想好。 巫婆 几乎是最简单的一关。。这一套是我上个月组起来在天梯上玩的猎人，本来想去看看战场是什么样子结果就打过了。一费雄斑虎二费土狼，很开心的是对面解不了土狼，然后被我土狼一脚一脚踢死了。。 其实最简单的打法是用心火牧，起手翻倍心火，对面是怎么死的都不知道。。 展览馆馆长 这一关主要是馆长的嘲讽使得他的随从能够躲在后面输出。单说一费的尘魔就有很多职业解起来很麻烦，这个时候就要挑解场能力比较强的职业了。我比较推荐法师，这一关火冲的补刀真的特别特别好用。 夜之魇没什么好说的，自动星界。全带大哥，跟他拼大哥就是了。我的牌表不是很壕就不放上来丢人了qwq。 不过如果他第一个回合上大螺丝解了你的怪或者拍大表哥你还解不掉可能就GG了。。 邪蹄 我是加基森出了挺长时间以后才开始玩的。那个时候已经有可以摩擦邪蹄的「疯狂药水」了。 起手找两张疯狂药水，你拉过来的粗鄙小鬼死了给你生小鬼还掉邪蹄的血。暗影狂乱白富美都可以带，反正是一个随随便便过的BOSS。 上层塔埃兰之影 多带点法术砸死他，好像也没什么可说的。享受蓝龙加成的快感吧！ 注意埃兰的那个全场打 10 10 10 的奥秘就好，不用随从打他，用法术轰他。 而且这个BOSS有法反，注意一下就好。 虚空幽龙 把大屁股嘲讽放在右边，高攻击冲锋放在左边。可能是AI有问题，一费我在右边放了一个虚空行者，然后BOSS就和失了智一样，前四个回合什么都没干。。然后就被我碾压了。。 营救麦迪文 常见的思路，要么是王子出来接着斩了他，要么是法反掉扭曲虚空，还有就是克总转生城墙萨。这里我选择了这一套克苏恩牧。 能赢的契机在于，我发现如果一费北婊，那么BOSS有很大的概率会上监工，这样二费奶一口前期就没有压力了，后期两个兜帽侍僧两个目光尊者两个奶泉足够把克苏恩叠到 72 72 72 攻了。 不要控BOSS血，把她打到一血，让她的斧子不敢砍你的墙。 贴一下当时斩杀王子的图，哈哈。","categories":[{"name":"日常生活","slug":"日常生活","permalink":"http://sulfur6.github.io/categories/日常生活/"}],"tags":[{"name":"炉石传说","slug":"炉石传说","permalink":"http://sulfur6.github.io/tags/炉石传说/"},{"name":"冒险模式","slug":"冒险模式","permalink":"http://sulfur6.github.io/tags/冒险模式/"}],"keywords":[{"name":"日常生活","slug":"日常生活","permalink":"http://sulfur6.github.io/categories/日常生活/"}]},{"title":"「HNOI2008」水平可见直线 - 计算几何，单调栈","slug":"bzoj1007","date":"2017-05-24T07:11:44.000Z","updated":"2017-06-02T13:39:40.000Z","comments":true,"path":"bzoj1007/","link":"","permalink":"http://sulfur6.github.io/bzoj1007/","excerpt":"有 n n n 条直线，在正无穷处往下看，如果一条直线的某一部分没有被其他任何直线覆盖，则我们认为这条直线是可见的，输出所有可见直线的编号。","text":"有 n n n 条直线，在正无穷处往下看，如果一条直线的某一部分没有被其他任何直线覆盖，则我们认为这条直线是可见的，输出所有可见直线的编号。 题解我先描述一下算法。 首先对所有直线按照斜率从小到大，截距从大到小排序。然后把最小的两条斜率不想等的直线放到一个栈里，每次向栈中加入一条直线时检查即将加入的直线和栈顶直线的交点和栈顶直线和栈第二位直线的交点的位置关系，若新直线与栈顶直线的交点在栈顶直线和栈第二位直线的交点左边，则将栈顶元素弹出，若在右边，则将新直线入栈。最后栈中的直线就是答案。 下面形象的解释一下它的正确性。 首先，我们要维护的应该是一个下凸壳（就是说起来形象一点）。。 假设这是栈中的两条直线，则 F F F 为栈顶直线，G G G 为栈第二位直线。绿色部分就是目前合法的下凸壳。 现在插入直线 L L L，交点在右侧，此时凸壳变成了蓝色部分，此时栈顶直线 F F F 已经变为不可见的，就把它出栈。 若直线 L L L 和栈顶直线的交点在左侧，凸壳就变成下图状态，此时原栈顶直线仍然可见，则直接将直线 L L L 入栈。 其实用语言来描述就是，排序以后保证栈顶元素下面的元素一定可以覆盖住它的一半，而只有一条斜率更大的直线才能覆盖住它的另一半，所以只需要检查新加入的斜率更大的直线是否能够完全覆盖未被覆盖的部分就可以了。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;cmath&gt;#include &lt;cfloat&gt;#include &lt;algorithm&gt;const int MAX_N = 50000;const double EPS = 1e-8;struct Line &#123; double k, b; int id; bool operator&lt;(const Line &amp;other) const &#123; if (fabs(k - other.k) &lt; EPS) return b &gt; other.b; return k &lt; other.k; &#125;&#125; l[MAX_N + 1];int n;int s[MAX_N + 1], top = 1;bool ans[MAX_N + 1];inline double calc(Line a, Line b) &#123; return (b.b - a.b) / (a.k - b.k);&#125;inline void solve() &#123; memset(ans, 0, sizeof(ans)); std::sort(l + 1, l + n + 1); s[top] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (fabs(l[i].k - l[i - 1].k) &lt; EPS) continue; while (top &gt; 1 &amp;&amp; calc(l[i], l[s[top]]) &lt;= calc(l[s[top]], l[s[top - 1]])) top--; s[++top] = i; &#125; for (int i = 1; i &lt;= top; i++) &#123; ans[l[s[i]].id] = true; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (ans[i]) printf(\"%d \", i); &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%lf %lf\", &amp;l[i].k, &amp;l[i].b); l[i].id = i; &#125; solve(); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"http://sulfur6.github.io/tags/计算几何/"},{"name":"单调栈","slug":"单调栈","permalink":"http://sulfur6.github.io/tags/单调栈/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「HNOI2008」神奇的国度 - 弦图染色","slug":"bzoj1006","date":"2017-05-23T13:01:16.000Z","updated":"2017-06-02T13:39:26.000Z","comments":true,"path":"bzoj1006/","link":"","permalink":"http://sulfur6.github.io/bzoj1006/","excerpt":"给定一个弦图，求其最小染色数。","text":"给定一个弦图，求其最小染色数。 题解用最大势算法求出弦图的完美消除序列。由于弦图的团数等于其染色数，直接求出其团数即可。 最大势算法详见代码。。 具体的证明可以看 cdq 冬令营的讲课稿。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;const int MAX_N = 10000;const int MAX_M = 1000000;struct Node;struct Edge;struct Node &#123; Edge *e; int pos, label; bool vis; Node() : e(NULL), pos(-1), label(0), vis(false) &#123;&#125;&#125; N[MAX_N + 1];struct Edge &#123; Node *fr, *to; Edge *ne; Edge(Node *fr, Node *to) : fr(fr), to(to), ne(fr-&gt;e) &#123;&#125;&#125;;inline void addEdge(int fr, int to) &#123; N[fr].e = new Edge(&amp;N[fr], &amp;N[to]); N[to].e = new Edge(&amp;N[to], &amp;N[fr]);&#125;std::priority_queue&lt; std::pair&lt;int, Node *&gt; &gt; q;int n, m;inline int mcs() &#123; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; q.push(std::make_pair(0, &amp;N[i])); &#125; for (int i = n; i &gt;= 1; i--) &#123;#ifdef DBG Node *u = q.top().second;#endif while (q.top().second-&gt;vis) q.pop(); Node *v = q.top().second; v-&gt;pos = i; v-&gt;vis = true; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (!e-&gt;to-&gt;vis) &#123; q.push(std::make_pair(++e-&gt;to-&gt;label, e-&gt;to)); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; int sum = 0; for (Edge *e = N[i].e; e; e = e-&gt;ne) &#123; if (e-&gt;to-&gt;pos &gt; N[i].pos) sum++; &#125; ans = std::max(ans, sum + 1); &#125; return ans;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); addEdge(u, v); &#125; printf(\"%d\\n\", mcs()); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"最大势算法","slug":"最大势算法","permalink":"http://sulfur6.github.io/tags/最大势算法/"},{"name":"弦图染色","slug":"弦图染色","permalink":"http://sulfur6.github.io/tags/弦图染色/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「HNOI2008」明明的烦恼 - prufer序列","slug":"bzoj1005","date":"2017-05-23T12:48:16.000Z","updated":"2017-06-02T13:39:16.000Z","comments":true,"path":"bzoj1005/","link":"","permalink":"http://sulfur6.github.io/bzoj1005/","excerpt":"给出标号为 1 1 1 到 N N N 的点，以及某些点最终的度数，允许在任意两点间连线，可产生多少棵度数满足要求的树？","text":"给出标号为 1 1 1 到 N N N 的点，以及某些点最终的度数，允许在任意两点间连线，可产生多少棵度数满足要求的树？ 题解首先要知道一个叫「prufer序列」的东西。 首先，从有标号无根树生成「prufer序列」的方法我就不瞎逼逼了。 其次，一个「prufer序列」唯一对应一棵有标号无根树。 再次，一棵 n n n 个节点的有标号无根树的「prufer序列」的长度为 n−2 n - 2 n−2，树中度为 d d d 的点在「prufer序列」中的出现次数是 d−1 d - 1 d−1。 设一共有 k k k个被限制度的点，di d_i d​i​​ 为第 i i i 个节点的度，s=∑di≠−1di s = \\sum\\limits_{d_i \\neq -1} d_i s=​d​i​​≠−1​∑​​d​i​​，表示被限制度的点在序列中出现了 s s s 次。 考虑这些点的位置： C(n−2,s)s!∏di≠−1(di−1)! C(n - 2, s)\\frac { s! } {\\prod\\limits_{d_i \\neq -1} (d_i - 1)!} C(n−2,s)​​d​i​​≠−1​∏​​(d​i​​−1)!​​s!​​对于序列中剩下的 n−2−s n - 2 - s n−2−s 个点，就可以随便放了，所以整体上就是 s!C(n−2,s)(n−k)n−2−s∏di≠−1(di−1)! \\frac {s!C(n - 2, s)(n - k) ^ {n - 2 - s}} {\\prod\\limits_{d_i \\neq -1}(d_i - 1)!} ​​d​i​​≠−1​∏​​(d​i​​−1)!​​s!C(n−2,s)(n−k)​n−2−s​​​​上式化简得: (n−2)!(n−k)n−2−s(n−2−s)!∏di≠−1(di−1)! \\frac {(n - 2)!(n - k) ^ {n - 2 - s}} {(n - 2 - s)!\\prod\\limits_{d_i \\neq -1} (d_i - 1)!} ​(n−2−s)!​d​i​​≠−1​∏​​(d​i​​−1)!​​(n−2)!(n−k)​n−2−s​​​​代码不想贴了。。我羞耻的没有写高精度。。","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://sulfur6.github.io/tags/组合数学/"},{"name":"prufer序列","slug":"prufer序列","permalink":"http://sulfur6.github.io/tags/prufer序列/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「HNOI2008」Card - Burnside引理","slug":"bzoj1004","date":"2017-05-23T08:25:22.000Z","updated":"2017-06-02T13:38:56.000Z","comments":true,"path":"bzoj1004/","link":"","permalink":"http://sulfur6.github.io/bzoj1004/","excerpt":"把 n n n 张卡牌染成 a a a 张红色，b b b 张蓝色，c c c 张绿色。同时给定 m m m 种洗牌方法，求有多少种不同染色的方案数。两种染色方法相同当且仅当一种染色方法可以同过任意洗牌方式变成另一种。","text":"把 n n n 张卡牌染成 a a a 张红色，b b b 张蓝色，c c c 张绿色。同时给定 m m m 种洗牌方法，求有多少种不同染色的方案数。两种染色方法相同当且仅当一种染色方法可以同过任意洗牌方式变成另一种。 题解使用 Burnside 引理。 染色集中的非等价染色数等于在置换群的每个置换作用下保持不变的着色之和的平均数。。懒得证了，组合数学上讲的还是很好的嘛。蛤蛤蛤团长就是这样的无耻。 至于统计在每个置换群作用下保持不变的着色数，可以用一个 DP 解决。 首先找出置换的循环节，这里这里只需要保证置换的循环节全部都是一种颜色就可以保证在这种置换的作用下染色保持不变了。不证明，YY一下发现它就是对的。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;const int MAX_X = 20;const int MAX_N = 60;const int MAX_M = 60;int a, b, c, n, m, mod;inline int calc(int *map) &#123; bool flag[MAX_M + 1] = &#123; false &#125;; std::vector&lt;int&gt; v; for (int i = 1; i &lt;= n; i++) &#123; int x = 0; for (int j = i; !flag[j]; j = map[j]) &#123; flag[j] = true; x++; &#125; if (x) v.push_back(x); &#125; static int f[MAX_X + 1][MAX_X + 1][MAX_X + 1]; memset(f, 0, sizeof(f)); f[0][0][0] = 1; for (std::vector&lt;int&gt;::const_iterator it = v.begin(); it != v.end(); it++) &#123; for (int i = a; i &gt;= 0; i--) &#123; for (int j = b; j &gt;= 0; j--) &#123; for (int k = c; k &gt;= 0; k--) &#123; if (i &gt;= *it) (f[i][j][k] += f[i - *it][j][k]) %= mod; if (j &gt;= *it) (f[i][j][k] += f[i][j - *it][k]) %= mod; if (k &gt;= *it) (f[i][j][k] += f[i][j][k - *it]) %= mod; &#125; &#125; &#125; &#125; return f[a][b][c];&#125;inline void exgcd(int a, int b, int &amp;g, int &amp;x, int &amp;y) &#123; if (!b) g = a, x = 1, y = 0; else exgcd(b, a % b, g, y, x), y -= x * (a / b);&#125;inline int inv(int x) &#123; int g, r, y; exgcd(x, mod, g, r, y); return (r % mod + mod) % mod;&#125;int main() &#123; scanf(\"%d %d %d %d %d\", &amp;a, &amp;b, &amp;c, &amp;m, &amp;mod); n = a + b + c; static int map[MAX_N + 1]; int sum = 0; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) scanf(\"%d\", &amp;map[j]); (sum += calc(map)) %= mod;; &#125; for (int i = 1; i &lt;= n; i++) map[i] = i; (sum += calc(map)) %= mod; int ans = sum * inv(m + 1) % mod; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://sulfur6.github.io/tags/组合数学/"},{"name":"置换群","slug":"置换群","permalink":"http://sulfur6.github.io/tags/置换群/"},{"name":"Burnside引理","slug":"Burnside引理","permalink":"http://sulfur6.github.io/tags/Burnside引理/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「ZJOI2006」物流运输 - 最短路，DP","slug":"bzoj1003","date":"2017-05-20T01:39:40.000Z","updated":"2017-06-02T13:38:40.000Z","comments":true,"path":"bzoj1003/","link":"","permalink":"http://sulfur6.github.io/bzoj1003/","excerpt":"物流公司要把一批货物从码头A运到码头B。由于货物量比较大，需要 n n n 天才能运完。货物输过程中一般要转停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是修改路线是一件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个 n n n 天的运输计划，使得总成本尽可能地小。","text":"物流公司要把一批货物从码头A运到码头B。由于货物量比较大，需要 n n n 天才能运完。货物输过程中一般要转停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是修改路线是一件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个 n n n 天的运输计划，使得总成本尽可能地小。 题解团长神智不清的时候盯着这题看了一节课。。结果发现自己看错题了。。 缓过神来以后感觉还是很简单的。。 首先预处理出 ci,j c_{i, j} c​i,j​​，意义是保证所有码头在第 i i i 天到第 j j j 天都可以运输货物的情况下不更换运输计划的最小运输费用，这个可以用最短路算法处理出来。 设 f(i) f(i) f(i) 为第 i i i 天时的最小费用，那么有显然的转移： f(i)=minj=1i−1(f(i),f(j)+cj+1,i+k) f(i) = \\min\\limits_{j = 1}^{i - 1} (f(i), f(j) + c_{j + 1, i} + k) f(i)=​j=1​min​i−1​​(f(i),f(j)+c​j+1,i​​+k)其中 k k k 是改变一次运输计划带来的额外代价。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;const int MAX_N = 100 + 10;const int MAX_M = 20 + 10;const int MAX_E = MAX_M * MAX_M;const int INF = 2e9;struct Edge &#123; int x, y, w; int ne;&#125; e[MAX_E + 10];int v[MAX_M + 1], num;inline void put(int x, int y, int z) &#123; num++; e[num].x = x, e[num].y = y, e[num].w = z; e[num].ne = v[x], v[x] = num;&#125;int n, m, k, tot;bool del[MAX_M + 1][MAX_N + 1], invalid[MAX_M + 1];int f[MAX_N + 1], cost[MAX_N + 1][MAX_N + 1];int dist[MAX_M + 1];bool inq[MAX_M + 1];inline int spfa() &#123; std::queue&lt;int&gt; q; memset(inq, 0, sizeof(inq));// for (int i = 1; i &lt;= m; i++) dist[i] = INT_MAX; memset(dist, 0x7f, sizeof(dist)); dist[1] = 0; inq[1] = true; while (!q.empty()) q.pop(); q.push(1); while (!q.empty()) &#123; int x = q.front(); q.pop(); inq[x] = false; for (int i = v[x]; i; i = e[i].ne) &#123; int y = e[i].y; if (!invalid[y] &amp;&amp; dist[y] &gt; dist[x] + e[i].w) &#123; dist[y] = dist[x] + e[i].w; if (!inq[y]) &#123; inq[y] = true; q.push(y); &#125; &#125; &#125; &#125; return dist[m];&#125;int main() &#123; scanf(\"%d %d %d %d\", &amp;n, &amp;m, &amp;k, &amp;tot); for (int i = 1; i &lt;= tot; i++) &#123; int x, y, z; scanf(\"%d %d %d\", &amp;x, &amp;y, &amp;z); put(x, y, z); put(y, x, z); &#125; int d; scanf(\"%d\", &amp;d); for (int i = 1; i &lt;= d; i++) &#123; int p, a, b; scanf(\"%d %d %d\", &amp;p, &amp;a, &amp;b); for (int j = a; j &lt;= b; j++) &#123; del[p][j] = true; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &lt;= n; j++) &#123; memset(invalid, 0, sizeof(invalid)); for (int k = 1; k &lt;= m; k++) for (int a = i; a &lt;= j; a++) invalid[k] |= del[k][a]; cost[i][j] = spfa(); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &lt;= n; j++) &#123; if (cost[i][j] &lt; INF) cost[i][j] *= (j - i + 1); &#125; &#125; for (int i = 1; i &lt;= n; i++) f[i] = cost[1][i]; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; f[i] = std::min(f[i], f[j] + cost[j + 1][i] + k); &#125; &#125; printf(\"%d\\n\", f[n]); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.github.io/tags/DP/"},{"name":"最短路","slug":"最短路","permalink":"http://sulfur6.github.io/tags/最短路/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「HNOI2017」单旋 - LCT","slug":"hnoi2017-spaly","date":"2017-05-20T01:29:29.000Z","updated":"2017-06-02T13:41:40.000Z","comments":true,"path":"hnoi2017-spaly/","link":"","permalink":"http://sulfur6.github.io/hnoi2017-spaly/","excerpt":"题目要求你维护一棵 Spaly，也就是单旋 splay。 并支持: 单旋最大值 单旋最小值 删除最大值 删除最小值 插入一个值 对于前四种操作，输出最大或最小值所在的深度，对于最后一种操作，输出插入后该节点的深度。 关于单旋的定义详见题目描述。","text":"题目要求你维护一棵 Spaly，也就是单旋 splay。 并支持: 单旋最大值 单旋最小值 删除最大值 删除最小值 插入一个值 对于前四种操作，输出最大或最小值所在的深度，对于最后一种操作，输出插入后该节点的深度。 关于单旋的定义详见题目描述。 题解首先，写一棵 spaly 显然不符合题目要求。 我们发现，由于本题只会单旋最大值或者最小值，结合单旋的优秀（暴力）性质，可以发现这棵树的形态只会发生非常少的变化。 对于插入操作，可以证明对于一个值，如果它在 spaly 中同时具有前驱和后继，那么前驱和后继对应书中的节点一定是父子关系，这时候只需要插入到深度较大的点的下面就可以了。这个新插入的节点一定会变成前驱的右儿子或者后继的左儿子。没有前驱或者没有后继的话就有哪个往哪个插。 单旋操作，这里以单旋最小值为例。在树中只会使得最小值的右子树变成其父节点的左子树，并让原来的根节点变成它的右子树。单旋最大值类似，总之 YY 一下就好了。 这样想的话直接用 LCT 维护一下就好了，还有一种维护 dfs序 和 深度 的做法，我太弱了只会 LCT。 代码好蠢的代码，只是懒得重构了。 #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;set&gt;#include &lt;algorithm&gt;const int MAX_N = 100000;const int MAX_VAL = 1e9;struct Spaly &#123; struct Node &#123; Node *fa, *c[2], *pathFa; Node *lc, *rc, *par; int size; Node() : fa(NULL), pathFa(NULL), lc(NULL), rc(NULL), par(NULL), size(1) &#123; c[0] = c[1] = NULL; &#125; void maintain() &#123; size = (c[0] ? c[0]-&gt;size : 0) + (c[1] ? c[1]-&gt;size : 0) + 1; &#125; int relation() &#123; return this == fa-&gt;c[1]; &#125; void rotate() &#123; Node *old = fa; int x = relation(); std::swap(fa-&gt;pathFa, pathFa); fa = old-&gt;fa; if (old-&gt;fa) old-&gt;fa-&gt;c[old-&gt;relation()] = this; old-&gt;c[x] = c[x ^ 1]; if (c[x ^ 1]) c[x ^ 1]-&gt;fa = old; c[x ^ 1] = old; old-&gt;fa = this; old-&gt;maintain(), maintain(); &#125; void splay() &#123; while (fa) &#123; if (!fa-&gt;fa) rotate(); else if (fa-&gt;relation() == relation()) fa-&gt;rotate(), rotate(); else rotate(), rotate(); &#125; &#125; void expose() &#123; splay(); if (c[1]) &#123; std::swap(c[1]-&gt;fa, c[1]-&gt;pathFa); c[1] = NULL; &#125; maintain(); &#125; bool splice() &#123; splay(); if (!pathFa) return false; pathFa-&gt;expose(); pathFa-&gt;c[1] = this; std::swap(fa, pathFa); fa-&gt;maintain(); return true; &#125; void access() &#123; expose(); while (splice()); &#125; int depth() &#123; access(); splay(); return size; &#125; &#125; N[MAX_N], *root; void link(Node *u, Node *par) &#123; u-&gt;access(); u-&gt;splay(); u-&gt;pathFa = par; &#125; void cut(Node *u) &#123; u-&gt;access(); u-&gt;splay(); if (u-&gt;c[0]) u-&gt;c[0]-&gt;fa = NULL; u-&gt;c[0] = NULL; &#125;/* Node *findRoot(Node *v) &#123; v-&gt;access(); v-&gt;splay(); while (v-&gt;c[0]) v = v-&gt;c[0]; return v; &#125; */&#125; spaly;int _end = 0;struct SetNode &#123; int val; Spaly::Node *v; SetNode(int val, Spaly::Node *v) : val(val), v(v) &#123;&#125; bool operator&lt;(const SetNode &amp;other) const &#123; return val &lt; other.val; &#125;&#125;;std::set&lt;SetNode&gt; set;inline int spalyMax() &#123; std::set&lt;SetNode&gt;::const_iterator it = set.end(); it--; int ans = it-&gt;v-&gt;depth(); if (ans == 1) return ans; if (it-&gt;v-&gt;lc &amp;&amp; it-&gt;v-&gt;par) &#123;// Spaly::Node *spaly.root = spaly.findRoot(it-&gt;v); spaly.cut(it-&gt;v-&gt;lc); spaly.cut(it-&gt;v); spaly.link(it-&gt;v-&gt;lc, it-&gt;v-&gt;par); it-&gt;v-&gt;par-&gt;rc = it-&gt;v-&gt;lc; it-&gt;v-&gt;lc-&gt;par = it-&gt;v-&gt;par; it-&gt;v-&gt;lc = NULL; it-&gt;v-&gt;par = NULL; spaly.link(spaly.root, it-&gt;v); it-&gt;v-&gt;lc = spaly.root; spaly.root-&gt;par = it-&gt;v; &#125; else if (it-&gt;v-&gt;par) &#123;// Spaly::Node *spaly.root = spaly.findRoot(it-&gt;v); spaly.cut(it-&gt;v); it-&gt;v-&gt;par-&gt;rc = NULL; it-&gt;v-&gt;par = NULL; spaly.link(spaly.root, it-&gt;v); spaly.root-&gt;par = it-&gt;v; it-&gt;v-&gt;lc = spaly.root; &#125; spaly.root = it-&gt;v; return ans;&#125;inline int spalyMin() &#123; std::set&lt;SetNode&gt;::const_iterator it = set.begin(); int ans = it-&gt;v-&gt;depth(); if (ans == 1) return ans; if (it-&gt;v-&gt;rc &amp;&amp; it-&gt;v-&gt;par) &#123;// Spaly::Node *spaly.root = spaly.findRoot(it-&gt;v); spaly.cut(it-&gt;v-&gt;rc); spaly.cut(it-&gt;v); spaly.link(it-&gt;v-&gt;rc, it-&gt;v-&gt;par); it-&gt;v-&gt;rc-&gt;par = it-&gt;v-&gt;par; it-&gt;v-&gt;par-&gt;lc = it-&gt;v-&gt;rc; it-&gt;v-&gt;rc = NULL; it-&gt;v-&gt;par = NULL; spaly.link(spaly.root, it-&gt;v); spaly.root-&gt;par = it-&gt;v; it-&gt;v-&gt;rc = spaly.root; &#125; else if (it-&gt;v-&gt;par) &#123;// Spaly::Node *spaly.root = spaly.findRoot(it-&gt;v); spaly.cut(it-&gt;v); it-&gt;v-&gt;par-&gt;lc = NULL; it-&gt;v-&gt;par = NULL; spaly.link(spaly.root, it-&gt;v); spaly.root-&gt;par = it-&gt;v; it-&gt;v-&gt;rc = spaly.root; &#125; spaly.root = it-&gt;v; return ans;&#125;inline int delMax() &#123; std::set&lt;SetNode&gt;::const_iterator it = set.end(); it--; int ans = spalyMax(); if (it-&gt;v-&gt;lc) spaly.cut(it-&gt;v-&gt;lc), it-&gt;v-&gt;lc-&gt;par = NULL, spaly.root = it-&gt;v-&gt;lc; set.erase(it); return ans;&#125;inline int delMin() &#123; std::set&lt;SetNode&gt;::const_iterator it = set.begin(); int ans = spalyMin(); if (it-&gt;v-&gt;rc) spaly.cut(it-&gt;v-&gt;rc), it-&gt;v-&gt;rc-&gt;par = NULL, spaly.root = it-&gt;v-&gt;rc; set.erase(it); return ans;&#125;inline int insert(int val) &#123; SetNode v(val, &amp;spaly.N[_end++]); if (set.empty()) return set.insert(v), spaly.root = v.v, 1; std::set&lt;SetNode&gt;::const_iterator suc = set.lower_bound(v), pre = suc; if (suc == set.end()) &#123; pre--; spaly.link(v.v, pre-&gt;v); v.v-&gt;par = pre-&gt;v; pre-&gt;v-&gt;rc = v.v; &#125; else if (suc == set.begin()) &#123; spaly.link(v.v, suc-&gt;v); v.v-&gt;par = suc-&gt;v; suc-&gt;v-&gt;lc = v.v; &#125; else &#123; pre--; if (pre-&gt;v-&gt;depth() &gt; suc-&gt;v-&gt;depth()) &#123; spaly.link(v.v, pre-&gt;v); v.v-&gt;par = pre-&gt;v; pre-&gt;v-&gt;rc = v.v; &#125; else &#123; spaly.link(v.v, suc-&gt;v); v.v-&gt;par = suc-&gt;v; suc-&gt;v-&gt;lc = v.v; &#125; &#125; set.insert(v); return v.v-&gt;depth();&#125;int main() &#123; int m; scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int cmd; scanf(\"%d\", &amp;cmd); if (cmd == 1) &#123; int key; scanf(\"%d\", &amp;key); printf(\"%d\\n\", insert(key)); &#125; else if (cmd == 2) &#123; printf(\"%d\\n\", spalyMin()); &#125; else if (cmd == 3) &#123; printf(\"%d\\n\", spalyMax()); &#125; else if (cmd == 4) &#123; printf(\"%d\\n\", delMin()); &#125; else if (cmd == 5) &#123; printf(\"%d\\n\", delMax()); &#125; &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://sulfur6.github.io/tags/LCT/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「BeiJing2006」狼爪兔子 - 平面图最小割","slug":"rabbit","date":"2017-05-20T00:30:03.000Z","updated":"2017-06-02T13:38:26.000Z","comments":true,"path":"rabbit/","link":"","permalink":"http://sulfur6.github.io/rabbit/","excerpt":"给定这种形式的一个图，求其最大流。","text":"给定这种形式的一个图，求其最大流。 题解据 Hellc 说，直接 dinic 就可以了，但是我没写，认真学习了一下正解，「平面图最大流」。 论文东西太多了，我转述也转述不清，详情见 《两极相通 —— 浅析最大最小定理在信息学竞赛中的应用》，写的很好很形象。 代码注意只有一行或者只有一列时的特判。 #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;const int MAX_N = 1000;const int MAX_M = 1000;const int MAX_NODE = MAX_N * MAX_M * 2 + 2;struct Node;struct Edge;struct Node &#123; Edge *e; int dist; bool vis;&#125; N[MAX_NODE];struct Edge &#123; Node *fr, *to; Edge *ne; int w; Edge(Node *fr, Node *to, int w) : fr(fr), to(to), ne(fr-&gt;e), w(w) &#123;&#125;&#125;;inline void addEdge(int fr, int to, int w) &#123; N[fr].e = new Edge(&amp;N[fr], &amp;N[to], w); N[to].e = new Edge(&amp;N[to], &amp;N[fr], w);&#125;inline int djk(int begin, int end, int n) &#123; Node *s = &amp;N[begin], *t = &amp;N[end]; std::priority_queue&lt; std::pair&lt;int, Node *&gt;, std::vector&lt; std::pair&lt;int, Node *&gt; &gt;, std::greater&lt; std::pair&lt;int, Node *&gt; &gt; &gt; q; for (int i = 0; i &lt; n; i++) N[i].dist = INT_MAX, N[i].vis = false; s-&gt;dist = 0; q.push(std::make_pair(s-&gt;dist, s)); while (!q.empty()) &#123; Node *v = q.top().second; q.pop(); if (v-&gt;vis) continue; v-&gt;vis = true; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;to-&gt;dist &gt; v-&gt;dist + e-&gt;w) &#123; e-&gt;to-&gt;dist = v-&gt;dist + e-&gt;w; q.push(std::make_pair(e-&gt;to-&gt;dist, e-&gt;to)); &#125; &#125; &#125; return t-&gt;dist;&#125;int n, m;inline int id(int i, int j) &#123; return (i - 1) * 2 * (m - 1) + j;&#125;inline int solve() &#123; if (n == 1 &amp;&amp; m == 1) return 0; else if (n == 1) &#123; int ans = INT_MAX; for (int i = 0; i &lt; m - 1; i++) &#123; int w; scanf(\"%d\", &amp;w); ans = std::min(ans, w); &#125; return ans; &#125; else if (m == 1) &#123; int ans = INT_MAX; for (int i = 0; i &lt; n - 1; i++) &#123; int w; scanf(\"%d\", &amp;w); ans = std::min(ans, w); &#125; return ans; &#125; int s = 2 * (m - 1) * (n - 1), t = s + 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; m - 1; j++) &#123; int w; scanf(\"%d\", &amp;w); if (i == 1) &#123; addEdge(id(i, (j * 2) ^ 1), t, w); &#125; else if (i == n) &#123; addEdge(s, id(i - 1, j * 2), w); &#125; else &#123; addEdge(id(i, (j * 2) ^ 1), id(i - 1, j * 2), w); &#125; &#125; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; int w; scanf(\"%d\", &amp;w); if (j == 0) &#123; addEdge(s, id(i, j * 2), w); &#125; else if (j == m - 1) &#123; addEdge(id(i, ((j - 1) * 2) ^ 1), t, w); &#125; else &#123; addEdge(id(i, ((j - 1) * 2) ^ 1), id(i, (j * 2)), w); &#125; &#125; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; m - 1; j++) &#123; int w; scanf(\"%d\", &amp;w); addEdge(id(i, j * 2), id(i, (j * 2) ^ 1), w); &#125; &#125; return djk(s, t, t + 1);&#125;int main() &#123;// freopen(\"bjrabbit.in\", \"r\", stdin), freopen(\"bjrabbit.out\", \"w\", stdout); scanf(\"%d %d\", &amp;n, &amp;m); printf(\"%d\\n\", solve()); return 0;&#125;","categories":[],"tags":[{"name":"平面图","slug":"平面图","permalink":"http://sulfur6.github.io/tags/平面图/"},{"name":"最小割","slug":"最小割","permalink":"http://sulfur6.github.io/tags/最小割/"},{"name":"最段路","slug":"最段路","permalink":"http://sulfur6.github.io/tags/最段路/"}],"keywords":[]},{"title":"「SDOI2017」相关分析 - 线段树","slug":"SDOI2017Round1Day2T3","date":"2017-05-06T00:58:38.000Z","updated":"2017-06-02T13:37:46.000Z","comments":true,"path":"SDOI2017Round1Day2T3/","link":"","permalink":"http://sulfur6.github.io/SDOI2017Round1Day2T3/","excerpt":"题目描述Frank 对天文学非常感兴趣，他经常用望远镜看星星， 同时记录下它们的信息，比如亮度、颜色等等，进而估算出星星的距离、半径等等。 Frank 不仅喜欢观测，还喜欢分析观测到的数据。他经常分析两个参数之间 （比如亮度和半径） 是否存在某种关系。 现在 Frank 要分析参数 X X X 与 Y Y Y 之间的关系。他有 n n n 组观测数据，第 i i i 组观测数据记录了 xi x_i x​i​​ 和 yi y_i y​i​​。他需耍进行以下几种操作： 用直线拟合第 L L L 组到第 R R R 组观测数据。用 x¯ \\bar x ​x​¯​​ 表示这些观测数据中 x x x 的平均数，用 y¯ \\bar y ​y​¯​​ 表示这些观测数据中 y y y 的平均数，即 x¯=1R−L+1∑i=LRxiy¯=1R−L+1∑i=LRyi \\begin{aligned} \\bar{x} &amp;= \\frac{1}{R - L + 1} \\sum\\limits_{i = L} ^ R x_i \\\\ \\bar{y} &amp;= \\frac{1}{R - L + 1} \\sum\\limits_{i = L} ^ R y_i \\end{aligned} ​​x​¯​​​​y​¯​​​​​=​R−L+1​​1​​​i=L​∑​R​​x​i​​​=​R−L+1​​1​​​i=L​∑​R​​y​i​​​​ 如果直线方程是 y=ax+b y = ax + b y=ax+b，那么 a a a、b b b 应该这样计算： a=∑i=LR(xi−x¯)(yi−y¯)∑i=LR(xi−x¯)2b=y¯−ax¯ \\begin{aligned} a &amp;= \\frac{\\sum\\limits_{i = L} ^ R (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum\\limits_{i = L} ^ R (x_i - \\bar{x}) ^ 2} \\\\ b &amp;= \\bar{y} - a \\bar{x} \\end{aligned} ​a​b​​​=​​i=L​∑​R​​(x​i​​−​x​¯​​)​2​​​​​i=L​∑​R​​(x​i​​−​x​¯​​)(y​i​​−​y​¯​​)​​​=​y​¯​​−a​x​¯​​​​ 你需要帮助 Frank 计算 a a a。 Frank 发现测量第 L L L 组到第 R R R 组数据时有误差，对于每个 i i i 满足 L≤i≤R L \\leq i \\leq R L≤i≤R，xi x_i x​i​​ 需要加上 S S S，yi y_i y​i​​ 需要加上 T T T。 Frank 发现第 L L L 组到第 R R R 组数据需要修改，对于每个 i i i 满足 L≤i≤R L \\leq i \\leq R L≤i≤R，xi x_i x​i​​ 需要修改为 (S+i) (S + i) (S+i)，yi y_i y​i​​ 需要修改为 (T+i) (T + i) (T+i)。","text":"题目描述Frank 对天文学非常感兴趣，他经常用望远镜看星星， 同时记录下它们的信息，比如亮度、颜色等等，进而估算出星星的距离、半径等等。 Frank 不仅喜欢观测，还喜欢分析观测到的数据。他经常分析两个参数之间 （比如亮度和半径） 是否存在某种关系。 现在 Frank 要分析参数 X X X 与 Y Y Y 之间的关系。他有 n n n 组观测数据，第 i i i 组观测数据记录了 xi x_i x​i​​ 和 yi y_i y​i​​。他需耍进行以下几种操作： 用直线拟合第 L L L 组到第 R R R 组观测数据。用 x¯ \\bar x ​x​¯​​ 表示这些观测数据中 x x x 的平均数，用 y¯ \\bar y ​y​¯​​ 表示这些观测数据中 y y y 的平均数，即 x¯=1R−L+1∑i=LRxiy¯=1R−L+1∑i=LRyi \\begin{aligned} \\bar{x} &amp;= \\frac{1}{R - L + 1} \\sum\\limits_{i = L} ^ R x_i \\\\ \\bar{y} &amp;= \\frac{1}{R - L + 1} \\sum\\limits_{i = L} ^ R y_i \\end{aligned} ​​x​¯​​​​y​¯​​​​​=​R−L+1​​1​​​i=L​∑​R​​x​i​​​=​R−L+1​​1​​​i=L​∑​R​​y​i​​​​ 如果直线方程是 y=ax+b y = ax + b y=ax+b，那么 a a a、b b b 应该这样计算： a=∑i=LR(xi−x¯)(yi−y¯)∑i=LR(xi−x¯)2b=y¯−ax¯ \\begin{aligned} a &amp;= \\frac{\\sum\\limits_{i = L} ^ R (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum\\limits_{i = L} ^ R (x_i - \\bar{x}) ^ 2} \\\\ b &amp;= \\bar{y} - a \\bar{x} \\end{aligned} ​a​b​​​=​​i=L​∑​R​​(x​i​​−​x​¯​​)​2​​​​​i=L​∑​R​​(x​i​​−​x​¯​​)(y​i​​−​y​¯​​)​​​=​y​¯​​−a​x​¯​​​​ 你需要帮助 Frank 计算 a a a。 Frank 发现测量第 L L L 组到第 R R R 组数据时有误差，对于每个 i i i 满足 L≤i≤R L \\leq i \\leq R L≤i≤R，xi x_i x​i​​ 需要加上 S S S，yi y_i y​i​​ 需要加上 T T T。 Frank 发现第 L L L 组到第 R R R 组数据需要修改，对于每个 i i i 满足 L≤i≤R L \\leq i \\leq R L≤i≤R，xi x_i x​i​​ 需要修改为 (S+i) (S + i) (S+i)，yi y_i y​i​​ 需要修改为 (T+i) (T + i) (T+i)。 题解展开上式，发现只需维护区间 xi,yi,xiyi,xi2 x_i, y_i, x_iy_i, x_i^2 x​i​​,y​i​​,x​i​​y​i​​,x​i​2​​，就可以回答上述问题。 对于修改操作 2 2 2，线段树区间修改随便搞，对于操作 3 3 3 由于给定的 S S S 和 T T T 可能为 0 0 0，所以需要一定奇技淫巧来标记该区间有无被复制。 线段树节点切勿忘记开 double。。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#define double long doubletypedef long long ll;const int MAX_N = 100000;double x[MAX_N + 1], y[MAX_N + 1];double sum[MAX_N + 1], sum2[MAX_N + 1];inline void prepare() &#123; sum[0] = 0, sum2[0] = 0; for (int i = 1; i &lt;= MAX_N; i++) &#123; sum[i] = sum[i - 1] + i; sum2[i] = sum2[i - 1] + (double)i * i; &#125;&#125;inline double calc(int l, int r) &#123; return sum[r] - sum[l - 1];&#125;inline double calc2(int l, int r) &#123; return sum2[r] - sum2[l - 1];&#125;struct Segt &#123; int l, r; Segt *lc, *rc; double sx, sy, sxy, sxx; double tags, tagt; double cs, ct; bool changed; Segt(int l, int r, Segt *lc, Segt *rc) : l(l), r(r), lc(lc), rc(rc), sx(lc-&gt;sx + rc-&gt;sx), sy(lc-&gt;sy + rc-&gt;sy), sxy(lc-&gt;sxy + rc-&gt;sxy), sxx(lc-&gt;sxx + rc-&gt;sxx), tags(0), tagt(0), cs(0), ct(0), changed(false) &#123;&#125; Segt(int l, int r, Segt *lc, Segt *rc, double sx, double sy) : l(l), r(r), lc(lc), rc(rc), sx(sx), sy(sy), sxy(sx * sy), sxx(sx * sx), tags(0), tagt(0), cs(0), ct(0), changed(false) &#123;&#125; double querysx(int l, int r) &#123; if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return sx; else return pushDown(), lc-&gt;querysx(l, r) + rc-&gt;querysx(l, r); &#125; double querysy(int l, int r) &#123; if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return sy; else return pushDown(), lc-&gt;querysy(l, r) + rc-&gt;querysy(l, r); &#125; double querysxy(int l, int r) &#123; if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return sxy; else return pushDown(), lc-&gt;querysxy(l, r) + rc-&gt;querysxy(l, r); &#125; double querysxx(int l, int r) &#123; if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return sxx; else return pushDown(), lc-&gt;querysxx(l, r) + rc-&gt;querysxx(l, r); &#125; void validate() &#123; double sx, sy, sxy, sxx; sx = this-&gt;sx; sy = this-&gt;sy; sxy = this-&gt;sxy; sxx = this-&gt;sxx; printf(\"Segt, sx : %lld, sy : %lld, sxy : %lld, sxx : %lld\\n\", (long long)sx, (long long)sy, (long long)sxy, (long long)sxx); sx = 0, sy = 0, sxy = 0, sxx = 0; for (int i = l; i &lt;= r; i++) &#123; sx += x[i]; sy += y[i]; sxy += (long long)x[i] * y[i]; sxx += (long long)x[i] * x[i]; &#125; printf(\"Force, sx : %lld, sy : %lld, sxy : %lld, sxx : %lld\\n\", (long long)sx, (long long)sy, (long long)sxy, (long long)sxx); &#125; void add(double s, double t) &#123; sxy = sxy + sx * t + sy * s + s * t * (this-&gt;r - this-&gt;l + 1); sxx = sxx + s * s * (this-&gt;r - this-&gt;l + 1) + 2 * sx * s; sx += s * (this-&gt;r - this-&gt;l + 1); sy += t * (this-&gt;r - this-&gt;l + 1); tags += s; tagt += t;// validate(); &#125; void change(double s, double t) &#123; double sump = calc(l, r), sumq = calc2(l, r); tags = 0, tagt = 0; int len = r - l + 1; sx = len * s + sump; sy = len * t + sump; sxy = len * s * t + sump * (s + t) + sumq; sxx = s * s * len + sumq + 2 * s * sump; cs = s, ct = t; changed = true;// validate(); &#125; void maintain() &#123; sx = lc-&gt;sx + rc-&gt;sx; sy = lc-&gt;sy + rc-&gt;sy; sxy = lc-&gt;sxy + rc-&gt;sxy; sxx = lc-&gt;sxx + rc-&gt;sxx; &#125; void pushDown() &#123; if (changed) &#123; lc-&gt;change(cs, ct); rc-&gt;change(cs, ct); changed = false; &#125; if (tags != 0 || tagt != 0) &#123; lc-&gt;add(tags, tagt); rc-&gt;add(tags, tagt); tags = 0, tagt = 0; &#125; &#125; void modify2(int l, int r, int s, int t) &#123; if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) add(s, t); else pushDown(), lc-&gt;modify2(l, r, s, t), rc-&gt;modify2(l, r, s, t), maintain(); &#125; void change(int l, int r, int s, int t) &#123; if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) change(s, t); else pushDown(), lc-&gt;change(l, r, s, t), rc-&gt;change(l, r, s, t), maintain(); &#125; static Segt *build(int l, int r) &#123; if (l == r) &#123; return new Segt(l, r, NULL, NULL, x[l], y[l]); &#125; else &#123; int mid = l + (r - l) / 2; return new Segt(l, r, build(l, mid), build(mid + 1, r)); &#125; &#125;&#125; *segt;inline void query(int l, int r) &#123; double sxy = segt-&gt;querysxy(l, r); double sx = segt-&gt;querysx(l, r); double sy = segt-&gt;querysy(l, r); double sxx = segt-&gt;querysxx(l, r); double xa = (double)sx / (double)(r - l + 1); double ya = (double)sy / (double)(r - l + 1); double up = sxy - (double)sx * ya - (double)sy * xa + xa * ya * (double)(r - l + 1); double down = sxx + xa * xa * (double)(r - l + 1) - 2 * sx * xa; double ans = up / down; printf(\"%.10Lf\\n\", ans);&#125;inline void modify2(int l, int r, double s, double t) &#123; for (int i = l; i &lt;= r; i++) &#123; x[i] += s, y[i] += t; &#125;&#125;inline void change(int l, int r, double s, double t) &#123; for (int i = l; i &lt;= r; i++) &#123; x[i] = s + i, y[i] = t + i; &#125;&#125;int main() &#123; freopen(\"relative.in\", \"r\", stdin); freopen(\"relative.out\", \"w\", stdout); int n, m; prepare(); scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(\"%Lf\", &amp;x[i]); for (int i = 1; i &lt;= n; i++) scanf(\"%Lf\", &amp;y[i]); segt = Segt::build(1, n); for (int i = 1; i &lt;= m; i++) &#123; int cmd; scanf(\"%d\", &amp;cmd); if (cmd == 1) &#123; int l, r; scanf(\"%d %d\", &amp;l, &amp;r); query(l, r); &#125; else if (cmd == 2) &#123; int l, r, s, t; scanf(\"%d %d %d %d\", &amp;l, &amp;r, &amp;s, &amp;t);// modify2(l, r, s, t); segt-&gt;modify2(l, r, s, t); &#125; else if (cmd == 3) &#123; int l, r, s, t; scanf(\"%d %d %d %d\", &amp;l, &amp;r, &amp;s, &amp;t);// change(l, r, s, t); segt-&gt;change(l, r, s, t); &#125; &#125; fclose(stdin), fclose(stdout); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://sulfur6.github.io/tags/线段树/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「SDOI2017」硬币游戏 - KMP，高斯消元","slug":"sdoi2017-game","date":"2017-05-06T00:58:35.000Z","updated":"2017-06-02T13:37:30.000Z","comments":true,"path":"sdoi2017-game/","link":"","permalink":"http://sulfur6.github.io/sdoi2017-game/","excerpt":"周末同学们非常无聊，有人提议，咱们扔硬币玩吧，谁扔的硬币正面次数多谁胜利。 大家纷纷觉得这个游戏非常符合同学们的特色，但只是扔硬币实在是太单调了。 同学们觉得要加强趣味性，所以要找一个同学扔很多很多次硬币，其他同学记录下正反面情况。 用 表示正面朝上， 用 表示反面朝上，扔很多次硬币后，会得到一个硬币序列。比如 表示第一次正面朝上，后两次反面朝上。 但扔到什么时候停止呢？大家提议，选出 n n n 个同学， 每个同学猜一个长度为 m m m 的序列，当某一个同学猜的序列在硬币序列中出现时，就不再扔硬币了，并且这个同学胜利。为了保证只有一个同学胜利，同学们猜的 n n n 个序列两两不同。 很快，n n n个同学猜好序列，然后进入了紧张而又刺激的扔硬币环节。你想知道，如果硬币正反面朝上的概率相同，每个同学胜利的概率是多少。","text":"周末同学们非常无聊，有人提议，咱们扔硬币玩吧，谁扔的硬币正面次数多谁胜利。 大家纷纷觉得这个游戏非常符合同学们的特色，但只是扔硬币实在是太单调了。 同学们觉得要加强趣味性，所以要找一个同学扔很多很多次硬币，其他同学记录下正反面情况。 用 表示正面朝上， 用 表示反面朝上，扔很多次硬币后，会得到一个硬币序列。比如 表示第一次正面朝上，后两次反面朝上。 但扔到什么时候停止呢？大家提议，选出 n n n 个同学， 每个同学猜一个长度为 m m m 的序列，当某一个同学猜的序列在硬币序列中出现时，就不再扔硬币了，并且这个同学胜利。为了保证只有一个同学胜利，同学们猜的 n n n 个序列两两不同。 很快，n n n个同学猜好序列，然后进入了紧张而又刺激的扔硬币环节。你想知道，如果硬币正反面朝上的概率相同，每个同学胜利的概率是多少。 题解哎呀好气呀，又到了团长看着就恶心的概率题辣。。 mmp，我在场上的时候真的是连样例都没有看懂啊。但是概率的题能看懂样例就有鬼啦。。 当时感觉可能是AC自动机上dp什么的。。但是最后这个部分分也没有想出来。。 好吧团长要正儿八经地写题解了。。 设 P(S) P(S) P(S) 为到达一个可能的硬币序列 S S S 的概率，特别的，若某位同学为 A A A，或者你乐意叫他张三李四王五都可以，那么 P(A) P(A) P(A) 为同学 A A A 胜利的概率。 设一个状态 N N N 为一个硬币序列，这个硬币序列中的任意子串不会使得任意玩家胜利，那么现在若在 N N N 后面接上玩家 A A A 的硬币序列，玩家 A A A 就可能胜利。 为什么是可能胜利呢？考虑一个玩家 A A A 的硬币序列为 TTH，玩家 B B B 的硬币序列为 HTT 这样如果状态 N N N 的末尾为 H 那么在后面加上 TT 后玩家 B B B 胜利，在这种情况下再加上 H 得到 N N N 后面接 A A A 硬币序列的情况，若 N N N 末尾为 HT 那么加上 T 后玩家 B B B 胜利，再接上 TH 后得到要求的合法情况。 这种情况只会出现在玩家 A A A 的硬币序列的某个前缀是玩家 B B B 硬币序列的某个后缀的情况。 假设只有这两个玩家，那么一个方程是显然的： P(N+A)=P(A)+0.75P(B) P(N + A) = P(A) + 0.75P(B) P(N+A)=P(A)+0.75P(B)尝试把这种情况拓展一下，对于两个任意的玩家 A,B A, B A,B，计算出所有 A A A 的硬币序列的前缀是 B B B 的硬币序列的后缀的长度 k k k，那么由 P(B) P(B) P(B) 达到到 P(N+A) P(N + A) P(N+A) 的概率应该是： ∑k12m−k \\sum\\limits_{k} \\frac {1} {2 ^ {m - k}} ​k​∑​​​2​m−k​​​​1​​这个式子可以用 KMP 处理出来。 对于第 i i i 个玩家和第 j j j 个玩家，我们记上面的式子为 Qi,j Q_{i, j} Q​i,j​​ 设 P(N) P(N) P(N) 为 x0 x_0 x​0​​，某个玩家 i i i 胜利的概率为 xi x_i x​i​​，那么这样可以列出 n n n 个方程，第 i i i 个方程的形式如下： xi+∑j=1nQi,j=12mx0 x_i + \\sum\\limits_{j = 1}^{n} Q_{i, j} = \\frac {1} {2 ^ m}x_0 x​i​​+​j=1​∑​n​​Q​i,j​​=​2​m​​​​1​​x​0​​但是这样有一个问题，现在已经列出 n n n 个方程，但是加上变量 x0 x_0 x​0​​ 一共有 n+1 n + 1 n+1 变量，所以我们需要第 n+1 n + 1 n+1 个方程。 由于所有玩家胜利的概率之和是 1 1 1，所以第 n+1 n + 1 n+1 个方程是显然的： ∑i=1nxi=1 \\sum\\limits_{i = 1}^{n} x_i = 1 ​i=1​∑​n​​x​i​​=1代码咸鱼团长第 n n n 次学习高斯消元。。 #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cfloat&gt;#include &lt;algorithm&gt;const int MAX_N = 300 + 5;const int MAX_M = 300 + 5;const long double EPS = 1e-10;int n, m, fail[MAX_N][MAX_M];long double pows[MAX_M], a[MAX_N][MAX_M];char s[MAX_N][MAX_N];inline long double check(int x, int y) &#123; long double res = 0; int max = 0; for (int i = 1; i &lt;= m; i++) &#123; while (max &amp;&amp; s[x][max + 1] != s[y][i]) max = fail[x][max]; if (s[x][max + 1] == s[y][i]) max++; &#125; while (max) res += pows[m - max], max = fail[x][max]; return res;&#125;inline void gaussJordan(int n) &#123; for (int i = 1; i &lt; n; i++) &#123; int id = i; for (int j = i + 1; j &lt; n; j++) if (fabs(a[j][i]) &gt; fabs(a[id][i])) id = j; if (id != i) for (int j = i; j &lt;= n; j++) std::swap(a[i][j], a[id][j]); for (int j = 1; j &lt; n; j++) &#123; if (i != j) &#123; for (int k = n; k &gt;= i; k--) &#123; a[j][k] -= a[i][k] / a[i][i] * a[j][i]; &#125; &#125; &#125; &#125; for (int i = 1; i &lt; n; ++i) a[i][n] /= a[i][i], a[i][i] = 1;&#125;inline void prepare() &#123; // KMP prepare for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt; m; j++) &#123; int k = fail[i][j]; while (k &amp;&amp; s[i][k + 1] != s[i][j + 1]) k = fail[i][k]; fail[i][j + 1] = s[i][k + 1] == s[i][j + 1] ? k + 1 : 0; &#125; &#125; pows[1] = 0.5; for (int i = 2; i &lt;= m; i++) pows[i] = pows[i - 1] * 0.5; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; a[i][j] = check(i, j) + (i == j ? 1.00 : 0.00); &#125; &#125; for (int i = 1; i &lt;= n; i++) a[n + 1][i] = 1, a[i][n + 1] = -1; a[n + 1][n + 2] = 1;#ifdef DBG for (int i = 1; i &lt;= n + 1; i++) &#123; for (int j = 1; j &lt;= n + 2; j++) &#123; printf(\"%.10Lf \", a[i][j]); &#125; puts(\"\"); &#125;#endif&#125;int main() &#123; freopen(\"game.in\", \"r\", stdin); freopen(\"game.out\", \"w\", stdout); scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%s\", s[i] + 1); &#125; prepare(); gaussJordan(n + 2); for (int i = 1; i &lt;= n; i++) &#123; printf(\"%.10lf\\n\", (double)a[i][n + 2]); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"概率","slug":"概率","permalink":"http://sulfur6.github.io/tags/概率/"},{"name":"KMP","slug":"KMP","permalink":"http://sulfur6.github.io/tags/KMP/"},{"name":"高斯消元","slug":"高斯消元","permalink":"http://sulfur6.github.io/tags/高斯消元/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「SDOI2017」新生舞会 - 01分数规划，二分图最大权匹配","slug":"sdoi2017-ball","date":"2017-05-06T00:58:32.000Z","updated":"2017-06-02T13:37:12.000Z","comments":true,"path":"sdoi2017-ball/","link":"","permalink":"http://sulfur6.github.io/sdoi2017-ball/","excerpt":"学校组织了一次新生舞会，Cathy 作为经验丰富的老学姐，负责为同学们安排舞伴。 有 n n n 个男生和 n n n 个女生参加舞会，一个男生和一个女生一起跳舞，互为舞伴。Cathy 收集了这些同学之间的关系，比如两个人之前是否认识，计算得出 ai,j a_{i, j} a​i,j​​，表示第 i i i 个男生和第 j j j 个女生一起跳舞时他们喜悦程度。Cathy 还需要考虑两个人一起跳舞是否方便，比如身高体重差别会不会太大，计算得出 bi,j b_{i, j} b​i,j​​ 表示第 i i i 个男生和第 j j j 个女生一起跳舞时的不协调裎度。 当然，还需要考虑很多其他间题。 Cathy 想先用一个程序通过 ai,j a_{i, j} a​i,j​​ 和 bi,j b_{i, j} b​i,j​​ 求出一种方案，再手动对方案进行微调。Cathy 找到你，希望你帮她写那个程序。 一个方案中有 n n n 对舞伴，假设每对舞伴的喜悦程度分别是 a1′,a2′,…,an′ a&#x27;_1, a&#x27;_2, \\ldots, a&#x27;_n a​1​′​​,a​2​′​​,…,a​n​′​​，假设每对舞伴不协调程度分别是 b1′,b2′,…,bn′ b&#x27;_1, b&#x27;_2, \\ldots, b&#x27;_n b​1​′​​,b​2​′​​,…,b​n​′​​。令 C=a1′+a2′+⋯+an′b1′+b2′+⋯+bn′ C = \\frac{a&#x27;_1 + a&#x27;_2 + \\cdots + a&#x27;_n}{b&#x27;_1 + b&#x27;_2 + \\cdots + b&#x27;_n} C=​b​1​′​​+b​2​′​​+⋯+b​n​′​​​​a​1​′​​+a​2​′​​+⋯+a​n​′​​​​Cathy 希望 C 值最大。","text":"学校组织了一次新生舞会，Cathy 作为经验丰富的老学姐，负责为同学们安排舞伴。 有 n n n 个男生和 n n n 个女生参加舞会，一个男生和一个女生一起跳舞，互为舞伴。Cathy 收集了这些同学之间的关系，比如两个人之前是否认识，计算得出 ai,j a_{i, j} a​i,j​​，表示第 i i i 个男生和第 j j j 个女生一起跳舞时他们喜悦程度。Cathy 还需要考虑两个人一起跳舞是否方便，比如身高体重差别会不会太大，计算得出 bi,j b_{i, j} b​i,j​​ 表示第 i i i 个男生和第 j j j 个女生一起跳舞时的不协调裎度。 当然，还需要考虑很多其他间题。 Cathy 想先用一个程序通过 ai,j a_{i, j} a​i,j​​ 和 bi,j b_{i, j} b​i,j​​ 求出一种方案，再手动对方案进行微调。Cathy 找到你，希望你帮她写那个程序。 一个方案中有 n n n 对舞伴，假设每对舞伴的喜悦程度分别是 a1′,a2′,…,an′ a&#x27;_1, a&#x27;_2, \\ldots, a&#x27;_n a​1​′​​,a​2​′​​,…,a​n​′​​，假设每对舞伴不协调程度分别是 b1′,b2′,…,bn′ b&#x27;_1, b&#x27;_2, \\ldots, b&#x27;_n b​1​′​​,b​2​′​​,…,b​n​′​​。令 C=a1′+a2′+⋯+an′b1′+b2′+⋯+bn′ C = \\frac{a&#x27;_1 + a&#x27;_2 + \\cdots + a&#x27;_n}{b&#x27;_1 + b&#x27;_2 + \\cdots + b&#x27;_n} C=​b​1​′​​+b​2​′​​+⋯+b​n​′​​​​a​1​′​​+a​2​′​​+⋯+a​n​′​​​​Cathy 希望 C 值最大。 题解题目要求最大化 ∑ai∑bi \\frac {\\sum a_i} {\\sum b_i} ​∑b​i​​​​∑a​i​​​​，考虑 01 01 01 分数规划。 二分一个答案 x x x，假设原式等于 x x x，则有： ∑ai∑bi=x \\frac {\\sum a_i} {\\sum b_i} = x ​∑b​i​​​​∑a​i​​​​=x移项，得： ∑ai−x∑bi=0 \\sum a_i - x\\sum b_i = 0 ∑a​i​​−x∑b​i​​=0同样的，可以得到若原式大于 x x x 或原式小于 x x x 的情况。我们求上式最大值以后和 x x x 比较即可。 最大化移项后的这个式子其实是一个二分图最大权匹配，这里我选择用费用流做法（其实就是不会什么 KM 辣。。）。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;climits&gt;#include &lt;cfloat&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;const double EPS = 1e-8;inline int dcmp(double x) &#123; if (fabs(x) &lt;= EPS) return 0; else return x &gt; 0 ? 1 : -1;&#125;inline bool equal(double a, double b) &#123; return !dcmp(a - b);&#125;const int MAX_N = 100;const int MAX_NODE_NUM = 2 * MAX_N + 2;const int MAX_EDGE_NUM = 2 * (MAX_N * MAX_N + 2 * MAX_N);const double NEG_INF = -1e18;namespace EK &#123; struct Node; struct Edge; struct Edge &#123; Node *fr, *to; int cap, flow; double cost; int rev; Edge(Node *fr, Node *to, int cap, double cost, int rev) : fr(fr), to(to), cap(cap), flow(0), cost(cost), rev(rev) &#123;&#125; &#125;; struct Node &#123; int flow; double dist; bool inq; std::vector&lt;Edge&gt; edges; Node *inNode; int inEdge; &#125; N[MAX_NODE_NUM]; inline void addEdge(int fr, int to, int cap, double cost) &#123; N[fr].edges.push_back(Edge(&amp;N[fr], &amp;N[to], cap, cost, N[to].edges.size())); N[to].edges.push_back(Edge(&amp;N[to], &amp;N[fr], 0, -cost, N[fr].edges.size() - 1)); &#125; int n; Node *s, *t; int maxFlow; double minCost; inline bool spfa() &#123; for (int i = 0; i &lt; n; i++) N[i].dist = NEG_INF; std::deque&lt;Node *&gt; q; q.push_back(s), s-&gt;dist = 0, s-&gt;inq = true, s-&gt;flow = INT_MAX; while (!q.empty()) &#123; Node *v = q.front(); q.pop_front(); v-&gt;inq = false; for (int i = 0, n = v-&gt;edges.size(); i &lt; n; i++) &#123; Edge *e = &amp;v-&gt;edges[i]; if (e-&gt;cap &gt; e-&gt;flow &amp;&amp; e-&gt;to-&gt;dist &lt; v-&gt;dist + e-&gt;cost) &#123; e-&gt;to-&gt;dist = v-&gt;dist + e-&gt;cost; e-&gt;to-&gt;inNode = v; e-&gt;to-&gt;inEdge = i; e-&gt;to-&gt;flow = std::min(v-&gt;flow, e-&gt;cap - e-&gt;flow); if (!e-&gt;to-&gt;inq) &#123; e-&gt;to-&gt;inq = true; if (q.empty() || e-&gt;to-&gt;dist &lt; q.front()-&gt;dist) q.push_front(e-&gt;to); else q.push_back(e-&gt;to); &#125; &#125; &#125; &#125; return !equal(t-&gt;dist, NEG_INF); &#125; inline void argument() &#123; int flow = t-&gt;flow; for (Edge *e = &amp;t-&gt;inNode-&gt;edges[t-&gt;inEdge]; ;) &#123; e-&gt;flow += flow; e-&gt;to-&gt;edges[e-&gt;rev].flow -= flow; if (e-&gt;fr-&gt;inNode) e = &amp;e-&gt;fr-&gt;inNode-&gt;edges[e-&gt;fr-&gt;inEdge]; else break; &#125; maxFlow += flow; minCost += t-&gt;dist * flow; &#125; inline void solve(int s, int t, int n) &#123; EK::maxFlow = 0, EK::minCost = 0; EK::s = &amp;N[s], EK::t = &amp;N[t], EK::n = n; while (spfa()) argument(); &#125; inline void clear(int n) &#123; for (int i = 0; i &lt; n; i++) N[i].edges.clear(); &#125;&#125;int n;int a[MAX_N + 1][MAX_N + 1], b[MAX_N + 1][MAX_N + 1];inline bool check(double bound) &#123; EK::clear(n * 2 + 2); int s = 0, t = n * 2 + 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; EK::addEdge(i, j + n, 1, a[i][j] - bound * b[i][j]); &#125; &#125; for (int i = 1; i &lt;= n; i++) EK::addEdge(s, i, 1, 0); for (int i = 1; i &lt;= n; i++) EK::addEdge(i + n, t, 1, 0); EK::solve(s, t, n * 2 + 2); return dcmp(EK::minCost) &gt;= 0;&#125;inline double solve() &#123; double l = 0, r = 1e4; while (r - l &gt; EPS) &#123; double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; &#125; return (l + r) / 2;&#125;int main() &#123;// freopen(\"ball.in\", \"r\", stdin);// freopen(\"ball.out\", \"w\", stdout); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) scanf(\"%d\", &amp;a[i][j]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) scanf(\"%d\", &amp;b[i][j]); printf(\"%.6lf\\n\", solve()); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"01分数规划","slug":"01分数规划","permalink":"http://sulfur6.github.io/tags/01分数规划/"},{"name":"二分图最大权匹配","slug":"二分图最大权匹配","permalink":"http://sulfur6.github.io/tags/二分图最大权匹配/"},{"name":"费用流","slug":"费用流","permalink":"http://sulfur6.github.io/tags/费用流/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「SDOI2017」序列计数 - DP，矩阵乘法，线性筛","slug":"sdoi2017-count","date":"2017-05-06T00:58:27.000Z","updated":"2017-06-02T13:36:56.000Z","comments":true,"path":"sdoi2017-count/","link":"","permalink":"http://sulfur6.github.io/sdoi2017-count/","excerpt":"Alice 想要得到一个长度为 n n n 的序列，序列中的数都是不超过 m m m 的正整数，而且这 n n n 个数的和是 p p p 的倍数。 Alice 还希望，这 n n n 个数中，至少有一个数是质数。 Alice 想知道，有多少个序列满足她的要求。","text":"Alice 想要得到一个长度为 n n n 的序列，序列中的数都是不超过 m m m 的正整数，而且这 n n n 个数的和是 p p p 的倍数。 Alice 还希望，这 n n n 个数中，至少有一个数是质数。 Alice 想知道，有多少个序列满足她的要求。 题解考虑一个比较显然的 dp，设 f(i,j) f(i, j) f(i,j) 表示序列长度为 i i i，序列中元素模 p p p 的值为 j j j 时的方案数。这样考虑不到需要有质数的要求，那么考虑容斥，设 g(i,j) g(i, j) g(i,j) 表示的意义与 f(i,j) f(i, j) f(i,j) 相同，但是不允许选出的序列中的元素有质数。 这样最后的答案就是 f(n,0)−g(n,0) f(n, 0) - g(n, 0) f(n,0)−g(n,0)。 刚才 dp 的转移方程是平凡的： 可以观察到这是一个一维转移，可以使用矩阵乘法来优化转移。 考虑一个转移矩阵 A A A 和初始矩阵 F F F。 考虑构造转移矩阵，若 F F F 矩阵的形式如下： 我们以转移矩阵的第一行为例，若转移矩阵第一行形式如下： 我们应使得 ∑j=0p−1aj f(i,j)=f(i+1,0) \\sum\\limits_{j = 0}^{p - 1} a_j\\ f(i, j) = f(i + 1, 0) ​j=0​∑​p−1​​a​j​​ f(i,j)=f(i+1,0)也就是说，转移矩阵第一行的每个位置对应的应该是对于每个 j j j 能够使得 j+k,k∈[1,m]=0 j + k, k \\in [1, m] = 0 j+k,k∈[1,m]=0 的方案数。余下几行同理。 在这里注意一个细节，我们并不需要枚举 [1,m] [1, m] [1,m] 中的数来构造转移矩阵，我们可以预处理处 [1,m] [1, m] [1,m] 中的数模 p p p 后的结果，并统计每个结果的出现次数，这样枚举的复杂度就从 O(m) O(m) O(m) 减小到 O(p) O(p) O(p) 了。原来构造转移矩阵需要 O(mp) O(mp) O(mp) 这样优化以后只需要 O(p2) O(p^2) O(p​2​​)。 这是对于 f(i,j) f(i, j) f(i,j) 的处理。同理，如果要处理 g(i,j) g(i, j) g(i,j) 的话，只需要在构造转移矩阵的时候排除掉加上质数转移的情况，处理的方式是线筛出 [1,m] [1, m] [1,m] 中的质数，然后在上一步统计 [1,m] [1, m] [1,m] 中的数模 p p p 所得结果出现次数时分质数和非质数来讨论就可以了。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAX_N = 1e9;const int MAX_M = 2e7;const int MAX_P = 100;const int MAX_PRIME = 1270607;const int MOD = 20170408;bool isNotPrime[MAX_M + 1];int primes[MAX_PRIME + 1], cnt;int n, m, p;inline int get()&#123; int res = 1, Q = 1; char c; while ((c = getchar()) &lt; 48 || c &gt; 57) if (c == '-') Q = -1; if (Q) res = c-48; while ((c=getchar()) &gt;= 48 &amp;&amp; c &lt;= 57) res = res * 10 + c - 48; return res * Q;&#125;inline void sieve() &#123; isNotPrime[0] = isNotPrime[1] = true; for (int i = 1; i &lt;= MAX_M; i++) &#123; if (!isNotPrime[i]) primes[cnt++] = i; for (int j = 0; j &lt; cnt &amp;&amp; (long long)i * primes[j] &lt;= MAX_M; j++) &#123; isNotPrime[i * primes[j]] = true; if (i % primes[j] == 0) break; &#125; &#125;&#125;struct Matrix &#123; long long a[MAX_P][MAX_P]; int n, m; Matrix(int n, int m, bool unit = false) : n(n), m(m) &#123; memset(a, 0, sizeof(a)); if (unit) for (int i = 0; i &lt; n; i++) a[i][i] = 1; &#125;&#125;;Matrix operator*(const Matrix &amp;a, const Matrix &amp;b) &#123; Matrix res(a.n, b.m); for (int i = 0; i &lt; a.n; i++) &#123; for (int j = 0; j &lt; b.m; j++) &#123; for (int k = 0; k &lt; a.m; k++) &#123; res.a[i][j] += a.a[i][k] * b.a[k][j] % MOD; &#125; &#125; &#125; return res;&#125;Matrix pow(Matrix a, int n) &#123; Matrix res(a.n, a.n, true); for (; n; n &gt;&gt;= 1, a = a * a) if (n &amp; 1) res = res * a; return res;&#125;int primeCnt[MAX_P], nonPrimeCnt[MAX_P];inline int calc(bool flag) &#123; Matrix A(p, p), F(p, 1); for (int j = 0; j &lt; p; j++) &#123; for (int k = 0; k &lt; p; k++) &#123; A.a[(j + k) % p][j] = (primeCnt[k] * flag + nonPrimeCnt[k]) % MOD; &#125; &#125; A = pow(A, n); F.a[0][0] = 1; A = A * F; return A.a[0][0];&#125;int main() &#123; n = get(), m = get(), p = get(); sieve(); for (int i = 1; i &lt;= m; i++) &#123; if (isNotPrime[i]) nonPrimeCnt[i % p]++; else primeCnt[i % p]++; &#125; printf(\"%d\\n\", (calc(true) - calc(false) + MOD) % MOD); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.github.io/tags/DP/"},{"name":"矩阵乘法优化","slug":"矩阵乘法优化","permalink":"http://sulfur6.github.io/tags/矩阵乘法优化/"},{"name":"线性筛","slug":"线性筛","permalink":"http://sulfur6.github.io/tags/线性筛/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「SDOI2017」树点涂色 - LCT，线段树","slug":"sdoi2017-paint","date":"2017-05-06T00:58:23.000Z","updated":"2017-06-02T13:36:42.000Z","comments":true,"path":"sdoi2017-paint/","link":"","permalink":"http://sulfur6.github.io/sdoi2017-paint/","excerpt":"Bob 有一棵 n n n 个点的有根树，其中 1 1 1 号点是根节点。Bob 在每个节点上涂了颜色，并且每个点上的颜色不同。 定义一条路径的权值是，这条路径上的点（包括起点和终点）共有多少种不同的颜色。 Bob 可能会进行这几种操作： 1 x 1 \\ x 1 x，把点 x x x 到根节点的路径上的所有的点染上一种没有用过的新颜色； 2 x y 2 \\ x \\ y 2 x y，求 x x x 到 y y y 的路径的权值； 3 x 3 \\ x 3 x，在以 x x x 为根的子树中选择一个点，使得这个点到根节点的路径权值最大，求最大权值。 Bob 一共会进行 m m m 次操作。","text":"Bob 有一棵 n n n 个点的有根树，其中 1 1 1 号点是根节点。Bob 在每个节点上涂了颜色，并且每个点上的颜色不同。 定义一条路径的权值是，这条路径上的点（包括起点和终点）共有多少种不同的颜色。 Bob 可能会进行这几种操作： 1 x 1 \\ x 1 x，把点 x x x 到根节点的路径上的所有的点染上一种没有用过的新颜色； 2 x y 2 \\ x \\ y 2 x y，求 x x x 到 y y y 的路径的权值； 3 x 3 \\ x 3 x，在以 x x x 为根的子树中选择一个点，使得这个点到根节点的路径权值最大，求最大权值。 Bob 一共会进行 m m m 次操作。 题解明显地，操作 1 1 1 对应的是 LCT 里的 access 操作，由于每次染上的颜色一定是一个没有出现过的颜色，所以说有两个比较明显的结论： LCT 中每条实路径上的颜色是相同的。 一个节点到根路径上颜色种类的数量等于它到根路径上虚边的个数。 这样，用线段树维护节点到根路径上的颜色种类数，access 时每次虚实边转换时，虚边变成实边的，子树中答案集体减一，实边变成虚边的，子树中答案集体加一。 对于操作 3 3 3，直接线段树查找子树最大就可以了。 对于操作 2 2 2，简单的 yy 一下以后可以发现，两个节点的颜色不可能同时和它们的 LCA 相同，所以 LCA 的颜色对答案的贡献一定是 1 1 1，这样，我们就把两个点到根路径上的颜色数各自减去 LCA 到根路径上的颜色数，然后再加上 LCA 贡献的 1 1 1 即可。 代码专业写挂线段树。 #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;const int MAX_N = 1e5;struct Node;struct Edge;struct Node &#123; Edge *e; Node *fa, *top, *maxc; int dep, size, min, max; bool vis;&#125; N[MAX_N + 1];struct Edge &#123; Node *to; Edge *ne; Edge(Node *fr, Node *to) : to(to), ne(fr-&gt;e) &#123;&#125;&#125;;inline void addEdge(int fr, int to) &#123; N[fr].e = new Edge(&amp;N[fr], &amp;N[to]); N[to].e = new Edge(&amp;N[to], &amp;N[fr]);&#125;int n, m;inline void split() &#123; std::stack&lt;Node *&gt; s; s.push(&amp;N[1]); N[1].dep = 1; while (!s.empty()) &#123; Node *v = s.top(); if (!v-&gt;vis) &#123; v-&gt;vis = true; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;to != v-&gt;fa) &#123; e-&gt;to-&gt;fa = v; e-&gt;to-&gt;dep = v-&gt;dep + 1; s.push(e-&gt;to); &#125; &#125; &#125; else &#123; v-&gt;size = 1; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;to-&gt;fa == v) &#123; v-&gt;size += e-&gt;to-&gt;size; if (!v-&gt;maxc || v-&gt;maxc-&gt;size &lt; e-&gt;to-&gt;size) v-&gt;maxc = e-&gt;to; &#125; &#125; s.pop(); &#125; &#125; for (int i = 1; i &lt;= n; i++) N[i].vis = false; int ts = 0; s.push(&amp;N[1]); while (!s.empty()) &#123; Node *v = s.top(); if (!v-&gt;vis) &#123; v-&gt;vis = true; v-&gt;min = ++ts; if (!v-&gt;fa || v != v-&gt;fa-&gt;maxc) v-&gt;top = v; else v-&gt;top = v-&gt;fa-&gt;top; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;to-&gt;fa == v &amp;&amp; e-&gt;to != v-&gt;maxc) &#123; s.push(e-&gt;to); &#125; &#125; if (v-&gt;maxc) s.push(v-&gt;maxc); &#125; else &#123; v-&gt;max = ts; s.pop(); &#125; &#125;&#125;int a[MAX_N + 1];struct Segt &#123; int l, r; Segt *lc, *rc; int max; int tag; Segt(int l, int r, Segt *lc, Segt *rc) : l(l), r(r), lc(lc), rc(rc), max(std::max(lc-&gt;max, rc-&gt;max)), tag(0) &#123;&#125; Segt(int l, int r, Segt *lc, Segt *rc, int max) : l(l), r(r), lc(lc), rc(rc), max(max), tag(0) &#123;&#125; void maintain() &#123; max = std::max(lc-&gt;max, rc-&gt;max); &#125; void add(int x) &#123; max += x; tag += x; &#125; void pushDown() &#123; if (tag) &#123; lc-&gt;add(tag); rc-&gt;add(tag); tag = 0; &#125; &#125; void modify(int l, int r, int val) &#123; if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) add(val); else pushDown(), lc-&gt;modify(l, r, val), rc-&gt;modify(l, r, val), maintain(); &#125; int query(int pos) &#123; if (l == r) return max; else &#123; pushDown(); int mid = l + (r - l) / 2; if (pos &lt;= mid) return lc-&gt;query(pos); else if (pos &gt; mid) return rc-&gt;query(pos); &#125; &#125; int query(int l, int r) &#123; if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return max; else return pushDown(), std::max(lc-&gt;query(l, r), rc-&gt;query(l, r)); &#125; static Segt *build(int l, int r) &#123; if (l == r) return new Segt(l, r, NULL, NULL, N[a[l]].dep); else &#123; int mid = l + (r - l) / 2; return new Segt(l, r, build(l, mid), build(mid + 1, r)); &#125; &#125;&#125; *segt;struct LinkCutTree &#123; struct Node &#123; Node *c[2], *fa, *pathFa, *min; int begin, end; Node() : min(this) &#123;&#125; void maintain() &#123; if (c[0]) min = c[0]-&gt;min; else min = this; &#125; int relation() &#123; return this == fa-&gt;c[1]; &#125; void rotate() &#123; std::swap(pathFa, fa-&gt;pathFa); Node *old = fa; int x = relation(); fa = old-&gt;fa; if (old-&gt;fa) old-&gt;fa-&gt;c[old-&gt;relation()] = this; old-&gt;c[x] = c[x ^ 1]; if (c[x ^ 1]) c[x ^ 1]-&gt;fa = old; c[x ^ 1] = old; old-&gt;fa = this; old-&gt;maintain(), maintain(); &#125; void splay() &#123; while (fa) &#123; if (!fa-&gt;fa) rotate(); else if (fa-&gt;relation() == relation()) fa-&gt;rotate(), rotate(); else rotate(), rotate(); &#125; &#125; void expose() &#123; splay(); if (c[1]) &#123; segt-&gt;modify(c[1]-&gt;min-&gt;begin, c[1]-&gt;min-&gt;end, +1); std::swap(c[1]-&gt;fa, c[1]-&gt;pathFa); c[1] = NULL; &#125; &#125; bool splice() &#123; splay(); if (!pathFa) return false; segt-&gt;modify(this-&gt;min-&gt;begin, this-&gt;min-&gt;end, -1); pathFa-&gt;expose(); pathFa-&gt;c[1] = this; std::swap(fa, pathFa); return true; &#125; void access() &#123; expose(); while (splice()); &#125; &#125; N[MAX_N + 1]; void link(int x, int fa) &#123; Node *v = &amp;N[x], *par = &amp;N[fa]; v-&gt;pathFa = par; &#125; void init() &#123; for (int i = 1; i &lt;= n; i++) &#123; N[i].begin = ::N[i].min, N[i].end = ::N[i].max; if (::N[i].fa) link(i, static_cast&lt;int&gt;(::N[i].fa - ::N)); &#125; &#125; void change(int x) &#123; Node *v = &amp;N[x]; v-&gt;access(); &#125;&#125; lct;inline void change(int x) &#123; lct.change(x);&#125;inline int queryMax(int x) &#123; return segt-&gt;query(N[x].min, N[x].max);&#125;inline Node *lca(Node *u, Node *v) &#123; while (u-&gt;top != v-&gt;top) &#123; if (u-&gt;top-&gt;dep &lt; v-&gt;top-&gt;dep) std::swap(u, v); u = u-&gt;top-&gt;fa; &#125; if (u-&gt;dep &lt; v-&gt;dep) return u; else return v;&#125;inline int query(int a, int b) &#123; Node *u = &amp;N[a], *v = &amp;N[b]; Node *p = lca(u, v); return segt-&gt;query(u-&gt;min) + segt-&gt;query(v-&gt;min) - segt-&gt;query(p-&gt;min) * 2 + 1;&#125;int main() &#123;// freopen(\"paint.in\", \"r\", stdin);// freopen(\"paint.out\", \"w\", stdout); scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); addEdge(u, v); &#125; split(); lct.init(); for (int i = 1; i &lt;= n; i++) a[N[i].min] = i; segt = Segt::build(1, n); for (int i = 1; i &lt;= m; i++) &#123; int cmd, x, y; scanf(\"%d\", &amp;cmd); if (cmd == 1) &#123; scanf(\"%d\", &amp;x); change(x); &#125; else if (cmd == 2) &#123; scanf(\"%d %d\", &amp;x, &amp;y); printf(\"%d\\n\", query(x, y)); &#125; else if (cmd == 3) &#123; scanf(\"%d\", &amp;x); printf(\"%d\\n\", queryMax(x)); &#125; else throw \"%%%Menci\"; &#125; fclose(stdin), fclose(stdout); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://sulfur6.github.io/tags/线段树/"},{"name":"LCT","slug":"LCT","permalink":"http://sulfur6.github.io/tags/LCT/"},{"name":"LCA","slug":"LCA","permalink":"http://sulfur6.github.io/tags/LCA/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「SDOI2017」数字表格 - 莫比乌斯反演","slug":"sdoi2017-product","date":"2017-05-06T00:58:20.000Z","updated":"2017-06-02T13:36:28.000Z","comments":true,"path":"sdoi2017-product/","link":"","permalink":"http://sulfur6.github.io/sdoi2017-product/","excerpt":"Doris 刚刚学习了 fibnacci 数列，用 f[i] f[i] f[i] 表示数列的第 i i i 项，那么： f[0]=0f[1]=1f[n]=f[n−1]+f[n−2],n≥2 \\begin{aligned} f[0] &amp;= 0 \\\\\\\\ f[1] &amp;= 1 \\\\\\\\ f[n] &amp;= f[n - 1] + f[n - 2], n \\geq 2 \\end{aligned} ​f[0]​​f[1]​​f[n]​​​=0​=1​=f[n−1]+f[n−2],n≥2​​Doris 用老师的超级计算机生成了一个 n×m n \\times m n×m 的表格，第 i i i 行第 j j j 列的格子中的数是 f[gcd(i,j)] f[\\gcd(i, j)] f[gcd(i,j)]，其中 gcd(i,j) \\gcd(i, j) gcd(i,j) 表示 i i i 与 j j j 的最大公约数。 Doris 的表格中共有 n×m n \\times m n×m 个数，她想知道这些数的乘积是多少。 这些数的乘积实在是太大了，所以 Doris 只想知道乘积对 1000000007 1000000007 1000000007 取模后的结果。","text":"Doris 刚刚学习了 fibnacci 数列，用 f[i] f[i] f[i] 表示数列的第 i i i 项，那么： f[0]=0f[1]=1f[n]=f[n−1]+f[n−2],n≥2 \\begin{aligned} f[0] &amp;= 0 \\\\\\\\ f[1] &amp;= 1 \\\\\\\\ f[n] &amp;= f[n - 1] + f[n - 2], n \\geq 2 \\end{aligned} ​f[0]​​f[1]​​f[n]​​​=0​=1​=f[n−1]+f[n−2],n≥2​​Doris 用老师的超级计算机生成了一个 n×m n \\times m n×m 的表格，第 i i i 行第 j j j 列的格子中的数是 f[gcd(i,j)] f[\\gcd(i, j)] f[gcd(i,j)]，其中 gcd(i,j) \\gcd(i, j) gcd(i,j) 表示 i i i 与 j j j 的最大公约数。 Doris 的表格中共有 n×m n \\times m n×m 个数，她想知道这些数的乘积是多少。 这些数的乘积实在是太大了，所以 Doris 只想知道乘积对 1000000007 1000000007 1000000007 取模后的结果。 题解反演一下就好啦。 设 n n n 为 n,m n, m n,m 中的较小值，首先，题目要求求的式子是 ∏i=1n∏j=1mf(gcd((i,j)) \\prod\\limits_{i = 1}^{n} \\prod\\limits_{j = 1}^{m} f(\\gcd((i, j)) ​i=1​∏​n​​​j=1​∏​m​​f(gcd((i,j))考虑枚举一个 d d d 使得 d d d 作为 gcd(i,j) \\gcd(i, j) gcd(i,j) 的值，原式可化为 ∏d=1nf(d)∑i=1n∑j=1m[gcd(i,j)=d] \\prod\\limits_{d = 1}^{n} f(d) ^ {\\sum\\limits_{i = 1}^{n} \\sum\\limits_{j = 1}^{m} [\\gcd(i, j) = d]} ​d=1​∏​n​​f(d)​​i=1​∑​n​​​j=1​∑​m​​[gcd(i,j)=d]​​把幂指数单独拿下来处理 ∑i=1n∑j=1m[gcd(i,j)=d] \\sum\\limits_{i = 1}^{n} \\sum\\limits_{j = 1}^{m} [\\gcd(i, j) = d] ​i=1​∑​n​​​j=1​∑​m​​[gcd(i,j)=d]将 i,j i, j i,j 同时除以 d d d 得 ∑i=1n∑j=1m[gcd(⌊id⌋⌊jd⌋)=1] \\sum\\limits_{i = 1}^{n} \\sum\\limits_{j = 1}^{m} [\\gcd(\\lfloor \\frac i d \\rfloor \\lfloor \\frac j d \\rfloor) = 1] ​i=1​∑​n​​​j=1​∑​m​​[gcd(⌊​d​​i​​⌋⌊​d​​j​​⌋)=1]更改求和指标，设 N=⌊nd⌋,M=⌊md⌋ N = \\lfloor \\frac n d \\rfloor, M = \\lfloor \\frac m d \\rfloorN=⌊​d​​n​​⌋,M=⌊​d​​m​​⌋ ∑i=1N∑j=1M[gcd(i,j)=1] \\sum\\limits_{i = 1}^{N} \\sum\\limits_{j = 1}^{M} [\\gcd(i, j) = 1] ​i=1​∑​N​​​j=1​∑​M​​[gcd(i,j)=1]把 [gcd(i,j)=1] [\\gcd(i, j) = 1] [gcd(i,j)=1] 卷一下 ∑i=1N∑j=1M∑p[p∣gcd(i,j)]μ(p) \\sum\\limits_{i = 1}^{N} \\sum\\limits_{j = 1}^{M} \\sum\\limits_{p} [p | \\gcd(i, j)]\\mu(p) ​i=1​∑​N​​​j=1​∑​M​​​p​∑​​[p∣gcd(i,j)]μ(p)更改求和顺序，改为先枚举 p p p ∑p=1N∑i=1N∑j=1M[p∣gcd(i,j)] \\sum\\limits_{p = 1}^{N} \\sum\\limits_{i = 1}^{N} \\sum\\limits_{j = 1}^{M} [p | \\gcd(i, j)] ​p=1​∑​N​​​i=1​∑​N​​​j=1​∑​M​​[p∣gcd(i,j)]p ∣gcd(i,j) p\\ | \\gcd(i, j) p ∣gcd(i,j) 的充要条件是 p ∣ i∧p ∣ j p\\ |\\ i \\wedge p\\ |\\ j p ∣ i∧p ∣ j ∑p=1Nμ(p)∑i=1N[p ∣ i]∑j=1M[p ∣ j] \\sum\\limits_{p = 1}^{N} \\mu(p) \\sum\\limits_{i = 1}^{N}[p\\ |\\ i]\\sum\\limits_{j = 1}^{M} [p\\ |\\ j] ​p=1​∑​N​​μ(p)​i=1​∑​N​​[p ∣ i]​j=1​∑​M​​[p ∣ j]可以转化为 ∑p=1Nμ(p)⌊Np⌋⌊Mp⌋ \\sum\\limits_{p = 1}^{N} \\mu(p) \\lfloor \\frac N p \\rfloor \\lfloor \\frac M p \\rfloor ​p=1​∑​N​​μ(p)⌊​p​​N​​⌋⌊​p​​M​​⌋预处理 μ \\mu μ 的前缀和，数论分块求。 回到一开始的式子，上式可以看做一个函数 g(N,M) g(N, M) g(N,M)，其中 N=⌊nd⌋,M=⌊md⌋ N = \\lfloor \\frac n d \\rfloor, M = \\lfloor \\frac m d \\rfloor N=⌊​d​​n​​⌋,M=⌊​d​​m​​⌋。 这样，预处理斐波那契数列前缀积，对于指数上的这个函数，也可以进行数论分块。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#define min(a, b) ((a) &lt; (b) ? (a) : (b))const int MAX_N = 1e6;const int MOD = 1e9 + 7;int primes[MAX_N + 1], mu[MAX_N + 1], mus[MAX_N + 1], cnt;bool isNotPrime[MAX_N + 1];inline void sieve() &#123; isNotPrime[0] = isNotPrime[1] = true; mu[1] = 1; for (int i = 2; i &lt;= MAX_N; i++) &#123; if (!isNotPrime[i]) &#123; primes[cnt++] = i; mu[i] = -1; &#125; for (int j = 0; j &lt; cnt &amp;&amp; (long long)i * primes[j] &lt;= MAX_N; j++) &#123; int p = primes[j]; isNotPrime[i * p] = true; if (i % p == 0) &#123; mu[i * p] = 0; break; &#125; else &#123; mu[i * p] = -mu[i]; &#125; &#125; &#125; for (int i = 1; i &lt;= MAX_N; i++) mus[i] = mus[i - 1] + mu[i];&#125;inline void exgcd(long long a, long long b, long long &amp;g, long long &amp;x, long long &amp;y) &#123; if (!b) g = a, x = 1, y = 0; else exgcd(b, a % b, g, y, x), y -= x * (a / b);&#125;inline long long inv(long long x) &#123; long long r, g, tmp; exgcd(x, MOD, g, r, tmp); return (r % MOD + MOD) % MOD;&#125;long long fib[MAX_N + 1], fibProd[MAX_N + 1], fibProdInv[MAX_N + 1];inline void prepare() &#123; fib[0] = 0, fib[1] = 1; for (int i = 2; i &lt;= MAX_N; i++) fib[i] = (fib[i - 1] + fib[i - 2]) % MOD; fibProd[0] = fibProdInv[0] = 1; for (int i = 1; i &lt;= MAX_N; i++) &#123; fibProd[i] = fibProd[i - 1] * fib[i] % MOD; fibProdInv[i] = inv(fibProd[i]); &#125;&#125;inline long long g(int N, int M) &#123; long long res = 0; for (int l = 1, r; l &lt;= N; l = r + 1) &#123; r = min(N / (N / l), M / (M / l)); res += (long long)(mus[r] - mus[l - 1]) * (N / l) * (M / l); &#125; return res;&#125;inline int pow(long long a, long long n) &#123; long long res = 1; for (; n; n &gt;&gt;= 1, a = a * a % MOD) if (n &amp; 1) res = res * a % MOD; return res;&#125;inline int calc(int N, int M, int l, int r) &#123; return pow(fibProd[r] * fibProdInv[l - 1] % MOD, g(N, M));&#125;inline int solve(int n, int m) &#123; if (n &gt; m) std::swap(n, m); long long res = 1; for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); (res *= calc(n / l, m / l, l, r)) %= MOD; &#125; return res;&#125;int main() &#123; freopen(\"product.in\", \"r\", stdin); freopen(\"product.out\", \"w\", stdout); int T_T; scanf(\"%d\", &amp;T_T); sieve(); prepare(); while (T_T--) &#123; int n, m; scanf(\"%d %d\", &amp;n, &amp;m); printf(\"%d\\n\", solve(n, m)); &#125;&#125;1. 1. 1. 1.","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"数论函数","slug":"数论函数","permalink":"http://sulfur6.github.io/tags/数论函数/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"http://sulfur6.github.io/tags/莫比乌斯反演/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「SDOI2011」染色 - 树链剖分，线段树","slug":"bzoj2243","date":"2017-04-30T15:05:02.000Z","updated":"2017-06-02T13:41:02.000Z","comments":true,"path":"bzoj2243/","link":"","permalink":"http://sulfur6.github.io/bzoj2243/","excerpt":"给定一棵 n n n 个节点的树，每个节点上有颜色，要求支持两种操作： 询问两点 (u,v) (u, v) (u,v) 之间有多少段颜色 将两点 (u,v) (u, v) (u,v) 之间所有的节点的颜色染成 c c c","text":"给定一棵 n n n 个节点的树，每个节点上有颜色，要求支持两种操作： 询问两点 (u,v) (u, v) (u,v) 之间有多少段颜色 将两点 (u,v) (u, v) (u,v) 之间所有的节点的颜色染成 c c c 题解树链剖分线段树维护，注意线段树每个节点要维护这个区间最左边和最右边位置上节点的颜色，两段区间的答案合并时如果左区间的最右节点和右区间的最左节点颜色相同的话答案要减 1 1 1。 树剖统计答案的时候也要注意这一点。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;stack&gt;#include &lt;algorithm&gt; const int MAX_N = 100000; struct Node;struct Edge; int a[MAX_N + 1]; struct Node &#123; Edge *e; Node *fa, *top, *maxc; int col, dep, size, dfn; bool vis;&#125; N[MAX_N + 1]; struct Edge &#123; Node *to; Edge *ne; Edge(Node *fr, Node *to) : to(to), ne(fr-&gt;e) &#123;&#125;&#125;; inline void addEdge(int fr, int to) &#123; N[fr].e = new Edge(&amp;N[fr], &amp;N[to]); N[to].e = new Edge(&amp;N[to], &amp;N[fr]);&#125; void dfs1(Node *v) &#123; v-&gt;size = 1; v-&gt;vis = true; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (!e-&gt;to-&gt;vis) &#123; e-&gt;to-&gt;dep = v-&gt;dep + 1; e-&gt;to-&gt;fa = v; dfs1(e-&gt;to); v-&gt;size += e-&gt;to-&gt;size; if (!v-&gt;maxc || e-&gt;to-&gt;size &gt; v-&gt;maxc-&gt;size) v-&gt;maxc = e-&gt;to; &#125; &#125;&#125; void dfs2(Node *v) &#123; static int ts = 0; v-&gt;dfn = ++ts; if (!v-&gt;fa || v != v-&gt;fa-&gt;maxc) v-&gt;top = v; else v-&gt;top = v-&gt;fa-&gt;top; if (v-&gt;maxc) dfs2(v-&gt;maxc); for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;to-&gt;fa == v &amp;&amp; e-&gt;to != v-&gt;maxc) dfs2(e-&gt;to); &#125;&#125; void split(Node *root) &#123; root-&gt;dep = 1; dfs1(root); dfs2(root);&#125; struct Segt &#123; int l, r; Segt *lc, *rc; int sum, tag; int lcol, rcol; Segt(int l, int r, Segt *lc, Segt *rc, int sum = 0, int lcol = -1, int rcol = -1) : l(l), r(r), lc(lc), rc(rc), sum(sum), tag(-1), lcol(lcol), rcol(rcol) &#123;&#125; void maintain() &#123; if (lc-&gt;rcol == rc-&gt;lcol) sum = lc-&gt;sum + rc-&gt;sum - 1; else sum = lc-&gt;sum + rc-&gt;sum; lcol = lc-&gt;lcol, rcol = rc-&gt;rcol; &#125; void change(int col) &#123; sum = 1; lcol = rcol = col; tag = col; &#125; void pushDown() &#123; if (tag != -1) &#123; lc-&gt;change(tag); rc-&gt;change(tag); tag = -1; &#125; &#125; void modify(int l, int r, int col) &#123; if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) change(col); else pushDown(), lc-&gt;modify(l, r, col), rc-&gt;modify(l, r, col), maintain(); &#125; int query(int l, int r) &#123; if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return sum; else &#123; pushDown(); int mid = this-&gt;l + (this-&gt;r - this-&gt;l) / 2; if (l &gt; mid) return rc-&gt;query(l, r); else if (r &lt;= mid) return lc-&gt;query(l, r); else &#123; int lsum = lc-&gt;query(l, r), rsum = rc-&gt;query(l, r); if (lc-&gt;rcol == rc-&gt;lcol) return lsum + rsum - 1; else return lsum + rsum; &#125; &#125; &#125; int query(int pos) &#123; if (l == r) return lcol; else &#123; pushDown(); int mid = l + (r - l) / 2; if (pos &lt;= mid) return lc-&gt;query(pos); else return rc-&gt;query(pos); &#125; &#125; static Segt *build(int l, int r) &#123; if (l == r) return new Segt(l, r, NULL, NULL, 1, a[l], a[r]); else &#123; int mid = l + (r - l) / 2; Segt *v = new Segt(l, r, build(l, mid), build(mid + 1, r)); v-&gt;maintain(); return v; &#125; &#125;&#125; *segt; inline void change(int a, int b, int c) &#123; Node *u = &amp;N[a], *v = &amp;N[b]; while (u-&gt;top != v-&gt;top) &#123; if (u-&gt;top-&gt;dep &lt; v-&gt;top-&gt;dep) std::swap(u, v); segt-&gt;modify(u-&gt;top-&gt;dfn, u-&gt;dfn, c); u = u-&gt;top-&gt;fa; &#125; if (u-&gt;dep &gt; v-&gt;dep) std::swap(u, v); segt-&gt;modify(u-&gt;dfn, v-&gt;dfn, c);&#125; inline int query(int a, int b) &#123; Node *u = &amp;N[a], *v = &amp;N[b]; int res = 0; while (u-&gt;top != v-&gt;top) &#123; if (u-&gt;top-&gt;dep &lt; v-&gt;top-&gt;dep) std::swap(u, v); res += segt-&gt;query(u-&gt;top-&gt;dfn, u-&gt;dfn); if (segt-&gt;query(u-&gt;top-&gt;dfn) == segt-&gt;query(u-&gt;top-&gt;fa-&gt;dfn)) res--; u = u-&gt;top-&gt;fa; &#125; if (u-&gt;dep &gt; v-&gt;dep) std::swap(u, v); res += segt-&gt;query(u-&gt;dfn, v-&gt;dfn); return res;&#125; int main() &#123;// freopen(\"data.in\", \"r\", stdin); int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;N[i].col); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); addEdge(u, v); &#125; split(&amp;N[1]); for (int i = 1; i &lt;= n; i++) &#123; a[N[i].dfn] = N[i].col; &#125; segt = Segt::build(1, n); for (int i = 1; i &lt;= m; i++) &#123; char cmd[2]; scanf(\"%s\", cmd); if (cmd[0] == 'C') &#123; int a, b, c; scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); change(a, b, c); &#125; else if (cmd[0] == 'Q') &#123; int a, b; scanf(\"%d %d\", &amp;a, &amp;b); printf(\"%d\\n\", query(a, b)); &#125; &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://sulfur6.github.io/tags/线段树/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://sulfur6.github.io/tags/BZOJ/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://sulfur6.github.io/tags/树链剖分/"},{"name":"SDOI","slug":"SDOI","permalink":"http://sulfur6.github.io/tags/SDOI/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「NOIP2016」天天爱跑步","slug":"NOIP2016-running","date":"2017-04-30T08:14:42.000Z","updated":"2017-06-02T13:34:38.000Z","comments":true,"path":"NOIP2016-running/","link":"","permalink":"http://sulfur6.github.io/NOIP2016-running/","excerpt":"小 C 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。 这个游戏的地图可以看作一棵包含 n n n 个结点和 n−1 n - 1 n−1 条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从 1 1 1 到 n n n 的连续正整数。 现在有 m m m 个玩家，第 i i i 个玩家的起点为 Si S_i S​i​​，终点为 Ti T_i T​i​​。每天打卡任务开始时，所有玩家在第 0 0 0 秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的） 小 C 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 j j j 的观察员会选择在第 Wj W_j W​j​​ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 Wj W_j W​j​​ 秒也理到达了结点 j j j。小 C 想知道每个观察员会观察到多少人？ 注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一段时间后再被观察员观察到。即对于把结点 j j j 作为终点的玩家：若他在第 Wj W_j W​j​​ 秒前到达终点，则在结点 j j j 的观察员不能观察到该玩家；若他正好在第 Wj W_j W​j​​ 秒到达终点，则在结点 j j j 的观察员可以观察到这个玩家。","text":"小 C 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。 这个游戏的地图可以看作一棵包含 n n n 个结点和 n−1 n - 1 n−1 条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从 1 1 1 到 n n n 的连续正整数。 现在有 m m m 个玩家，第 i i i 个玩家的起点为 Si S_i S​i​​，终点为 Ti T_i T​i​​。每天打卡任务开始时，所有玩家在第 0 0 0 秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的） 小 C 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 j j j 的观察员会选择在第 Wj W_j W​j​​ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 Wj W_j W​j​​ 秒也理到达了结点 j j j。小 C 想知道每个观察员会观察到多少人？ 注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一段时间后再被观察员观察到。即对于把结点 j j j 作为终点的玩家：若他在第 Wj W_j W​j​​ 秒前到达终点，则在结点 j j j 的观察员不能观察到该玩家；若他正好在第 Wj W_j W​j​​ 秒到达终点，则在结点 j j j 的观察员可以观察到这个玩家。 题目链接LYOI#100 题解首先考虑在序列上的做法。 假设现在我们的序列是一个 [0,L) [0, L) [0,L) 的序列，那么对于每一个玩家 (Si,Ti) (S_i, T_i) (S​i​​,T​i​​) ，有两种情况。 当 Si&lt;Ti S_i &lt; T_i S​i​​&lt;T​i​​ 时，只有在序列的 [Si,Ti] [S_i, T_i] [S​i​​,T​i​​] 这段区间内的某个 j j j 才有可能观察到这个玩家。 考虑在位置 j j j 的观察员观察到玩家 i i i 的充要条件，就是玩家 i i i 到达位置 j j j 的时间等于位置 j j j 的观察员出现的时间，即 Wj W_j W​j​​，又因为相邻两个点的距离和玩家的速度都为 1 1 1 ，所以上述条件可以用式子表示出来，即 j−Si=Wj j - S_i = W_j j−S​i​​=W​j​​，移项后得 j−Wj=Si j - W_j = S_i j−W​j​​=S​i​​。 对于一个确定的点，它的 j−Wj j - W_j j−W​j​​ 是确定的，也就是说这种情况的问题转化为，设 Xj=j−Wj X_j = j - W_j X​j​​=j−W​j​​ 区间加一个数，然后对于区间中的某个节点 j j j 询问该位置上的数等于 Xj X_j X​j​​ 的个数。这个问题我们可以用差分化思想解决，即对于需要添加的一个数，在位置 S S S 把它加上，在位置 T+1 T + 1 T+1 把它删去。 当 Si&gt;Tj S_i &gt; T_j S​i​​&gt;T​j​​ 时，仍可以用差分化思想解决，只不过这个时候能够观察到的先决条件变为 Si−j=Wj S_i - j = W_j S​i​​−j=W​j​​。我们设 Xj=j+Wj X_j = j + W_j X​j​​=j+W​j​​，按照上述做法来做即可。 问题转移到树上，考虑树链剖分。 把每一条链看成是一个序列，链上深度最小的点的位置为 0 0 0，向下位置递增，向上位置为负。 这样可以把每个玩家的运动过程拆成从 S S S 到 lca(S,T) lca(S, T) lca(S,T) 的第一部分以及从 lca(S,T) lca(S, T) lca(S,T) 到 T T T 的第二部分。 对于第一部分的每一条链上的情况，把它看作是 S&gt;T S &gt; T S&gt;T 的情况，第二部分的每一条链上的情况，把它看作是 S&lt;T S &lt; T S&lt;T 的情况。 我们记链上每个节点的位置为 id id id，其深度为 dep dep dep，两点之间的距离为 dist dist dist。 具体来讲，对于第一种情况，考虑链上的深度最大的由 S S S 到 lca lca lca 的必经点，记为 u u u，由它向上走到链上任意深度大于 lca(S,T) lca(S, T) lca(S,T) 的点上的观察员都是可能观察到这位玩家的。由它向上走到的某一个合法的，链上坐标为 j j j 的点能观察到这个玩家的充要条件是，由 S S S 到 u u u 的距离加上从 u u u 到 j j j 的距离等于 Wj W_j W​j​​，即 dist(S,u)+dist(u,j) dist(S, u) + dist(u, j) dist(S,u)+dist(u,j)。用已知的量表示出来就是 S.dep−u.dep+u.id−j.id=Wj S.dep - u.dep + u.id - j.id = W_j S.dep−u.dep+u.id−j.id=W​j​​。 对于第二种情况，在某条链上，将 S S S 的坐标看成一个负值，则它的坐标应该是从 S S S 到这条链顶端节点的距离的相反数，我们将原有的条件取反，则得到 S=Wj−j S = W_j - j S=W​j​​−j。 本来想画个图的，但是感觉让我画图还不如让我干说（其实是写题解的时候找不到画图工具了。。），不过有时间会补上图的。具体实现细节见代码吧。还有我的代码在洛谷上是过不去的。。本身 nlogn n\\log n nlogn 的复杂度就有点不靠谱。。不过如果您会 ____ 的 ____ 的话树剖当然稳稳过啦。 其实这个题有 O(n+m) O(n + m) O(n+m) 的做法，只不过我目前还没有去看 qwq （其实就是懒找什么借口），如果写出线性做法的话再更新辣。 感觉自己是真的菜，NOIP2016 爆炸以后这么久才填完坑。。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;new&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;const int MAX_N = 300000;int n, m;struct Tag &#123; int x; bool del; Tag(bool del, int x) : x(x), del(del) &#123;&#125;&#125;;struct Node;struct Edge;struct Chain;struct Node &#123; Edge *e; Node *fa, *maxc; Chain *chain; int size, dep, dfn, id, w, x, ans; bool vis; std::vector&lt;Tag&gt; forwTag, bacwTag;&#125; N[MAX_N];struct Edge &#123; Node *fr, *to; Edge *ne; Edge() &#123;&#125; Edge(Node *fr, Node *to) : fr(fr), to(to), ne(fr-&gt;e) &#123;&#125;&#125; _pool[MAX_N * 2], *_end;inline void addEdge(int fr, int to) &#123; N[fr].e = new (_end++) Edge(&amp;N[fr], &amp;N[to]); N[to].e = new (_end++) Edge(&amp;N[to], &amp;N[fr]);&#125;struct Chain &#123; Node *top, *bot; std::vector&lt;Node *&gt; nodes; int len;&#125; chains[MAX_N];int chainCnt = 0;template&lt;typename T&gt;struct Stack &#123; T s[MAX_N]; int tot; Stack() : tot(0) &#123;&#125; void push(T val) &#123; s[tot++] = val; &#125; void pop() &#123; tot--; &#125; bool empty() &#123; return tot == 0; &#125; T top() &#123; return s[tot - 1]; &#125;&#125;;Stack&lt;Node *&gt; s;inline void split() &#123;// std::stack&lt;Node *&gt; s; N[1].dep = 1; s.push(&amp;N[1]); while (!s.empty()) &#123; Node *v = s.top(); if (!v-&gt;vis) &#123; v-&gt;vis = true; v-&gt;size = 1; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;to != v-&gt;fa) &#123; e-&gt;to-&gt;fa = v; e-&gt;to-&gt;dep = v-&gt;dep + 1; s.push(e-&gt;to); &#125; &#125; &#125; else &#123; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;to-&gt;fa == v) &#123; v-&gt;size += e-&gt;to-&gt;size; if (!v-&gt;maxc || e-&gt;to-&gt;size &gt; v-&gt;maxc-&gt;size) v-&gt;maxc = e-&gt;to; &#125; &#125; s.pop(); &#125; &#125; for (int i = 1; i &lt;= n; i++) N[i].vis = false; s.push(&amp;N[1]); N[1].dep = 1; while (!s.empty()) &#123; Node *v = s.top(); if (!v-&gt;vis) &#123; v-&gt;vis = true; if (!v-&gt;fa || v != v-&gt;fa-&gt;maxc) &#123; v-&gt;chain = &amp;chains[chainCnt++]; v-&gt;chain-&gt;top = v; v-&gt;id = 0; &#125; else &#123; v-&gt;chain = v-&gt;fa-&gt;chain; v-&gt;id = v-&gt;fa-&gt;id + 1; &#125; v-&gt;chain-&gt;nodes.push_back(v); v-&gt;chain-&gt;bot = v; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;to-&gt;fa == v) s.push(e-&gt;to); &#125; &#125; else &#123; s.pop(); &#125; &#125; for (int i = 0; i &lt; chainCnt; i++) chains[i].len = chains[i].nodes.size();&#125;inline Node *lca(Node *u, Node *v) &#123; while (u-&gt;chain != v-&gt;chain) &#123; if (u-&gt;chain-&gt;top-&gt;dep &lt; v-&gt;chain-&gt;top-&gt;dep) std::swap(u, v); u = u-&gt;chain-&gt;top-&gt;fa; &#125; if (u-&gt;dep &gt; v-&gt;dep) return v; else return u;&#125;inline int dist(Node *u, Node *v, Node *p) &#123; return u-&gt;dep + v-&gt;dep - p-&gt;dep * 2;&#125;inline void addTag(bool forw, Chain *chain, int s, int t, int x) &#123; if (forw) &#123; if (s &gt; t) return; chain-&gt;nodes[s]-&gt;forwTag.push_back(Tag(false, x)); chain-&gt;nodes[t]-&gt;forwTag.push_back(Tag(true, x)); &#125; else &#123; if (s &lt; t) return; chain-&gt;nodes[s]-&gt;bacwTag.push_back(Tag(false, x)); chain-&gt;nodes[t]-&gt;bacwTag.push_back(Tag(true, x)); &#125;&#125;inline void play(Node *s, Node *t) &#123; if (s == t) &#123; if (s-&gt;w == 0) s-&gt;ans++; return; &#125; Node *p = lca(s, t), *u = s, *v = t; if (dist(s, p, p) == p-&gt;w) p-&gt;ans++; if (s != p) &#123; while (u-&gt;chain != p-&gt;chain) &#123; addTag(false, u-&gt;chain, u-&gt;id, 0, s-&gt;dep - u-&gt;dep + u-&gt;id); u = u-&gt;chain-&gt;top-&gt;fa; &#125; addTag(false, u-&gt;chain, u-&gt;id, p-&gt;id + 1, s-&gt;dep - u-&gt;dep + u-&gt;id); &#125; if (t != p) &#123; while (v-&gt;chain != p-&gt;chain) &#123; addTag(true, v-&gt;chain, 0, v-&gt;id, (s-&gt;dep - p-&gt;dep) + (v-&gt;chain-&gt;top-&gt;dep - p-&gt;dep)); v = v-&gt;chain-&gt;top-&gt;fa; &#125; addTag(true, v-&gt;chain, p-&gt;id + 1, v-&gt;id, (s-&gt;dep - p-&gt;dep) + (v-&gt;chain-&gt;top-&gt;dep - p-&gt;dep)); &#125;&#125;int _cnt[MAX_N * 4 + 1], *cnt = _cnt + MAX_N * 2;inline void solve() &#123; for (int i = 0; i &lt; chainCnt; i++) &#123; Chain &amp;chain = chains[i]; // forw on tree for (int j = 0; j &lt; chain.len; j++) &#123; for (std::vector&lt;Tag&gt;::const_iterator it = chain.nodes[j]-&gt;forwTag.begin(); it != chain.nodes[j]-&gt;forwTag.end(); it++) &#123; if (!it-&gt;del) cnt[it-&gt;x]++; &#125; chain.nodes[j]-&gt;ans += cnt[chain.nodes[j]-&gt;w - j]; for (std::vector&lt;Tag&gt;::const_iterator it = chain.nodes[j]-&gt;forwTag.begin(); it != chain.nodes[j]-&gt;forwTag.end(); it++) &#123; if (it-&gt;del) cnt[it-&gt;x]--; &#125; &#125; // bacw on tree for (int j = chain.len - 1; j &gt;= 0; j--) &#123; for (std::vector&lt;Tag&gt;::const_iterator it = chain.nodes[j]-&gt;bacwTag.begin(); it != chain.nodes[j]-&gt;bacwTag.end(); it++) &#123; if (!it-&gt;del) cnt[it-&gt;x]++; &#125; chain.nodes[j]-&gt;ans += cnt[chain.nodes[j]-&gt;w + j]; for (std::vector&lt;Tag&gt;::const_iterator it = chain.nodes[j]-&gt;bacwTag.begin(); it != chain.nodes[j]-&gt;bacwTag.end(); it++) &#123; if (it-&gt;del) cnt[it-&gt;x]--; &#125; &#125; &#125;&#125;int main() &#123; freopen(\"running.in\", \"r\", stdin); freopen(\"running.out\", \"w\", stdout); _end = _pool; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); addEdge(u, v); &#125; split(); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;N[i].w); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); play(&amp;N[u], &amp;N[v]); &#125; solve(); for (int i = 1; i &lt;= n; i++) printf(\"%d%c\", N[i].ans, i == n ? '\\n' : ' '); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"http://sulfur6.github.io/tags/树链剖分/"},{"name":"差分化标记","slug":"差分化标记","permalink":"http://sulfur6.github.io/tags/差分化标记/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"Link-Cut Tree 学习笔记","slug":"lct-note","date":"2017-04-02T14:48:46.000Z","updated":"2017-04-02T14:51:42.000Z","comments":true,"path":"lct-note/","link":"","permalink":"http://sulfur6.github.io/lct-note/","excerpt":"LCT 学习笔记，防忘","text":"LCT 学习笔记，防忘 动态树有一类问题，要求我们维护树上路径的信息，如果树是静态的，即树的结构是不会变的，树链剖分可以解决这类问题。但是如果要求支持我们修改树的结构，比如加边，删边等操作，树剖就 gg 了。。 这种动态维护树上信息的问题，我们称之为动态树问题，上述例子是比较简单的动态树问题，不存在对子树进行操作等丧心病狂的操作，所以我们可以用 Link-Cut Tree 来解决。 Link-Cut TreeLink-Cut Tree 是一种能在 O(logn) O(\\log n) O(logn) 的时间内解决上述问题的数据结构。 简单来说， LCT 与树链剖分一样，会对树中节点的儿子进行划分，轻重链剖分根据子树大小将节点的儿子分为轻儿子和重儿子， LCT 则会将儿子划分为实、虚两种儿子，相应的边被称为实边和虚边，而且任意时刻，一个节点最多会有一个实儿子，也可能没有。 与树剖不同的是， LCT 并不固定划分实虚儿子，由于树的形态不断改变，实虚儿子也有可能变化。 基本定义深度：深度越大，到根节点越远，反之亦然。 实边：一个非叶节点，向它的实儿子连的一条边叫做实边，向其他所有儿子连的边均为虚边。注意，一个非叶节点可以没有实儿子，此时它向所有儿子连边均为虚边。 实路径：由若干条实边首尾相连的，不可伸长的路径称之为实路径。实路径之间并非孤立的，各条实路径之间通过虚边连接。一条实路径中深度最小的点在树中的父节点被称之为实路径的父亲，在代码中用 pathFa 体现。 基本操作用 Splay 来维护实路径。由于实路径中的任意两个节点都是祖先和子孙的关系，则如果我们按照节点的深度进行排序，我们会得到一个唯一的有序深度序列，换言之，在某条实路径对应的 Splay 中，一个节点的左子树中的所有节点一定是其祖先，右子树中的所有子树一定是其子孙，这也是我们用Splay维护实路径的原因。 在实际维护中，并不需要真的在 Splay 中用维护有序集的方法去排序，我们只需要在修改 Splay 的时候满足其中序遍历满足我们的需求即可。 我们设 v 是树中某个节点，v.OPERATION可以使得这个节点进行OPERATION这个操作。 v.access 使得节点 v 到根节点的路径成为实路径。 节点 v v v 可能不是目前属实路径的尾部，所以我们将其旋转到其所属Splay的根节点，此时如果它有右子树，则它右子树中所有的节点都是它目前所处实路径的下方的节点，我们要断掉这条边（注意不是真的断掉，只是转换成虚边），要做的操作是将其右儿子的 pathFa 设成它，同时将其右儿子置空。 如果此时这条实路径包含根节点，操作结束 然后我们要做的是将以节点v为尾部的这条实路径和它的父亲相连，此时我们对这条实路径的父亲执行上述操作，并且将这条实路径的父亲向实路径的顶部节点的边置为实边，即在这条实路径对应的 Splay 中将原来的 pathFa 设为 fa 即可。 继续查询该实路径是否包含根节点，若不包含，则继续执行上述操作。 v.find 找到节点v所处这棵树的根节点。我们只需要执行v.access，此时节点v与根节点处在一条实路径中，而且根节点一定是深度最小的那个节点，所以查找实路径对应Splay的最左节点即可。 v.evert 将节点v置为整棵树的根首先我们将节点v和根置于一条实路径上，即执行v.access，此时我们只需让这条实路径反转即可将v置为整棵树的根。利用平衡树打标记处理即可。 注：维护根不变的树时，不需要此操作。 link(u, v) 将节点u和节点v连起来首先u.evert，然后将u所在实路径上的pathFa置成v即可。 注：这样操作，让节点u成为了节点v的儿子 cut(u, v) 删掉节点u和节点v之间的边 先u.evert使得u成为有根树的根节点，这样保证v一定是节点u的子节点，然后v.access，再将v旋转至Splay的根，这样如果原树中有边(u, v)，那么v的左子树一定只有u这个节点。 附上「BZOJ2049」洞穴勘探 的代码 #include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAXN = 10000;struct LinkCutTree &#123; struct Node &#123; Node *fa, *ch[2], *pathFa; bool rev; void pushDown() &#123; if (rev) &#123; std::swap(ch[0], ch[1]); if (ch[0]) ch[0]-&gt;rev ^= 1; if (ch[1]) ch[1]-&gt;rev ^= 1; rev = false; &#125; &#125; int relation() &#123; return this == fa-&gt;ch[1]; &#125; void rotate() &#123; pushDown(); std::swap(pathFa, fa-&gt;pathFa); Node *old = fa; int x = relation(); fa = old-&gt;fa; if (old-&gt;fa) old-&gt;fa-&gt;ch[old-&gt;relation()] = this; old-&gt;ch[x] = ch[x ^ 1]; if (ch[x ^ 1]) ch[x ^ 1]-&gt;fa = old; ch[x ^ 1] = old; old-&gt;fa = this; &#125; void splay() &#123; while (fa) &#123; if (fa-&gt;fa) fa-&gt;fa-&gt;pushDown(); fa-&gt;pushDown(); if (!fa-&gt;fa) rotate(); else if (fa-&gt;relation() == relation()) fa-&gt;rotate(), rotate(); else rotate(), rotate(); &#125; &#125; void expose() &#123; splay(); pushDown(); if (ch[1]) &#123; std::swap(ch[1]-&gt;pathFa, ch[1]-&gt;fa); ch[1] = NULL; &#125; &#125; bool splice() &#123; splay(); if (!pathFa) return false; pathFa-&gt;expose(); pathFa-&gt;ch[1] = this; std::swap(pathFa, fa); return true; &#125; void access() &#123; expose(); while (splice()); &#125; void evert() &#123; access(); splay(); rev ^= 1; &#125; &#125; N[MAXN + 1]; void link(int a, int b) &#123; Node *u = &amp;N[a], *v = &amp;N[b]; u-&gt;evert(); u-&gt;pathFa = v; &#125; void cut(int a, int b) &#123; Node *u = &amp;N[a], *v = &amp;N[b]; u-&gt;evert(); v-&gt;access(); u-&gt;splay(); u-&gt;pushDown(); u-&gt;ch[1] = NULL; v-&gt;fa = NULL; &#125; int find(int a) &#123; Node *v = &amp;N[a]; v-&gt;access(); v-&gt;splay(); while (v-&gt;pushDown(), v-&gt;ch[0]) v = v-&gt;ch[0]; return v - N; &#125;&#125; lct;int main() &#123; int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; char s[8]; int u, v; scanf(\"%s %d %d\", s, &amp;u, &amp;v); if (s[0] == 'C') lct.link(u, v); else if (s[0] == 'D') lct.cut(u, v); else if (s[0] == 'Q') puts(lct.find(u) == lct.find(v) ? \"Yes\" : \"No\"); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://sulfur6.github.io/tags/LCT/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://sulfur6.github.io/tags/学习笔记/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「SDOI2014」旅行","slug":"bzoj3531","date":"2017-02-21T12:42:47.000Z","updated":"2017-06-02T13:32:56.000Z","comments":true,"path":"bzoj3531/","link":"","permalink":"http://sulfur6.github.io/bzoj3531/","excerpt":"S国有 N N N 个城市，编号从1 1 1到N N N。城市间用N−1 N - 1 N−1条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。为了方便，我们用不同的正整数代表各种宗教，S国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S国政府为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。","text":"S国有 N N N 个城市，编号从1 1 1到N N N。城市间用N−1 N - 1 N−1条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。为了方便，我们用不同的正整数代表各种宗教，S国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S国政府为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。 在S国的历史上常会发生以下几种事件:CC x c：城市x x x的居民全体改信了c c c教;CW x w：城市x x x的评级调整为c c c;QS x y：一位旅行者从城市x x x出发，到城市y y y，并记下了途中留宿过的城市的评级总和；QM x y：一位旅行者从城市x x x出发，到城市y y y，并记下了途中留宿过的城市的评级最大值。 由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。 题解本题的主要限制在宗教，做法是对于每个宗教开一棵线段树。 显然地，如果一开始就把 c c c 棵线段树建好，那么一定会 MLE，所以我们要用线段树动态开点来搞，大意就是每次插入的时候沿路新建不存在的节点。 写法就是把线段树中的节点在修改中下传，若该节点为空，则新建它。 更改宗教时，将一个节点在原宗教线段树中的值设为 0 0 0 ，再将其插入新宗教线段树中。 顺便说一句，更改某个节点的值时不要只修改它在线段树中的值，别问我是怎么知道的。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;const int MAX_N = 100000;const int MAX_C = 100000;const int MAX_NODE_NUM = 3400000;struct SegmentTree &#123;#define mid ((l + r) &gt;&gt; 1) struct Node &#123; Node *lc, *rc; int sum, max; void init() &#123; lc = rc = NULL; sum = max = 0; &#125; void update() &#123; sum = (lc ? lc-&gt;sum : 0) + (rc ? rc-&gt;sum : 0); max = std::max(lc ? lc-&gt;max : 0, rc ? rc-&gt;max : 0); &#125; &#125;; static Node *newNode() &#123; static Node N[MAX_NODE_NUM], *_end = N; return _end-&gt;init(), _end++; &#125; Node *root; int L, R; SegmentTree(int l, int r) &#123; L = l, R = r, root = NULL; &#125; int querySum(Node *v, int l, int r, int ql, int qr) &#123; if (v == NULL) return 0; else if (l == ql &amp;&amp; r == qr) return v-&gt;sum; else if (mid &gt;= qr) return querySum(v-&gt;lc, l, mid, ql, qr); else if (mid &lt;= ql) return querySum(v-&gt;rc, mid, r, ql, qr); else return querySum(v-&gt;lc, l, mid, ql, mid) + querySum(v-&gt;rc, mid, r, mid, qr); &#125; int queryMax(Node *v, int l, int r, int ql, int qr) &#123; if (v == NULL) return 0; else if (l == ql &amp;&amp; r == qr) return v-&gt;max; else if (mid &gt;= qr) return queryMax(v-&gt;lc, l, mid, ql, qr); else if (mid &lt;= ql) return queryMax(v-&gt;rc, mid, r, ql, qr); else return std::max(queryMax(v-&gt;lc, l, mid, ql, mid), queryMax(v-&gt;rc, mid, r, mid, qr)); &#125; void modify(Node *&amp;v, int l, int r, int pos, int val) &#123; if (v == NULL) v = newNode(); if (r - l == 1) v-&gt;sum = v-&gt;max = val; else &#123; if (pos &lt; mid) modify(v-&gt;lc, l, mid, pos, val); else modify(v-&gt;rc, mid, r, pos, val); v-&gt;update(); &#125; &#125; int querySum(int l, int r) &#123; return querySum(root, L, R, l, r); &#125; int queryMax(int l, int r) &#123; return queryMax(root, L, R, l, r); &#125; void modify(int pos, int val) &#123; modify(root, L, R, pos, val); &#125;&#125; *segt[MAX_C + 1];struct Node;struct Edge;struct Node &#123; Edge *e; Node *fa, *maxChild, *pathFa; int dfn, depth, size; bool vis; int type, val;&#125; N[MAX_N + 5];struct Edge &#123; Node *fr, *to; Edge *ne; Edge() &#123;&#125; Edge(Node *fr, Node *to) : fr(fr), to(to), ne(fr-&gt;e) &#123;&#125;&#125;;inline void addEdge(int fr, int to) &#123; Node *u = &amp;N[fr], *v = &amp;N[to]; u-&gt;e = new Edge(u, v); v-&gt;e = new Edge(v, u);&#125;int n, c;inline void treeChainSplit(Node *root) &#123; std::stack&lt;Node *&gt; s; s.push(root), root-&gt;fa = NULL, root-&gt;depth = 0; while (!s.empty()) &#123; Node *v = s.top(); if (!v-&gt;vis) &#123; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;to != v-&gt;fa) &#123; e-&gt;to-&gt;fa = v, e-&gt;to-&gt;depth = v-&gt;depth + 1; s.push(e-&gt;to); &#125; &#125; v-&gt;vis = true; &#125; else &#123; v-&gt;size = 1, v-&gt;maxChild = NULL; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;to != v-&gt;fa) &#123; v-&gt;size += e-&gt;to-&gt;size; if (!v-&gt;maxChild || v-&gt;maxChild-&gt;size &lt; e-&gt;to-&gt;size) v-&gt;maxChild = e-&gt;to; &#125; &#125; s.pop(); &#125; &#125; for (int i = 0; i &lt; n; i++) N[i].vis = false; int timeStamp = 0; s.push(root); while (!s.empty()) &#123; Node *v = s.top(); if (!v-&gt;vis) &#123; v-&gt;dfn = timeStamp++; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;to != v-&gt;fa &amp;&amp; e-&gt;to != v-&gt;maxChild) &#123; s.push(e-&gt;to); &#125; &#125; if (v-&gt;maxChild) s.push(v-&gt;maxChild); v-&gt;pathFa = (!v-&gt;fa || v != v-&gt;fa-&gt;maxChild) ? v : v-&gt;fa-&gt;pathFa; v-&gt;vis = true; &#125; else &#123; s.pop(); &#125; &#125;&#125;inline void build() &#123; treeChainSplit(N); for (int i = 1; i &lt;= MAX_C; i++) segt[i] = new SegmentTree(0, n); for (int i = 0; i &lt; n; i++) segt[N[i].type]-&gt;modify(N[i].dfn, N[i].val);&#125;inline void modifyType(int i, int x) &#123; Node *v = &amp;N[i]; segt[v-&gt;type]-&gt;modify(v-&gt;dfn, 0); segt[v-&gt;type = x]-&gt;modify(v-&gt;dfn, v-&gt;val);&#125;inline void modifyVal(int i, int val) &#123; Node *v = &amp;N[i]; segt[v-&gt;type]-&gt;modify(v-&gt;dfn, v-&gt;val = val);&#125;inline int querySum(int x, int y) &#123; Node *u = &amp;N[x], *v = &amp;N[y]; SegmentTree *s = segt[u-&gt;type]; int res = 0; while (u-&gt;pathFa != v-&gt;pathFa) &#123; if (u-&gt;pathFa-&gt;depth &lt; v-&gt;pathFa-&gt;depth) std::swap(u, v); res += s-&gt;querySum(u-&gt;pathFa-&gt;dfn, u-&gt;dfn + 1); u = u-&gt;pathFa-&gt;fa; &#125; if (u-&gt;depth &gt; v-&gt;depth) std::swap(u, v); res += s-&gt;querySum(u-&gt;dfn, v-&gt;dfn + 1); return res;&#125;inline int queryMax(int x, int y) &#123; Node *u = &amp;N[x], *v = &amp;N[y]; SegmentTree *s = segt[u-&gt;type]; int res = INT_MIN; while (u-&gt;pathFa != v-&gt;pathFa) &#123; if (u-&gt;pathFa-&gt;depth &lt; v-&gt;pathFa-&gt;depth) std::swap(u, v); res = std::max(res, s-&gt;queryMax(u-&gt;pathFa-&gt;dfn, u-&gt;dfn + 1)); u = u-&gt;pathFa-&gt;fa; &#125; if (u-&gt;depth &gt; v-&gt;depth) std::swap(u, v); res = std::max(res, s-&gt;queryMax(u-&gt;dfn, v-&gt;dfn + 1)); return res;&#125;int main() &#123; int q; scanf(\"%d %d\", &amp;n, &amp;q); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d %d\", &amp;N[i].val, &amp;N[i].type); &#125; for (int i = 0, u, v; i &lt; n - 1; i++) &#123; scanf(\"%d %d\", &amp;u, &amp;v), u--, v--; addEdge(u, v); &#125; build(); static char cmd[3]; for (int i = 0, x, y; i &lt; q; i++) &#123; scanf(\"%s %d %d\", cmd, &amp;x, &amp;y); if (cmd[0] == 'C') &#123; x--; if (cmd[1] == 'C') modifyType(x, y); else if (cmd[1] == 'W') modifyVal(x, y); else throw \"%%% Menci\"; &#125; else if (cmd[0] == 'Q') &#123; x--, y--; if (cmd[1] == 'S') printf(\"%d\\n\", querySum(x, y)); else if (cmd[1] == 'M') printf(\"%d\\n\", queryMax(x, y)); else throw \"%%% Menci\"; &#125; else throw \"%%% Menci\"; &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://sulfur6.github.io/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://sulfur6.github.io/tags/树链剖分/"},{"name":"SDOI","slug":"SDOI","permalink":"http://sulfur6.github.io/tags/SDOI/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「BZOJ1756」小白逛公园 - 线段树","slug":"bzoj1756","date":"2017-02-20T12:57:02.000Z","updated":"2017-06-02T13:32:36.000Z","comments":true,"path":"bzoj1756/","link":"","permalink":"http://sulfur6.github.io/bzoj1756/","excerpt":"给定一个序列，需要支持两种操作： 询问给定区间 [l,r] [l, r] [l,r] 中的最大子段和 修改序列中某个元素的值","text":"给定一个序列，需要支持两种操作： 询问给定区间 [l,r] [l, r] [l,r] 中的最大子段和 修改序列中某个元素的值 题解最大子段和问题的最优复杂度显然是 O(n) O(n) O(n) 的 dp，但是我们要求的是某个区间中的最大子段和，并且需要支持对区间上的某个位置修改其值，所以我们用分治法来求，用线段树来维护信息。 我们考虑对于求解一个区间的最大子段和的分治做法，首先将其分为两个子区间。 整个大区间的最大子段和可能等于某一个小区间的最大子段和，但是也有可能存在最大子段和中的子段跨过区间中点的情况，所以我们需要左半边区间强制包含右端点的最大子段和，以及右半边区间强制包含左端点的最大子段和，这样将这两个加起来，得到大区间跨过区间中点的最大子段和，三者取最大即可。 对于线段树而言，我们对于每个节点都记录该区间的最大子段和，该区间包含左端点，包含右端点的最大子段和，具体实现见代码。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAXN = 500000;const int MAXM = 100000;struct SegmentTree &#123; struct Node &#123; Node *lc, *rc; int l, r, val; int sum, lsum, rsum, maxSum; Node() &#123;&#125; Node(Node *lc, Node *rc, int l, int r) : lc(lc), rc(rc), l(l), r(r) &#123;&#125; void update() &#123; sum = val; if (lc) sum += lc-&gt;sum; if (rc) sum += rc-&gt;sum; lsum = rsum = sum; if (lc) &#123; lsum = std::max(lsum, lc-&gt;lsum); if (rc) lsum = std::max(lsum, lc-&gt;sum + rc-&gt;lsum); &#125; if (rc) &#123; rsum = std::max(rsum, rc-&gt;rsum); if (lc) rsum = std::max(rsum, rc-&gt;sum + lc-&gt;rsum); &#125; maxSum = sum; maxSum = std::max(maxSum, lsum); maxSum = std::max(maxSum, rsum); if (lc) maxSum = std::max(maxSum, lc-&gt;maxSum); if (rc) maxSum = std::max(maxSum, rc-&gt;maxSum); if (lc &amp;&amp; rc) maxSum = std::max(maxSum, lc-&gt;rsum + rc-&gt;lsum); &#125; void query(int l, int r, int &amp;sum, int &amp;lsum, int &amp;rsum, int &amp;maxSum) &#123; if (this-&gt;l &gt; r || this-&gt;r &lt; l) return; else if (this-&gt;l &gt;= l &amp;&amp; this-&gt;r &lt;= r) &#123; sum = this-&gt;sum; lsum = this-&gt;lsum; rsum = this-&gt;rsum; maxSum = this-&gt;maxSum; &#125; else &#123; int mid = (this-&gt;l + this-&gt;r) &gt;&gt; 1; if (r &lt;= mid) return lc-&gt;query(l, r, sum, lsum, rsum, maxSum); if (l &gt;= mid + 1) return rc-&gt;query(l, r, sum, lsum, rsum, maxSum); else &#123; int suml, lsuml, rsuml, maxSuml; int sumr, lsumr, rsumr, maxSumr; lc-&gt;query(l, r, suml, lsuml, rsuml, maxSuml); rc-&gt;query(l, r, sumr, lsumr, rsumr, maxSumr); maxSum = sum = suml + sumr; lsum = std::max(lsuml, suml + lsumr); rsum = std::max(rsumr, sumr + rsuml); maxSum = std::max(maxSum, maxSuml); maxSum = std::max(maxSum, maxSumr); maxSum = std::max(maxSum, rsuml + lsumr); &#125; &#125; &#125; void modify(int pos, int val) &#123; if (this-&gt;l &gt; pos || this-&gt;r &lt; pos) return; else if (this-&gt;l == pos &amp;&amp; this-&gt;r == pos) this-&gt;val = val, update(); else &#123; if (lc) lc-&gt;modify(pos, val); if (rc) rc-&gt;modify(pos, val); update(); &#125; &#125; &#125; *root; SegmentTree(int l, int r) &#123; root = build(l, r); &#125; Node *build(int l, int r) &#123; if (l &gt; r) return NULL; else if (l == r) return new Node(NULL, NULL, l, r); else &#123; int mid = (l + r) &gt;&gt; 1; return new Node(build(l, mid), build(mid + 1, r), l, r); &#125; &#125; void modify(int pos, int val) &#123; root-&gt;modify(pos, val); &#125; int query(int l, int r) &#123; int sum, lsum, rsum, maxSum; root-&gt;query(l, r, sum, lsum, rsum, maxSum); return maxSum; &#125;&#125; *segt;int main() &#123; int n, m; scanf(\"%d %d\", &amp;n, &amp;m); segt = new SegmentTree(1, n); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf(\"%d\", &amp;x); segt-&gt;modify(i, x); &#125; for (int i = 0; i &lt; m; i++) &#123; int k; scanf(\"%d\", &amp;k); if (k == 1) &#123; int l, r; scanf(\"%d %d\", &amp;l, &amp;r); if (l &gt; r) std::swap(l, r); printf(\"%d\\n\", segt-&gt;query(l, r)); &#125; else &#123; int pos, val; scanf(\"%d %d\", &amp;pos, &amp;val); segt-&gt;modify(pos, val); &#125; &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://sulfur6.github.io/tags/线段树/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://sulfur6.github.io/tags/BZOJ/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「网络流24题」最长递增子序列 - 网络流","slug":"lcp-network-flow","date":"2017-02-18T10:31:26.000Z","updated":"2017-06-02T13:34:06.000Z","comments":true,"path":"lcp-network-flow/","link":"","permalink":"http://sulfur6.github.io/lcp-network-flow/","excerpt":"给定正整数序列 x1∼xn x_1 \\sim x_n x​1​​∼x​n​​，以下递增子序列均为非严格递增。 计算其最长递增子序列的长度 s s s。 计算从给定的序列中最多可取出多少个长度为 s s s 的递增子序列。 如果允许在取出的序列中多次使用 x1 x_1 x​1​​ 和 xn x_n x​n​​，则从给定序列中最多可取出多少个长度为 s s s 的递增子序列。","text":"给定正整数序列 x1∼xn x_1 \\sim x_n x​1​​∼x​n​​，以下递增子序列均为非严格递增。 计算其最长递增子序列的长度 s s s。 计算从给定的序列中最多可取出多少个长度为 s s s 的递增子序列。 如果允许在取出的序列中多次使用 x1 x_1 x​1​​ 和 xn x_n x​n​​，则从给定序列中最多可取出多少个长度为 s s s 的递增子序列。 题解题意不清的辣鸡题。。这里感谢 Menci 同学在博客里和 OJ 上都强调了 非严格递增 题意要求求出 “最长递增子序列” ，然而实际数据却是 “最长不下降子序列” 第一问直接 dp 即可，第二问第三问网络流解决。 第二问: 记第一问答案为 K K K。 首先在 dp 中，f(i) f(i) f(i) 表示以第 i 个元素结尾的最长不下降子序列长度， 然后我们将每个 (f(i)=1) (f(i) = 1) (f(i)=1) 与 源点连边，容量为 1 1 1 ， 每个 (f(i)=K) (f(i) = K) (f(i)=K) 向汇点连边，每个可能的转移连边，对于可能的转移 f(j)→f(i) f(j) \\rightarrow f(i) f(j)→f(i)，需要满足的条件是 j&lt;i j &lt; i j&lt;i，aj&lt;ai a_j &lt; a_i a​j​​&lt;a​i​​ 且 f(j)+1=f(i) f(j) + 1 = f(i) f(j)+1=f(i)。 但是第二问要求的方案数其实是不允许在不同方案中选取相同元素的， 所以我们把每个点拆点限制容量。 第三问: 第三问就是允许在不同的方案中出现多次 a1 a_1 a​1​​ 或 an a_n a​n​​， 这是我们只需要把与 f(1) f(1) f(1) 或 f(n) f(n) f(n) 相连的边的容量限制撤掉即可，即与其相连的边容量为 ∞ \\infty ∞; 顺便吐槽一句出题人这里也没有解释清楚。。。 注意特判，如果第一问求得答案为 1 1 1 ，则直接输出 1 n n 1 \\ n \\ n 1 n n。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;new&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;const int MAXN = 500;struct Node;struct Edge;struct Node &#123; Edge *e, *c; int level;&#125; N[MAXN * 2 + 10];struct Edge &#123; Node *fr, *to; Edge *ne, *rev; int cap, flow; Edge() &#123;&#125; Edge(Node *fr, Node *to, int cap) : fr(fr), to(to), ne(fr-&gt;e), cap(cap), flow(0) &#123;&#125;&#125;;inline void addEdge(int fr, int to, int cap) &#123; N[fr].e = new Edge(&amp;N[fr], &amp;N[to], cap); N[to].e = new Edge(&amp;N[to], &amp;N[fr], 0); N[fr].e-&gt;rev = N[to].e, N[to].e-&gt;rev = N[fr].e;&#125;struct Dinic &#123; bool makeLevelGraph(Node *s, Node *t, int n) &#123; for (int i = 0; i &lt; n; i++) N[i].c = N[i].e, N[i].level = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) &#123; Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;cap &gt; e-&gt;flow &amp;&amp; e-&gt;to-&gt;level == 0) &#123; e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; q.push(e-&gt;to); &#125; &#125; &#125; return false; &#125; int findPath(Node *s, Node *t, int limit = INT_MAX) &#123; if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;ne) &#123; if (e-&gt;cap &gt; e-&gt;flow &amp;&amp; e-&gt;to-&gt;level == s-&gt;level + 1) &#123; int flow = findPath(e-&gt;to, t, std::min(e-&gt;cap - e-&gt;flow, limit)); if (flow &gt; 0) &#123; e-&gt;flow += flow; e-&gt;rev-&gt;flow -= flow; return flow; &#125; &#125; &#125; return 0; &#125; int operator()(int s, int t, int n) &#123; int res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) &#123; int flow; if ((flow = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += flow; &#125; return res; &#125;&#125; dinic;int a[MAXN + 1], f[MAXN + 1], n, maxLength;int subTask1() &#123; int res = 0; for (int i = 1; i &lt;= n; i++) f[i] = 1; for (int i = 1; i &lt;= n; i++) &#123; int lastStat = 0; for (int j = 1; j &lt; i; j++) &#123; if (a[i] &gt;= a[j] &amp;&amp; lastStat &lt; f[j]) lastStat = f[j]; &#125; f[i] = lastStat + 1; res = std::max(res, f[i]); &#125; return res;&#125;int subTask2() &#123; const int s = 0, t = n * 2 + 1; for (int i = 1; i &lt;= n; i++) &#123; addEdge(i, i + n, 1); if (f[i] == maxLength) addEdge(i + n, t, 1); if (f[i] == 1) addEdge(s, i, 1); for (int j = 1; j &lt; i; j++) &#123; if (f[j] == f[i] - 1 &amp;&amp; a[j] &lt;= a[i]) addEdge(j + n, i, 1); &#125; &#125; int res = dinic(s, t, n * 2 + 2); return res;&#125;int subTask3() &#123; const int s = 0, t = n * 2 + 1; for (int i = 1; i &lt;= n; i++) &#123; int cap = 1; if (i == 1 || i == n) cap = INT_MAX; addEdge(i, i + n, cap); if (f[i] == maxLength) addEdge(i + n, t, cap); if (f[i] == 1) addEdge(s, i, cap); for (int j = 1; j &lt; i; j++) &#123; if (f[j] == f[i] - 1 &amp;&amp; a[j] &lt;= a[i]) addEdge(j + n, i, 1); &#125; &#125; int res = dinic(s, t, n * 2 + 2); return res;&#125;int main() &#123;// freopen(\"alis.in\", \"r\", stdin);// freopen(\"alis.out\", \"w\", stdout); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); printf(\"%d\\n\", maxLength = subTask1()); if (maxLength == 1) &#123; printf(\"%d\\n%d\", n, n); &#125; else &#123; printf(\"%d\\n\", subTask2()); for (int i = 0; i &lt; n * 2 + 2; i++) &#123; for (Edge *&amp;e = N[i].e, *ne; e; ne = e-&gt;ne, delete e, e = ne); N[i].e = N[i].c = NULL; N[i].level = 0; &#125; printf(\"%d\\n\", subTask3()); &#125;// fclose(stdin);// fclose(stdout); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://sulfur6.github.io/tags/网络流/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「网络流24题」最小路径覆盖","slug":"road-network-flow","date":"2017-02-16T07:49:18.000Z","updated":"2017-06-02T13:33:52.000Z","comments":true,"path":"road-network-flow/","link":"","permalink":"http://sulfur6.github.io/road-network-flow/","excerpt":"给定有向图 G=(V,E) G = (V, E) G=(V,E)。设 P P P 是 G G G 的一个简单路（顶点不相交）的集合。如果 V V V 中每个顶点恰好在 P P P 的一条路上，则称 P P P 是 G G G 的一个路径覆盖。P P P 中路径可以从 V V V 的任何一个顶点开始，长度也是任意的，特别地，可以为 0 0 0。G G G 的最小路径覆盖是 G G G 的所含路径条数最少的路径覆盖。 设计一个有效算法求一个有向无环图 G G G 的最小路径覆盖。","text":"给定有向图 G=(V,E) G = (V, E) G=(V,E)。设 P P P 是 G G G 的一个简单路（顶点不相交）的集合。如果 V V V 中每个顶点恰好在 P P P 的一条路上，则称 P P P 是 G G G 的一个路径覆盖。P P P 中路径可以从 V V V 的任何一个顶点开始，长度也是任意的，特别地，可以为 0 0 0。G G G 的最小路径覆盖是 G G G 的所含路径条数最少的路径覆盖。 设计一个有效算法求一个有向无环图 G G G 的最小路径覆盖。 题解关于路径覆盖的定义，这题题面里说的比较好。 路径覆盖就是用若干条路径来覆盖一个DAG上的所有点，但是不同路径上的各个顶点不可以重复 特别的，一条路径的长度可以为 1 1 1 ，也就是一个顶点可以算作一条路径 最小路径覆盖的意义就是最小化路径覆盖集的大小 考虑把一个顶点拆成两个，分属集合 A A A 以及集合 B B B，若原图中有某一条边 (u,v) (u, v) (u,v),则在网络中建立(u∈A,v∈B) (u \\in A, v \\in B) (u∈A,v∈B)，在这个二分图上找最大匹配，最终答案就是原图点数减去最大匹配数。 这样做的道理是什么呢? 考虑路径覆盖的定义，我们每将原图中的一条边 (u,v) (u, v) (u,v) 加入路径覆盖的条件是: 保证对于路径覆盖集中的任意其他路径，保证不存在 s∈V,(u,s) s \\in V, (u, s) s∈V,(u,s); 这和二分图匹配的定义相似，所以我们拆点做二分图匹配 黄学长这题题解里有句话说的非常好：如果无匹配，显然要 n n n 条路径才能覆盖所有点，两个点匹配意味着将可以把它们用一条路径覆盖，路径数就可以减 1 1 1 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;new&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;const int MAXN = 400;const int MAXM = 6000;struct Node;struct Edge;struct Node &#123; Edge *e, *c; int level, id; bool vis;&#125; N[MAXN + 5];struct Edge &#123; Node *fr, *to; Edge *ne, *rev; int cap, flow; Edge() &#123;&#125; Edge(Node *fr, Node *to, int cap) : fr(fr), to(to), ne(fr-&gt;e), cap(cap), flow(0) &#123;&#125;&#125;;inline void addEdge(int fr, int to, int cap) &#123; N[fr].e = new Edge(&amp;N[fr], &amp;N[to], cap); N[to].e = new Edge(&amp;N[to], &amp;N[fr], 0); N[fr].e-&gt;rev = N[to].e, N[to].e-&gt;rev = N[fr].e;&#125;struct Dinic &#123; bool makeLevelGraph(Node *s, Node *t, int n) &#123; for (int i = 0; i &lt; n; i++) N[i].c = N[i].e, N[i].level = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) &#123; Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;cap &gt; e-&gt;flow &amp;&amp; !e-&gt;to-&gt;level) &#123; e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; q.push(e-&gt;to); &#125; &#125; &#125; return false; &#125; int findPath(Node *s, Node *t, int limit = INT_MAX) &#123; if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;ne) &#123; if (e-&gt;cap &gt; e-&gt;flow &amp;&amp; e-&gt;to-&gt;level == s-&gt;level + 1) &#123; int flow = findPath(e-&gt;to, t, std::min(e-&gt;cap - e-&gt;flow, limit)); if (flow &gt; 0) &#123; e-&gt;flow += flow; e-&gt;rev-&gt;flow -= flow; return flow; &#125; &#125; &#125; return 0; &#125; int operator()(int s, int t, int n) &#123; int res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) &#123; int flow; if ((flow = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += flow; &#125; return res; &#125;&#125; dinic;void printPath(Node *v) &#123; printf(\"%d \", v-&gt;id); v-&gt;vis = true; for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;flow == e-&gt;cap &amp;&amp; e-&gt;to-&gt;id != 0 &amp;&amp; !N[e-&gt;to-&gt;id].vis) &#123; printPath(&amp;N[e-&gt;to-&gt;id]); break; &#125; &#125;&#125;int main() &#123; int n, m; scanf(\"%d %d\", &amp;n, &amp;m); // let [1, n] equal to the set A, [n + 1, n * 2] equal to the set B; const int s = 0, t = n * 2 + 1; for (int i = 1; i &lt;= n; i++) addEdge(s, i, 1), addEdge(i + n, t, 1), N[i].id = N[i + n].id = i; for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); addEdge(u, v + n, 1); &#125; int res = dinic(s, t, n * 2 + 2); for (int i = 1; i &lt;= n; i++) &#123; if (!N[i].vis) &#123; printPath(&amp;N[i]); puts(\"\"); &#125; &#125; printf(\"%d\\n\", n - res); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://sulfur6.github.io/tags/网络流/"},{"name":"最小路径覆盖","slug":"最小路径覆盖","permalink":"http://sulfur6.github.io/tags/最小路径覆盖/"},{"name":"二分图匹配","slug":"二分图匹配","permalink":"http://sulfur6.github.io/tags/二分图匹配/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「网络流24题」太空飞行计划 - 最大权闭合子图","slug":"shuttle","date":"2017-02-16T07:40:58.000Z","updated":"2017-06-02T13:33:36.000Z","comments":true,"path":"shuttle/","link":"","permalink":"http://sulfur6.github.io/shuttle/","excerpt":"W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 E={E1,E2,⋯,Em} E = \\{ E_1, E_2, \\cdots, E_m \\} E={E​1​​,E​2​​,⋯,E​m​​}，和进行这些实验需要使用的全部仪器的集合 I={I1,I2,⋯,In} I = \\{ I_1, I_2, \\cdots, I_n \\} I={I​1​​,I​2​​,⋯,I​n​​}。实验 Ej E_j E​j​​ 需要用到的仪器是 I I I 的子集 Rj⊆I R_j \\subseteq I R​j​​⊆I。 配置仪器 Ik I_k I​k​​ 的费用为 ck c_k c​k​​ 美元。实验 Ej E_j E​j​​ 的赞助商已同意为该实验结果支付 pj p_j p​j​​ 美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。 对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。","text":"W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 E={E1,E2,⋯,Em} E = \\{ E_1, E_2, \\cdots, E_m \\} E={E​1​​,E​2​​,⋯,E​m​​}，和进行这些实验需要使用的全部仪器的集合 I={I1,I2,⋯,In} I = \\{ I_1, I_2, \\cdots, I_n \\} I={I​1​​,I​2​​,⋯,I​n​​}。实验 Ej E_j E​j​​ 需要用到的仪器是 I I I 的子集 Rj⊆I R_j \\subseteq I R​j​​⊆I。 配置仪器 Ik I_k I​k​​ 的费用为 ck c_k c​k​​ 美元。实验 Ej E_j E​j​​ 的赞助商已同意为该实验结果支付 pj p_j p​j​​ 美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。 对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。 链接LYOI #118 COGS #727 题解源点与正权点连边，容量为点权值 正权点与负权点连边，容量为负无穷 负权点与汇点连边，容量为点权值绝对值 最大权闭合子图的点权和 = 正点权和 - 最大流 上面讲述了一种通过最大权闭合子图来思考的模式，具体证明见胡伯涛论文。 按照上述方式建图，考虑这张图中割的意义。 割中不应该存在实验连向仪器的边，因为它们的容量是正无穷。那么如果一条源点到实验的边被割开，意味着这个实验被抛弃不做，一条仪器到汇点的边被割去了，意味着这个仪器会被使用，也就是最后的收益要减去仪器的价格。这样求出最小割以后，就可以最小化弃置实验的价值和使用仪器的代价，最终把期望总收益（所有实验的收益和）减去我们得到的最小代价，得到的就是最终的答案。 求最小割: 在包含负权边的网络中沿着未满流的边 bfs， 到达的点打上标记，一条跨越标记点和未标记点的边属于最小割。 代码我才不要用什么 set_difference 呢。 #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;cassert&gt;#include &lt;new&gt;#include &lt;algorithm&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;const int MAXN = 100;const int MAXM = 100;struct Node;struct Edge;struct Node &#123; Edge *e, *c; int level; bool chosen, flag; Node() : e(NULL), c(NULL), level(0), chosen(false), flag(false) &#123;&#125;;&#125; N[MAXM + MAXN + 2];struct Edge &#123; Node *fr, *to; Edge *ne, *rev; int cap, flow; bool isCut; Edge() &#123;&#125; Edge(Node *fr, Node *to, int cap) : fr(fr), to(to), ne(fr-&gt;e), cap(cap), flow(0), isCut(false) &#123;&#125;&#125; _pool[MAXN * MAXM + MAXN + MAXM + 1000], *_end;inline void init() &#123; _end = _pool;&#125;inline void addEdge(int fr, int to, int cap) &#123; N[fr].e = new (_end++) Edge(&amp;N[fr], &amp;N[to], cap); N[to].e = new (_end++) Edge(&amp;N[to], &amp;N[fr], 0); N[fr].e-&gt;rev = N[to].e, N[to].e-&gt;rev = N[fr].e;&#125;struct Dinic &#123; bool makeLevelGraph(Node *s, Node *t, int n) &#123; for (int i = 0; i &lt;= n; i++) N[i].c = N[i].e, N[i].level = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) &#123; Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;cap &gt; e-&gt;flow &amp;&amp; e-&gt;to-&gt;level == 0) &#123; e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; q.push(e-&gt;to); &#125; &#125; &#125; return false; &#125; int findPath(Node *s, Node *t, int limit = INT_MAX) &#123; if (s == t) return limit; for (Edge *&amp;e = s-&gt;c; e; e = e-&gt;ne) &#123; if (e-&gt;cap &gt; e-&gt;flow &amp;&amp; e-&gt;to-&gt;level == s-&gt;level + 1) &#123; int flow = findPath(e-&gt;to, t, std::min(limit, e-&gt;cap - e-&gt;flow)); if (flow &gt; 0) &#123; e-&gt;flow += flow; e-&gt;rev-&gt;flow -= flow; return flow; &#125; &#125; &#125; return 0; &#125; int operator()(int s, int t, int n) &#123; int res = 0; while (makeLevelGraph(&amp;N[s], &amp;N[t], n)) &#123; int flow; if ((flow = findPath(&amp;N[s], &amp;N[t])) &gt; 0) res += flow; &#125; return res; &#125;&#125; dinic;void minCut(int s) &#123; std::queue&lt;Node *&gt; q; q.push(&amp;N[s]); N[s].flag = true; while (!q.empty()) &#123; Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123; if (e-&gt;flow &lt; e-&gt;cap &amp;&amp; !e-&gt;to-&gt;flag) &#123; e-&gt;to-&gt;flag = true; q.push(e-&gt;to); &#125; &#125; &#125; for (Edge *e = _pool; e != _end; e++) &#123; if (e-&gt;fr-&gt;flag &amp;&amp; !e-&gt;to-&gt;flag) e-&gt;isCut = true; &#125;&#125;int main() &#123; init(); int n, m, sum = 0; scanf(\"%d %d\\n\", &amp;m, &amp;n); const int s = 0, t = n + m + 1; for (int i = 1; i &lt;= m; i++) &#123; std::string str; std::getline(std::cin, str); std::stringstream ss; ss &lt;&lt; str; int x; ss &gt;&gt; x; sum += x; addEdge(s, n + i, x); while (!ss.eof()) &#123; ss &gt;&gt; x; addEdge(n + i, x, INT_MAX); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; int x; scanf(\"%d\", &amp;x); addEdge(i, t, x); &#125; int maxFlow = dinic(s, t, t); minCut(s); for (Edge *e = _pool; e != _end; e++) &#123; if (e-&gt;isCut) &#123; if (e-&gt;fr - N == s) e-&gt;to-&gt;chosen = true; if (e-&gt;to - N == t) e-&gt;fr-&gt;chosen = true; &#125; &#125; for (int i = n + 1; i &lt;= n + m; i++) &#123; if (!N[i].chosen) printf(\"%d \", i - n); &#125; puts(\"\"); for (int i = 1; i &lt;= n; i++) &#123; if (N[i].chosen) printf(\"%d \", i); &#125; printf(\"\\n%d\\n\", sum - maxFlow); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://sulfur6.github.io/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"http://sulfur6.github.io/tags/最大流/"},{"name":"最大权闭合子图","slug":"最大权闭合子图","permalink":"http://sulfur6.github.io/tags/最大权闭合子图/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「CQOI 2015」任务查询系统 - 可持久化权值线段树","slug":"bzoj3932","date":"2017-02-15T01:22:18.000Z","updated":"2017-06-02T13:41:28.000Z","comments":true,"path":"bzoj3932/","link":"","permalink":"http://sulfur6.github.io/bzoj3932/","excerpt":"给定若干个任务 (si,ei,pi) (s_i, e_i, p_i) (s​i​​,e​i​​,p​i​​)，表示该任务从第 si s_i s​i​​ 秒运行到第 ei e_i e​i​​ 秒，它的价值为 pi p_i p​i​​，每次询问给定一个 x x x 并由你计算一个 k k k，查询第 x x x 秒时价值最小的 k k k 个任务的价值之和，如果第 x x x 秒时运行的任务不足 k k k 个，则输出此时所有任务的价值和。","text":"给定若干个任务 (si,ei,pi) (s_i, e_i, p_i) (s​i​​,e​i​​,p​i​​)，表示该任务从第 si s_i s​i​​ 秒运行到第 ei e_i e​i​​ 秒，它的价值为 pi p_i p​i​​，每次询问给定一个 x x x 并由你计算一个 k k k，查询第 x x x 秒时价值最小的 k k k 个任务的价值之和，如果第 x x x 秒时运行的任务不足 k k k 个，则输出此时所有任务的价值和。 题解这里用一种差分的思想来建主席树。 考虑当我们接受到一个任务时，它会从第 si s_i s​i​​ 秒存在到第 ei e_i e​i​​ 秒，而且查询是查询第 x x x 秒存在的的所有任务，所以我们对于时间建主席树，对于一个任务 i i i，我们在建第 si s_i s​i​​ 棵线段树时把它插入主席树，在建 ei+1 e_i + 1 e​i​​+1 棵线段树时把它删掉，这样我们可以保证第 i i i 棵线段树中存储的任务是所有在第 i i i 秒中运行的任务，剩下的就是主席树上二分查询了。。 注意，相同优先级的任务可能有多个。 顺便吐个槽，感觉这种写法叫做可持久化权值线段树更好。。 代码奇怪的类名实例名什么的不要在意啦 qwq #include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;const int MAXN = 100000;const int MAXM = 100000;struct Mission &#123; int val; bool isDelete; Mission() &#123;&#125; Mission(int val, bool isDelete) : val(val), isDelete(isDelete) &#123;&#125;&#125;;std::vector&lt;Mission&gt; a[MAXM + 50];struct PresentTreeByGoldYeInInternationalOlympidInInformaticsHellc &#123; struct Node &#123; int l, r; Node *lc, *rc; int size, sum; Node() &#123;&#125; Node(int l, int r, Node *lc, Node *rc) : l(l), r(r), lc(lc), rc(rc), size(lc-&gt;size + rc-&gt;size), sum(lc-&gt;sum + rc-&gt;sum) &#123;&#125; Node(int l, int r, Node *lc, Node *rc, int size, int sum) : l(l), r(r), lc(lc), rc(rc), size(size), sum(sum) &#123;&#125; &#125; *roots[MAXN + 50], *null, _pool[MAXN * 200], *_curr; int l, r; PresentTreeByGoldYeInInternationalOlympidInInformaticsHellc() &#123; null = new Node(-1, -1, NULL, NULL, 0, 0); null-&gt;lc = null, null-&gt;rc = null; &#125; Node *insert(Node *v, int l, int r, int x, bool isDelete) &#123; if (!isDelete) &#123; if (x &lt; l || x &gt; r) return v; else if (l == r) return new (_curr++) Node(l, r, null, null, v-&gt;size + 1, v-&gt;sum + x); else &#123; int mid = l + (r - l) / 2; return new (_curr++) Node(l, r, insert(v-&gt;lc, l, mid, x, isDelete), insert(v-&gt;rc, mid + 1, r, x, isDelete)); &#125; &#125; else &#123; if (x &lt; l || x &gt; r) return v; else if (l == r) return new (_curr++) Node(l, r, null, null, v-&gt;size - 1, v-&gt;sum - x); else &#123; int mid = l + (r - l) / 2; return new (_curr++) Node(l, r, insert(v-&gt;lc, l, mid, x, isDelete), insert(v-&gt;rc, mid + 1, r, x, isDelete)); &#125; &#125; &#125;/* void update(Node *v, int x, bool isDelete) &#123; if (!isDelete) &#123; v-&gt;size++, v-&gt;sum += x; if (v-&gt;l == v-&gt;r) return; else &#123; int mid = v-&gt;l + (v-&gt;r - v-&gt;l) / 2; if (x &lt;= mid) update(v-&gt;lc, x, isDelete); else update(v-&gt;rc, x, isDelete); &#125; &#125; else &#123; v-&gt;size--, v-&gt;sum -= x; if (v-&gt;l == v-&gt;r) return; else &#123; int mid = v-&gt;l + (v-&gt;r - v-&gt;l) / 2; if (x &lt;= mid) update(v-&gt;lc, x, isDelete); else update(v-&gt;rc, x, isDelete); &#125; &#125; &#125;*/ void build(std::vector&lt;Mission&gt; *a, int n, int l, int r) &#123; _curr = _pool; roots[0] = null; for (int i = 1; i &lt;= n; i++) &#123; std::vector&lt;Mission&gt;::iterator it = a[i].begin(); if (it == a[i].end()) &#123; roots[i] = roots[i - 1]; continue; &#125; else &#123; roots[i] = insert(roots[i - 1], l, r, it-&gt;val, it-&gt;isDelete); it++; for (; it != a[i].end(); it++) &#123; assert(it != a[i].end()); roots[i] = insert(roots[i], l, r, it-&gt;val, it-&gt;isDelete); &#125; &#125; &#125; this-&gt;l = l, this-&gt;r = r; &#125; long long query(int qr, int k) &#123; long long ans = 0, lsize; Node *v = roots[qr]; if (k &gt;= v-&gt;size) return v-&gt;sum; lsize = v-&gt;lc-&gt;size; while (v-&gt;l != v-&gt;r) &#123; if (k &lt;= lsize) &#123; v = v-&gt;lc; lsize = v-&gt;lc-&gt;size; &#125; else &#123; k -= lsize; ans += v-&gt;lc-&gt;sum; v = v-&gt;rc; lsize = v-&gt;lc-&gt;size; &#125; &#125; if (k) ans += v-&gt;l * k; return ans; &#125;&#125; presentTreeByGoldYeInInternationalOlympidInInformaticsHellc;int main() &#123; int m, n; scanf(\"%d %d\", &amp;m, &amp;n); int max = INT_MIN, min = INT_MAX; for (int i = 1; i &lt;= m; i++) &#123; int s, t, val; scanf(\"%d %d %d\", &amp;s, &amp;t, &amp;val); max = std::max(max, val); min = std::min(min, val); a[s].push_back(Mission(val, false)); a[t + 1].push_back(Mission(val, true)); &#125; presentTreeByGoldYeInInternationalOlympidInInformaticsHellc.build(a, n, min, max); long long pre = 1; for (int i = 1; i &lt;= n; i++) &#123; int x, k; long long a, b, c; scanf(\"%d %lld %lld %lld\", &amp;x, &amp;a, &amp;b, &amp;c); k = 1 + (a * pre + b) % c; pre = presentTreeByGoldYeInInternationalOlympidInInformaticsHellc.query(x, k); printf(\"%lld\\n\", pre); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://sulfur6.github.io/tags/BZOJ/"},{"name":"主席树","slug":"主席树","permalink":"http://sulfur6.github.io/tags/主席树/"},{"name":"可持久化","slug":"可持久化","permalink":"http://sulfur6.github.io/tags/可持久化/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「HDU 5791」Two - DP","slug":"hdu5791","date":"2017-02-07T02:17:06.000Z","updated":"2017-06-02T13:42:04.000Z","comments":true,"path":"hdu5791/","link":"","permalink":"http://sulfur6.github.io/hdu5791/","excerpt":"给定两个字符串 A A A 和 B B B，求两个字符串的公共子序列个数。","text":"给定两个字符串 A A A 和 B B B，求两个字符串的公共子序列个数。 题解设 f(i,j) f(i, j) f(i,j) 为 A A A 串前 i i i 位和 B B B 串前 j j j 位的公共子序列个数，则 f(i,j)={f(i,j−1)+f(i−1,j)+1Ai=Bjf(i,j−1)+f(i−1,j)−f(i−1,j−1)Ai≠Bj f(i, j) = \\begin{cases} f(i, j - 1) + f(i - 1, j) + 1 &amp; A_i = B_j\\\\ f(i, j - 1) + f(i - 1, j) - f(i - 1, j - 1) &amp; A_i \\neq B_j \\end{cases} f(i,j)={​f(i,j−1)+f(i−1,j)+1​f(i,j−1)+f(i−1,j)−f(i−1,j−1)​​​A​i​​=B​j​​​A​i​​≠B​j​​​​代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAXN = 1005;const int MOD = 1000000007;int a[MAXN + 1], b[MAXN + 1], dp[MAXN + 1][MAXN + 1], n, m;int main() &#123; while (scanf(\"%d %d\", &amp;n, &amp;m) != EOF) &#123; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= m; i++) scanf(\"%d\", &amp;b[i]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; if (a[i] == b[j]) dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + 1) % MOD; else dp[i][j] = ( ( (dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]) ) % MOD + MOD ) % MOD; &#125; printf(\"%d\\n\", dp[n][m] % MOD); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.github.io/tags/DP/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「HDU5900」QSC and Master - 区间DP","slug":"hdu5900","date":"2017-02-07T00:56:15.000Z","updated":"2017-06-02T13:42:16.000Z","comments":true,"path":"hdu5900/","link":"","permalink":"http://sulfur6.github.io/hdu5900/","excerpt":"给定 n n n 个二元组，每个二元组由键和值构成，当且仅当相邻的两个二元组的键互质的时候，它们可以被消去，这时得到的价值为它们值的和，然后两边的元素链接在一起。 求能够获得的最大价值。","text":"给定 n n n 个二元组，每个二元组由键和值构成，当且仅当相邻的两个二元组的键互质的时候，它们可以被消去，这时得到的价值为它们值的和，然后两边的元素链接在一起。 求能够获得的最大价值。 题解两遍 dp ，第一遍处理出某个区间 [l, r] 中的 value 能否被全部得到，方法如下: let canEarnAll(l, r) equal to if all the value in [l, r] can be earned;canEarnAll(l, r) |= (canEarnAll(l + 1, r - 1) &amp; (gcd(l, r) != 1));for (int k = l; k &lt; r; k++) canEarnAll |= (canEarnAll(l, k) &amp; canEarnAll(k + 1, r)); 然后按照做出来的结果继续 dp，方法如下: let maxValue equal to the max value can be earned in [l, r];if (canEarnAll(l, r) == true) maxValue(l, r) = sumValue(l, r);else for (int k = l; k &lt; r; k++) maxValue(l, r) = max(maxValue(l, r), maxValue(l, k) + maxValue(k + 1, r)); 最后 maxValue(1, n) 即为答案。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAXN = 500;long long f[MAXN + 1][MAXN + 1], key[MAXN + 1], val[MAXN + 1], ans = 0;bool canEarnAll[MAXN + 1][MAXN + 1];int n;long long gcd(long long a, long long b) &#123; return !b ? a : gcd(b, a % b);&#125;int main() &#123; int T_T; scanf(\"%d\", &amp;T_T); for (int i = 1; i &lt;= T_T; i++) &#123; memset(f, 0, sizeof(f)); memset(canEarnAll, 0, sizeof(canEarnAll)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%lld\", &amp;key[i]); for (int i = 1; i &lt;= n; i++) scanf(\"%lld\", &amp;val[i]), val[i] += val[i - 1], canEarnAll[i][i - 1] = true; canEarnAll[n + 1][n] = true; for (int len = 2; len &lt;= n; len++) &#123; for (int i = 1; i &lt;= n - len + 1; i++) &#123; int j = i + len - 1; canEarnAll[i][j] |= canEarnAll[i + 1][j - 1] &amp; (gcd(key[i], key[j]) != 1); if (!canEarnAll[i][j]) for (int k = i; k &lt; j; k++) canEarnAll[i][j] |= canEarnAll[i][k] &amp; canEarnAll[k + 1][j]; &#125; &#125; for (int len = 2; len &lt;= n; len++) &#123; for (int i = 1; i &lt;= n - len + 1; i++) &#123; int j = i + len - 1; if (canEarnAll[i][j]) f[i][j] = val[j] - val[i - 1]; else for (int k = i; k &lt; j; k++) f[i][j] = std::max(f[i][j], f[i][k] + f[k + 1][j]); &#125; &#125; printf(\"%lld\\n\", f[1][n]); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://sulfur6.github.io/tags/HDU/"},{"name":"区间DP","slug":"区间DP","permalink":"http://sulfur6.github.io/tags/区间DP/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"「BZOJ3223」文艺平衡树","slug":"bzoj3223","date":"2017-02-03T12:16:20.000Z","updated":"2017-06-02T13:41:16.000Z","comments":true,"path":"bzoj3223/","link":"","permalink":"http://sulfur6.github.io/bzoj3223/","excerpt":"给定一个序列，以及若干次反转区间的操作，要求输出经过若干次反转操作之后的序列。","text":"给定一个序列，以及若干次反转区间的操作，要求输出经过若干次反转操作之后的序列。 题解用 Splay 维护序列即可。 对于一棵平衡树，满足旋转后其中序遍历始终不变的性质，所以我们按照序列来确定初始的 Splay ，这样做的话， Splay 的每个节点代表的是序列上的某个位置。 而后，对于每次反转，其实就是反转某一棵中序遍历为 [l,r] [l, r] [l,r] 的子树，这里我们将 l−1 l - 1 l−1 位置上的节点旋转到根，将 r+1 r + 1 r+1 位置上的节点旋转到根的右子树，由于这棵 Splay 的中序遍历就是原来的序列，那么 r+1 r + 1 r+1 位置上的节点的左子树的中序遍历一定是我们要的 [l,r] [l, r] [l,r] 这段区间，将这个节点打上反转标记即可。 注意，访问某个节点的儿子的时候一定要记得下放标记。 此外，如果要在函数内修改参数的值，不要忘记引用。。 代码#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#ifdef DBG const int MAXN = 10;#else const int MAXN = 100000;#endifint a[MAXN + 1];struct Splay &#123; struct Node &#123; Node *c[2], *fa, **root; int size, x; bool isBound, rev; Node(Node *fa, Node **root, int x, bool isBound = false) : fa(fa), root(root), size(1), x(x), isBound(isBound), rev(false) &#123; c[0] = c[1] = NULL; &#125; Node *pushDown() &#123; if (rev) &#123; std::swap(c[0], c[1]); if (c[0]) c[0]-&gt;rev ^= 1; if (c[1]) c[1]-&gt;rev ^= 1; rev = false; &#125; return this; &#125; void maintain() &#123; size = (c[0] ? c[0]-&gt;size : 0) + (c[1] ? c[1]-&gt;size : 0) + 1; &#125; int relation() &#123; return this == fa-&gt;c[1]; &#125; void rotate() &#123; pushDown(); Node *old = fa; int x = relation(); if (old-&gt;fa) old-&gt;fa-&gt;c[fa-&gt;relation()] = this; fa = old-&gt;fa; old-&gt;c[x] = c[x ^ 1]; if (c[x ^ 1]) c[x ^ 1]-&gt;fa = old; c[x ^ 1] = old; old-&gt;fa = this; old-&gt;maintain(), maintain(); if (!fa) *root = this; &#125; void splay(Node *target = NULL) &#123; while (fa != target) &#123; if (fa-&gt;fa) fa-&gt;fa-&gt;pushDown(); fa-&gt;pushDown(); if (fa-&gt;fa == target) rotate(); else if (relation() == fa-&gt;relation()) fa-&gt;rotate(), rotate(); else rotate(), rotate(); &#125; &#125; int lSize() &#123; return c[0] ? c[0]-&gt;size : 0; &#125; &#125; *root; Splay() : root(NULL) &#123;&#125; void build(int *a, int n) &#123; root = build(a, 1, n, NULL); Node **v = &amp;root, *fa = NULL; while (*v) &#123; fa = *v; fa-&gt;size++; v = &amp;(*v)-&gt;c[0]; &#125; *v = new Node(fa, &amp;root, 0, true); v = &amp;root, fa = NULL; while (*v) &#123; fa = *v; fa-&gt;size++; v = &amp;(*v)-&gt;c[1]; &#125; *v = new Node(fa, &amp;root, 0, true); &#125; Node *build(int *a, int l, int r, Node *fa) &#123; if (l &gt; r) return NULL; int mid = (l + r) &gt;&gt; 1; Node *v = new Node(fa, &amp;root, a[mid - 1]); if (l != r) &#123; v-&gt;c[0] = build(a, l, mid - 1, v); v-&gt;c[1] = build(a, mid + 1, r, v); v-&gt;maintain(); &#125; return v; &#125; Node *select(int k) &#123; k++; Node *v = root; while (k != v-&gt;pushDown()-&gt;lSize() + 1) &#123; if (k &lt; v-&gt;lSize() + 1) v = v-&gt;c[0]; else k -= v-&gt;lSize() + 1, v = v-&gt;c[1]; &#125;#ifdef DBG printf(\"Result before splay is %d\\n\", v-&gt;x);#endif v-&gt;splay();#ifdef DBG assert(root == v); printf(\"Result is %d\\n\", v-&gt;x); printf(\"------------------------------------------\\n\");#endif return root; &#125; Node *select(int l, int r) &#123; Node *epl = select(l - 1), *epr = select(r + 1); epl-&gt;splay(); epr-&gt;splay(epl); return epr-&gt;c[0]; &#125; void reverse(int l, int r) &#123; Node *range = select(l, r); range-&gt;rev ^= 1; &#125; void getAns(int *a) &#123; dfs(a, root); &#125; void dfs(int *&amp;a, Node *v) &#123; if (v) &#123; v-&gt;pushDown(); dfs(a, v-&gt;c[0]); if (!v-&gt;isBound) *a++ = v-&gt;x; dfs(a, v-&gt;c[1]); &#125; &#125;#ifdef DBG void print(Node *v) &#123; if (v) &#123; v-&gt;pushDown(); print(v-&gt;c[0]); printf(\"Size : %d, value : %d\\n\", v-&gt;size, v-&gt;x); print(v-&gt;c[1]); &#125; &#125;#endif&#125; splay;int main() &#123; int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) a[i] = i + 1; splay.build(a, n);#ifdef DBG splay.print(splay.root); printf(\"--------------------------------------\\n\");#endif while (m--) &#123; int l, r; scanf(\"%d %d\", &amp;l, &amp;r); splay.reverse(l, r);#ifdef DBG splay.print(splay.root); printf(\"---------------------------------------------\\n\");#endif &#125; splay.getAns(a); for (int i = 0; i &lt; n; i++) printf(\"%d \", a[i]); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://sulfur6.github.io/tags/BZOJ/"},{"name":"Splay","slug":"Splay","permalink":"http://sulfur6.github.io/tags/Splay/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"愤怒的小鸟 - 状态压缩，BFS，NOIP2016","slug":"NOIP2016-angrybirds","date":"2016-11-30T13:15:36.000Z","updated":"2017-06-02T13:36:14.000Z","comments":true,"path":"NOIP2016-angrybirds/","link":"","permalink":"http://sulfur6.github.io/NOIP2016-angrybirds/","excerpt":"Kiana最近沉迷于一款神奇的游戏无法自拔。 简单来说，这款游戏是在一个平面上进行的。 有一架弹弓位于 (0,0) (0, 0) (0,0) 处，每次Kiana可以用它向第一象限发射一只小鸟，小鸟们的飞行轨迹均为形如 y=ax2+bx y = ax ^ 2 + bx y=ax​2​​+bx 的曲线，其中 a a a，b b b 是Kiana指定的参数，且必须满足 a&lt;0 a &lt; 0 a&lt;0。 当小鸟落回地面（即 x x x 轴）时，它就会瞬间消失。 在游戏的某个关卡里，平面的第一象限中有 n n n 只绿色的猪，其中第 i i i 只猪所在的坐标为 (xi,yi) (x_i, y_i) (x​i​​,y​i​​)。 如果某只小鸟的飞行轨迹经过了(xi,yi) (x_i, y_i) (x​i​​,y​i​​)，那么第 i i i 只猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行； 如果一只小鸟的飞行轨迹没有经过(xi,yi) (x_i, y_i) (x​i​​,y​i​​)，那么这只小鸟飞行的全过程就不会对第 i i i 只猪产生任何影响。 例如，若两只猪分别位于 (1,3) (1, 3) (1,3) 和 (3,3) (3, 3) (3,3)，Kiana可以选择发射一只飞行轨迹为 y=−x2+4x y = -x ^ 2 + 4x y=−x​2​​+4x 的小鸟，这样两只猪就会被这只小鸟一起消灭。 而这个游戏的目的，就是通过发射小鸟消灭所有的猪。 这款神奇游戏的每个关卡对来说都很难，所以Kiana还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在「输入格式」中详述。 假设这款游戏一共有 T T T 个关卡，现在Kiana想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的猪。由于她不会算，所以希望由你告诉她。","text":"Kiana最近沉迷于一款神奇的游戏无法自拔。 简单来说，这款游戏是在一个平面上进行的。 有一架弹弓位于 (0,0) (0, 0) (0,0) 处，每次Kiana可以用它向第一象限发射一只小鸟，小鸟们的飞行轨迹均为形如 y=ax2+bx y = ax ^ 2 + bx y=ax​2​​+bx 的曲线，其中 a a a，b b b 是Kiana指定的参数，且必须满足 a&lt;0 a &lt; 0 a&lt;0。 当小鸟落回地面（即 x x x 轴）时，它就会瞬间消失。 在游戏的某个关卡里，平面的第一象限中有 n n n 只绿色的猪，其中第 i i i 只猪所在的坐标为 (xi,yi) (x_i, y_i) (x​i​​,y​i​​)。 如果某只小鸟的飞行轨迹经过了(xi,yi) (x_i, y_i) (x​i​​,y​i​​)，那么第 i i i 只猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行； 如果一只小鸟的飞行轨迹没有经过(xi,yi) (x_i, y_i) (x​i​​,y​i​​)，那么这只小鸟飞行的全过程就不会对第 i i i 只猪产生任何影响。 例如，若两只猪分别位于 (1,3) (1, 3) (1,3) 和 (3,3) (3, 3) (3,3)，Kiana可以选择发射一只飞行轨迹为 y=−x2+4x y = -x ^ 2 + 4x y=−x​2​​+4x 的小鸟，这样两只猪就会被这只小鸟一起消灭。 而这个游戏的目的，就是通过发射小鸟消灭所有的猪。 这款神奇游戏的每个关卡对来说都很难，所以Kiana还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在「输入格式」中详述。 假设这款游戏一共有 T T T 个关卡，现在Kiana想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的猪。由于她不会算，所以希望由你告诉她。 链接LYOI#104 题解状压因为猪的数量最多只有 18 18 18 只，所以自然而然地想到状压，这里说一下本题状压的思想。 我们用一个形如 011011001100110010 的二进制数，表示游戏中现存的猪，其中从左往右数第 i i i 位，表示的是编号为 i i i 的猪的状态，该位为 0 0 0 ，表示这只猪死亡或本身就不存在，反之表示这只猪现在还活着。 对于一条抛物线（真·题解中会提到抛物线相关），我们也用一个类似的二进制数记录它的信息，即它的从左往右第 i i i 位为 1 1 1，表示编号为 i i i 的猪可以被这条抛物线杀死，反之此抛物线不会对这只猪造成任何影响。 用位运算乱搞就可以表示杀猪了 QwQ. 真·题解由于弹弓的位置确定，为 (0,0) (0,0) (0,0)，则可以由两个点唯一确定出一条形如题目描述中 ax2+by=0 a x ^ 2 + b y = 0 ax​2​​+by=0 抛物线，枚举每两只猪的坐标，求出 n2 n^2 n​2​​ 条抛物线，并舍去其中不合题意的抛物线（即 a&gt;0 a &gt; 0 a&gt;0 的抛物线），使用一个二进制数来记录每条合法抛物线可击杀的猪。 可以证明，这样枚举一定最优，因为每条击杀猪数目超过 2 2 2 的抛物线，一定会击杀至少两只猪，而所有可至少击杀两只猪的合法抛物线都在枚举的过程中被求出，则如此枚举可以所有击杀猪的数量最多的抛物线。 但是这样还会有几只猪不在我们枚举到的任何一条合法的抛物线上，对于这种猪，我们为其虚拟出一条抛物线，我们不需要知道其方程，只需要标记这条抛物线可以击杀对应的猪即可。 然后建立状态图进行 BFS 即可。 当然在操作的过程中可能会用到各种各样的位运算操作，状压当中常见的奇技淫巧。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 18 + 3;const int MAXS = (1 &lt;&lt; (MAXN + 1));const double EPS = 1e-6; // 精度搞的高一点struct Point &#123; double x, y; Point(double x = 0, double y = 0): x(x), y(y) &#123;&#125;&#125; a[MAXN];inline bool dcmp (double x) &#123; return fabs(x) &lt;= EPS;&#125;inline bool dcmp (double x, double y) &#123; return dcmp(x - y);&#125; // 处理浮点数时常用的根据 EPS 判断相等的技巧struct Line &#123; double a, b; bool valid; unsigned int kill; Line(unsigned int kill = 0): a(0), b(0), valid(true), kill(kill) &#123;&#125; bool operator&lt;(const Line &amp;other) const &#123; return kill &gt; other.kill; &#125; bool operator==(const Line &amp;other) const &#123; return kill == other.kill; &#125;&#125; lines[MAXN * MAXN];struct Node &#123; bool vis; int dist;&#125; N[MAXS];int n, cmd, limit, lineCnt;inline int bfs (int status) &#123; if (!status) return 0; queue&lt;int&gt; q; q.push(status); N[status].vis = true; N[status].dist = 0; while (!q.empty()) &#123; int v = q.front(); q.pop(); if (N[v].dist == limit) continue; for (int i = 1; i &lt;= lineCnt; i++) &#123; Line &amp;l = lines[i]; if (l.valid &amp;&amp; (l.kill &amp; status)) &#123; int u = v; u &amp;= ~l.kill; // 状压通过位运算搞掉 if (!N[u].vis) &#123; N[u].vis = true; N[u].dist = N[v].dist + 1; if (!u) return N[u].dist; q.push(u); &#125; &#125; &#125; &#125; return n;&#125;inline Line getLine (const Point &amp;a, const Point &amp;b) &#123; Line l; l.a = (a.x * b.y - b.x * a.y) / (a.x * b.x * b.x - b.x * a.x * a.x); l.b = (a.y - l.a * a.x * a.x) / a.x; return l;&#125;inline bool onLine (const Line &amp;l, const Point &amp;a) &#123; return dcmp(l.a * a.x * a.x + l.b * a.x, a.y);&#125;inline int solve () &#123; bool flags[MAXN]; for (int i = 1; i &lt;= n; i++) flags[i] = false; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; if (dcmp(a[i].x, a[j].x)) continue; Line l = getLine(a[i], a[j]); if (l.a &gt;= 0) continue; flags[i] = flags[j] = true; lines[++lineCnt] = l; &#125; &#125; for (int i = 1; i &lt;= lineCnt; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (onLine(lines[i], a[j])) &#123; lines[i].kill |= (1u &lt;&lt; (j - 1)); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!flags[i]) &#123; lines[++lineCnt] = Line(1u &lt;&lt; (i - 1)); // 或运算标记能击杀的猪的编号 &#125; &#125; sort(lines + 1, lines + lineCnt + 1); for (int i = 1; i &lt;= lineCnt; i++) &#123; for (int j = i + 1; j &lt;= lineCnt; j++) &#123; if ((lines[i].kill | lines[j].kill) == lines[i].kill) &#123; lines[j].valid = false; &#125; // 如果抛物线i能击杀抛物线j能击杀的所有猪，而且能击杀抛物线j不能击杀的猪，则使用抛物线j明显不优 &#125; &#125; for (unsigned int i = 0; i &lt; (1u &lt;&lt; n); i++) &#123; N[i].vis = false; &#125; return bfs((1u &lt;&lt; n) - 1);&#125;int main() &#123; freopen(\"angrybirds.in\", \"r\", stdin); freopen(\"angrybirds.out\", \"w\", stdout); int t; scanf(\"%d\", &amp;t); while (t--) &#123; scanf(\"%d %d\", &amp;n, &amp;cmd); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%lf %lf\", &amp;a[i].x, &amp;a[i].y); &#125; lineCnt = 0; if (cmd == 1) &#123; limit = ceil(double(n) / 3 + 1); &#125; else &#123; limit = n; &#125; printf(\"%d\\n\", solve()); &#125; fclose(stdin); fclose(stdout);&#125; 最后写完这题才发现，貌似那个作弊指令没有什么卵用","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.github.io/tags/NOIP/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://sulfur6.github.io/tags/状态压缩/"},{"name":"BFS","slug":"BFS","permalink":"http://sulfur6.github.io/tags/BFS/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"蚯蚓 - 单调队列，NOIP2016","slug":"NOIP2016-earthworm","date":"2016-11-30T13:15:33.000Z","updated":"2017-06-02T13:36:00.000Z","comments":true,"path":"NOIP2016-earthworm/","link":"","permalink":"http://sulfur6.github.io/NOIP2016-earthworm/","excerpt":"本题中，我们将用符号 ⌊c⌋ \\lfloor c \\rfloor ⌊c⌋ 表示对 c c c 向下取整，例如：⌊3.0⌋=⌊3.1⌋=⌊3.9⌋=3 \\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3 ⌊3.0⌋=⌊3.1⌋=⌊3.9⌋=3。 蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。 蛐蛐国里现在共有 n n n 只蚯蚓（n n n 为正整数）。每只蚯蚓拥有长度，我们设第 i i i 只蚯蚓的长度为 ai a_i a​i​​（i=1,2,…,n i = 1, 2, \\ldots , n i=1,2,…,n），并保证所有的长度都是非负整数（即：可能存在长度为 0 0 0 的蚯蚓）。 每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 p p p（是满足 0&lt;p&lt;1 0 &lt; p &lt; 1 0&lt;p&lt;1 的有理数）决定，设这只蚯蚓长度为 x x x，神刀手会将其切成两只长度分别为 ⌊px⌋ \\lfloor px \\rfloor ⌊px⌋ 和 x−⌊px⌋ x - \\lfloor px \\rfloor x−⌊px⌋ 的蚯蚓。特殊地，如果这两个数的其中一个等于 0 0 0，则这个长度为 0 0 0 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 q q q（是一个非负整常数）。 蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 m m m 秒才能到来 ……（m m m 为非负整数） 蛐蛐国王希望知道这 m m m 秒内的战况。具体来说，他希望知道： m m m 秒内，每一秒被切断的蚯蚓被切断前的长度（有 m m m 个数）； m m m 秒后，所有蚯蚓的长度（有 n+m n + m n+m 个数）。 蛐蛐国王当然知道怎么做啦！但是他想考考你 ……","text":"本题中，我们将用符号 ⌊c⌋ \\lfloor c \\rfloor ⌊c⌋ 表示对 c c c 向下取整，例如：⌊3.0⌋=⌊3.1⌋=⌊3.9⌋=3 \\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3 ⌊3.0⌋=⌊3.1⌋=⌊3.9⌋=3。 蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。 蛐蛐国里现在共有 n n n 只蚯蚓（n n n 为正整数）。每只蚯蚓拥有长度，我们设第 i i i 只蚯蚓的长度为 ai a_i a​i​​（i=1,2,…,n i = 1, 2, \\ldots , n i=1,2,…,n），并保证所有的长度都是非负整数（即：可能存在长度为 0 0 0 的蚯蚓）。 每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 p p p（是满足 0&lt;p&lt;1 0 &lt; p &lt; 1 0&lt;p&lt;1 的有理数）决定，设这只蚯蚓长度为 x x x，神刀手会将其切成两只长度分别为 ⌊px⌋ \\lfloor px \\rfloor ⌊px⌋ 和 x−⌊px⌋ x - \\lfloor px \\rfloor x−⌊px⌋ 的蚯蚓。特殊地，如果这两个数的其中一个等于 0 0 0，则这个长度为 0 0 0 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 q q q（是一个非负整常数）。 蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 m m m 秒才能到来 ……（m m m 为非负整数） 蛐蛐国王希望知道这 m m m 秒内的战况。具体来说，他希望知道： m m m 秒内，每一秒被切断的蚯蚓被切断前的长度（有 m m m 个数）； m m m 秒后，所有蚯蚓的长度（有 n+m n + m n+m 个数）。 蛐蛐国王当然知道怎么做啦！但是他想考考你 …… 链接LYOI#103 题解当 q=0 q = 0 q=0 时，首先将蚯蚓排序，然后每次将切割后的两段蚯蚓分别放入两个队列中，则三个队列始终是单调的。设第 i i i 次取出并切开的蚯蚓的长度为 ai a_i a​i​​，切开之后两段的长度分别为 li l_i l​i​​ 和 ri r_i r​i​​，那么对于第 i+1 i + 1 i+1 取出的蚯蚓，一定有 ai+1&lt;ai a_{i + 1} &lt; a_i a​i+1​​&lt;a​i​​，这是因为我们每次取最长的来切并且所有的蚯蚓长度只会减少，由此可得，一定有 li+1&lt;li,ri+1&lt;ri l_{i + 1} &lt; l_i, r_{i + 1} &lt; r_i l​i+1​​&lt;l​i​​,r​i+1​​&lt;r​i​​。 当 q≠0 q \\neq 0 q≠0时，每秒钟除了被切的蚯蚓，其他所有蚯蚓长度增加 q q q，可以将其余蚯蚓增加 q q q 改为被切开的两段减少 q q q ，此时三个序列仍满足单调性，正确性显然。 时间复杂度为 O(nlogn+m) O(n\\log n + m) O(nlogn+m)，如果被辣鸡stl中队列卡常，可以尝试手写队列。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;climits&gt;using namespace std;const int MAXN = 100000;const int MAXM = 70000000;queue&lt;int&gt; q[3];int getMax () &#123; int res = -1; for (int i = 0; i &lt; 3; i++) if (!q[i].empty() &amp;&amp; (res == -1 || q[i].front() &gt; q[res].front())) res = i; return res;&#125;bool cmp (int a, int b) &#123; return a &gt; b; &#125;int len[MAXN + 1];int main () &#123; freopen(\"earthworm.in\", \"r\", stdin); freopen(\"earthworm.out\", \"w\", stdout); int n, m, k, u, v, t; scanf(\"%d %d %d %d %d %d\", &amp;n, &amp;m, &amp;k, &amp;u, &amp;v, &amp;t); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;len[i]); sort(len, len + n, cmp); for (int i = 0; i &lt; n; i++) q[0].push(len[i]); int d = 0, frt; for (int i = 1; i &lt;= m; i++) &#123; int j = getMax(); frt = q[j].front(); q[j].pop(); frt += d; if (i % t == 0) printf(\"%d \", frt); int a = static_cast&lt;long long&gt;(frt) * u / v, b = frt - a; d += k; a -= d, b -= d; q[1].push(a); q[2].push(b); &#125; printf(\"\\n\"); for (int i = 1; i &lt;= n + m; i++) &#123; int j = getMax(); int ans = q[j].front(); q[j].pop(); ans += d; if (i % t == 0) printf(\"%d \", ans); &#125; fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.github.io/tags/NOIP/"},{"name":"单调队列","slug":"单调队列","permalink":"http://sulfur6.github.io/tags/单调队列/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"组合数问题 - 组合数学，递推，二维前缀和","slug":"NOIP2016-problem","date":"2016-11-30T13:15:30.000Z","updated":"2017-06-02T13:35:10.000Z","comments":true,"path":"NOIP2016-problem/","link":"","permalink":"http://sulfur6.github.io/NOIP2016-problem/","excerpt":"组合数表示的是从 n n n 个物品中选出 m m m 个物品的方案数。举个例子，从 (1,2,3) (1, 2, 3) (1,2,3) 三个物品中选择两个物品可以有 (1,2) (1, 2) (1,2)，(1,3) (1, 3) (1,3)，(2,3) (2, 3) (2,3) 这三种选择方法。 根据组合数的定义，我们可以给出计算组合数的一般公式： Cnm=n!m!(n−m)! C_n ^ m = \\frac{n!}{m!(n - m)!} C​n​m​​=​m!(n−m)!​​n!​​其中 n!=1×2×⋯×n n! = 1 \\times 2 \\times \\cdots \\times n n!=1×2×⋯×n。 小葱想知道如果给定 n n n，m m m 和 k k k，对于所有的 0≤i≤n 0 \\leq i \\leq n 0≤i≤n，0≤j≤min(i,m) 0 \\leq j \\leq \\min(i, m) 0≤j≤min(i,m) 有多少对 (i,j) (i, j) (i,j) 满足是 k k k 的倍数。","text":"组合数表示的是从 n n n 个物品中选出 m m m 个物品的方案数。举个例子，从 (1,2,3) (1, 2, 3) (1,2,3) 三个物品中选择两个物品可以有 (1,2) (1, 2) (1,2)，(1,3) (1, 3) (1,3)，(2,3) (2, 3) (2,3) 这三种选择方法。 根据组合数的定义，我们可以给出计算组合数的一般公式： Cnm=n!m!(n−m)! C_n ^ m = \\frac{n!}{m!(n - m)!} C​n​m​​=​m!(n−m)!​​n!​​其中 n!=1×2×⋯×n n! = 1 \\times 2 \\times \\cdots \\times n n!=1×2×⋯×n。 小葱想知道如果给定 n n n，m m m 和 k k k，对于所有的 0≤i≤n 0 \\leq i \\leq n 0≤i≤n，0≤j≤min(i,m) 0 \\leq j \\leq \\min(i, m) 0≤j≤min(i,m) 有多少对 (i,j) (i, j) (i,j) 满足是 k k k 的倍数。 链接LYOI# 题解组合数递推，你们乐意叫Pascal定理就叫好了反正我叫杨辉三角。。。 Cnm=Cn−1m+Cn−1m−1 C_{n}^{m} = C_{n-1}^{m} + C_{n-1}^{m-1} C​n​m​​=C​n−1​m​​+C​n−1​m−1​​递推过程中每次取模，若该位取模后为000则记该位答案为111，反之为000，对答案数组求二维前缀和，每次O(1)O(1)O(1)查询即可。 总复杂度O(2×20002+T)O(2 \\times 2000^2 + T)O(2×2000​2​​+T) 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2000;int f[MAXN + 1][MAXN + 1], ans[MAXN + 1][MAXN + 1];int main () &#123; freopen(\"problem.in\", \"r\", stdin); freopen(\"problem.out\", \"w\", stdout); int t, k; scanf(\"%d %d\", &amp;t, &amp;k); for (int i = 0; i &lt;= MAXN; i++) f[i][0] = f[i][i] = 1; for (int i = 2; i &lt;= MAXN; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % k; if (f[i][j] == 0) ans[i][j]++; &#125; &#125; for (int i = 1; i &lt;= MAXN; i++) &#123; for (int j = 1; j &lt;= MAXN; j++) &#123; ans[i][j] = ans[i - 1][j] + ans[i][j - 1] - ans[i - 1][j - 1] + ans[i][j]; &#125; &#125; while (t--) &#123; int n, m; scanf(\"%d %d\", &amp;n, &amp;m); printf(\"%d\\n\", ans[n][m]); &#125; fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.github.io/tags/NOIP/"},{"name":"组合数学","slug":"组合数学","permalink":"http://sulfur6.github.io/tags/组合数学/"},{"name":"递推","slug":"递推","permalink":"http://sulfur6.github.io/tags/递推/"},{"name":"前缀和","slug":"前缀和","permalink":"http://sulfur6.github.io/tags/前缀和/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"换教室 - NOIP2016，Floyd，概率与期望","slug":"NOIP2016-classroom","date":"2016-11-30T13:15:25.000Z","updated":"2017-06-02T13:34:54.000Z","comments":true,"path":"NOIP2016-classroom/","link":"","permalink":"http://sulfur6.github.io/NOIP2016-classroom/","excerpt":"对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。 在可以选择的课程中，有 2n 2n 2n 节课程安排在 n n n 个时间段上。在第 i i i （1≤i≤n 1 \\leq i \\leq n 1≤i≤n）个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室 ci c_i c​i​​ 上课，而另一节课程在教室 di d_i d​i​​ 进行。 在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的 n n n 节安排好的课程。如果学生想更换第i节课程的教室，则需要提出申请。若申请通过，学生就可以在第 i i i 个时间段去教室 di d_i d​i​​ 上课，否则仍然在教室 ci c_i c​i​​ 上课。 由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第 i i i 节课程的教室时，申请被通过的概率是一个已知的实数 ki k_i k​i​​，并且对于不同课程的申请，被通过的概率是互相独立的。 学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多 m m m 节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请白己最希望更换教室的 m m m 门课程，也可以不用完这 m m m 个申请的机会，甚至可以一门课程都不申请。 因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。 牛牛所在的大学有 v v v 个教室，有 e e e 条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第 i i i（1≤i≤n−1 1 \\leq i \\leq n - 1 1≤i≤n−1）节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。 现在牛牛想知道，申请哪几门课程可以使他因在教室问移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。","text":"对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。 在可以选择的课程中，有 2n 2n 2n 节课程安排在 n n n 个时间段上。在第 i i i （1≤i≤n 1 \\leq i \\leq n 1≤i≤n）个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室 ci c_i c​i​​ 上课，而另一节课程在教室 di d_i d​i​​ 进行。 在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的 n n n 节安排好的课程。如果学生想更换第i节课程的教室，则需要提出申请。若申请通过，学生就可以在第 i i i 个时间段去教室 di d_i d​i​​ 上课，否则仍然在教室 ci c_i c​i​​ 上课。 由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第 i i i 节课程的教室时，申请被通过的概率是一个已知的实数 ki k_i k​i​​，并且对于不同课程的申请，被通过的概率是互相独立的。 学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多 m m m 节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请白己最希望更换教室的 m m m 门课程，也可以不用完这 m m m 个申请的机会，甚至可以一门课程都不申请。 因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。 牛牛所在的大学有 v v v 个教室，有 e e e 条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第 i i i（1≤i≤n−1 1 \\leq i \\leq n - 1 1≤i≤n−1）节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。 现在牛牛想知道，申请哪几门课程可以使他因在教室问移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。 链接LYOI#101 题解\u0010这题说是考了期望，然而关于概率的内容只有期望的定义和概率的乘法计算，当然也考了十分冷门的 。 这道题只有 300 300 300 个教室，所以可以用 求出多源最短路，在用 的时候注意判断重边，而且要注意一个教室到它自己的距离为 0 0 0 ，即邻接矩阵中 g(i,i) \\mathrm{g}(i,i) g(i,i) 应设为 0 0 0 而非常用的正无穷。 DP： 设状态 f(i,j,k) f(i,j,k) f(i,j,k) 表示在前 i i i 个阶段，已经用掉了 j j j 次申请机会，本次是否申请（k=0 k = 0 k=0 表示本次不申请，k=1 k = 1 k=1 表示本次申请）， 表示教室 i,ji, ji,j 之间的距离。 考虑 f(i,j,0) f(i,j,0) f(i,j,0) 的转移，上一次可以申请，也可以不申请，反正本次一定不申请是确定的，则有： f(i,j,0)=min{f(i−1,j,0)+dist(c(i−1),c(i))f(i−1,j,1)+dist(d(i−1),c(i))×k(i−1)+dist(c(i−1),c(i))×(1−k(i−1)) f(i, j, 0) = \\min \\begin{cases} f(i - 1, j, 0) + \\mathrm{dist}(c(i - 1), c(i)) \\\\ \\\\ \\begin{aligned} f(i - 1, j, 1) &amp; + \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\\\ &amp; + \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1)) \\end{aligned} \\end{cases} f(i,j,0)=min​⎩​⎪​⎪​⎨​⎪​⎪​⎧​​​f(i−1,j,0)+dist(c(i−1),c(i))​​​f(i−1,j,1)​​​​+dist(d(i−1),c(i))×k(i−1)​+dist(c(i−1),c(i))×(1−k(i−1))​​​​f(i,j,1) f(i,j,1) f(i,j,1) 的转移要长一点： f(i,j,1)=min{f(i−1,j−1,0)+dist(c(i−1),d(i))×k(i)+dist(c(i−1),c(i))×(1−k(i))f(i−1,j−1,1)+dist(d(i−1),d(i))×k(i−1)×k(i)+dist(c(i−1),d(i))×(1−k(i−1))×k(i)+dist(d(i−1),c(i))×k(i−1)×(1−k(i))+dist(c(i−1),c(i))×(1−k(i−1))×(1−k(i)) f(i, j, 1) = \\min \\begin{cases} \\begin{aligned} f(i - 1, j - 1, 0) &amp;+ \\mathrm{dist}(c(i - 1), d(i)) \\times k(i) \\\\ &amp;+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i)) \\end{aligned} \\\\ \\\\ \\begin{aligned} f(i - 1, j - 1, 1) &amp;+ \\mathrm{dist}(d(i - 1), d(i)) \\times k(i - 1) \\times k(i) \\\\ &amp;+ \\mathrm{dist}(c(i - 1), d(i)) \\times (1 - k(i - 1)) \\times k(i) \\\\ &amp;+ \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\times (1 - k(i)) \\\\ &amp;+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1)) \\times (1 - k(i)) \\end{aligned} \\end{cases} f(i,j,1)=min​⎩​⎪​⎪​⎪​⎪​⎪​⎪​⎪​⎪​⎨​⎪​⎪​⎪​⎪​⎪​⎪​⎪​⎪​⎧​​​​f(i−1,j−1,0)​​​​+dist(c(i−1),d(i))×k(i)​+dist(c(i−1),c(i))×(1−k(i))​​​​​f(i−1,j−1,1)​​​​​​+dist(d(i−1),d(i))×k(i−1)×k(i)​+dist(c(i−1),d(i))×(1−k(i−1))×k(i)​+dist(d(i−1),c(i))×k(i−1)×(1−k(i))​+dist(c(i−1),c(i))×(1−k(i−1))×(1−k(i))​​​​边界 f(i,0,1)=+∞f(1,0,0)=0 \\begin{aligned} f(i, 0, 1) &amp;= +\\infty \\\\ f(1, 0, 0) &amp;= 0 \\end{aligned} ​f(i,0,1)​f(1,0,0)​​​=+∞​=0​​时间复杂度为 O(v3+nm) O(v ^ 3 + nm) O(v​3​​+nm)。 代码#include &lt;cstdio&gt;#include &lt;cfloat&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;const int MAXN = 2000;const int MAXM = 2000;const int MAXV = 300;const int MAXE = 90000;int g[MAXV + 1][MAXV + 1], d[MAXN + 1], c[MAXN + 1], n, m, v, e;double k[MAXN + 1];void floyd () &#123; for (int a = 1; a &lt;= v; a++) &#123; for (int b = 1; b &lt;= v; b++) &#123; for (int c = 1; c &lt;= v; c++) &#123; if (g[b][a] != INT_MAX &amp;&amp; g[a][c] != INT_MAX &amp;&amp; g[b][c] &gt; g[b][a] + g[a][c]) &#123; g[b][c] = g[b][a] + g[a][c]; &#125; &#125; &#125; &#125;&#125;double f[MAXN + 1][MAXM + 1][2];int main () &#123; freopen(\"classroom.in\", \"r\", stdin); freopen(\"classroom.out\", \"w\", stdout); scanf(\"%d %d %d %d\", &amp;n, &amp;m, &amp;v, &amp;e); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;c[i]); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;d[i]); for (int i = 1; i &lt;= n; i++) scanf(\"%lf\", &amp;k[i]); for (int i = 1; i &lt;= v; i++) &#123; for (int j = 1; j &lt;= v; j++) &#123; g[i][j] = INT_MAX; &#125; &#125; for (int i = 1; i &lt;= e; i++) &#123; int fr, to, w; scanf(\"%d %d %d\", &amp;fr, &amp;to, &amp;w); g[fr][to] = g[to][fr] = min(w, g[fr][to]); &#125; floyd(); for (int i = 1; i &lt;= v; i++) g[i][i] = 0; f[1][0][0] = 0; f[1][0][1] = DBL_MAX; for (int i = 2; i &lt;= n; i++) &#123; f[i][0][0] = f[i - 1][0][0] + g[c[i - 1]][c[i]]; f[i][0][1] = DBL_MAX; for (int j = 1; j &lt;= m; j++) &#123; f[i][j][0] = f[i][j][1] = DBL_MAX; if (f[i - 1][j][0] != DBL_MAX) &#123; f[i][j][0] = min(f[i][j][0], f[i - 1][j][0] + g[c[i - 1]][c[i]]); &#125; if (f[i - 1][j][1] != DBL_MAX) &#123; f[i][j][0] = min(f[i][j][0], f[i - 1][j][1] + (g[c[i - 1]][c[i]] * (1 - k[i - 1])) + (g[d[i - 1]][c[i]] * k[i - 1])); &#125; if (f[i - 1][j - 1][0] != DBL_MAX) &#123; f[i][j][1] = min(f[i][j][1], f[i - 1][j - 1][0] + (g[c[i - 1]][d[i]] * k[i]) + (g[c[i - 1]][c[i]] * (1 - k[i]))); &#125; if (f[i - 1][j - 1][1] != DBL_MAX) &#123; f[i][j][1] = min(f[i][j][1], f[i - 1][j - 1][1] + (g[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i])) + (g[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i])) + (g[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i]) + (g[d[i - 1]][d[i]] * k[i - 1] * k[i])); &#125; &#125; &#125; double ans = DBL_MAX; for (int j = 0; j &lt;= m; j++) &#123; ans = min(ans, f[n][j][0]); ans = min(ans, f[n][j][1]); &#125; printf(\"%.2lf\\n\", ans); fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.github.io/tags/NOIP/"},{"name":"Floyd","slug":"Floyd","permalink":"http://sulfur6.github.io/tags/Floyd/"},{"name":"概率","slug":"概率","permalink":"http://sulfur6.github.io/tags/概率/"},{"name":"数学期望","slug":"数学期望","permalink":"http://sulfur6.github.io/tags/数学期望/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"玩具迷题 - NOIP2016，模拟","slug":"NOIP2016-toy","date":"2016-11-30T13:15:19.000Z","updated":"2017-06-02T13:34:24.000Z","comments":true,"path":"NOIP2016-toy/","link":"","permalink":"http://sulfur6.github.io/NOIP2016-toy/","excerpt":"小南有一套可爱的玩具小人，它们各有不同的职业。 有一天，这些玩具小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外。 这时 singer 告诉小南一个谜题：「眼镜藏在我左数第 3 3 个玩具小人的右数第 111 个玩具小人的左数第 222 个玩具小人那里。」 小南发现，这个谜题中玩具小人的朝向非常关键， 因为朝内和朝外的玩具小人的左右方向是相反的：面朝圈内的玩具小人，它的左边是顺时针方向，右边是逆时针方向；而面向圈外的玩具小人，它的左边是逆时针方向，右边是顺时针方向。 小南一边艰难地辨认着玩具小人，一边数着： singer 朝内，左数第 333 个是 archer。 archer 朝外，右数第 111 个是 thinker。 thinker 朝外，左数第 222 个是 writer。 所以眼镜藏在 writer 这里！ 虽然成功找回了眼镜，但小南并没有放心。如果下次有更多的玩具小人藏他的眼镜，或是谜题的长度更长，他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。这样的谜题具体可以描述为： 有n n n个玩具小人围成一圈，已知它们的职业和朝向。现在第 111 个玩具小人告诉小南一个包含 mmm 条指令的谜题。其中第 iii 条指令形如「左数/右数第 sis_is​i​​ 个玩具小人」。你需要输出依次数完这些指令后，到达的玩具小人的职业。","text":"小南有一套可爱的玩具小人，它们各有不同的职业。 有一天，这些玩具小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外。 这时 singer 告诉小南一个谜题：「眼镜藏在我左数第 3 3 个玩具小人的右数第 111 个玩具小人的左数第 222 个玩具小人那里。」 小南发现，这个谜题中玩具小人的朝向非常关键， 因为朝内和朝外的玩具小人的左右方向是相反的：面朝圈内的玩具小人，它的左边是顺时针方向，右边是逆时针方向；而面向圈外的玩具小人，它的左边是逆时针方向，右边是顺时针方向。 小南一边艰难地辨认着玩具小人，一边数着： singer 朝内，左数第 333 个是 archer。 archer 朝外，右数第 111 个是 thinker。 thinker 朝外，左数第 222 个是 writer。 所以眼镜藏在 writer 这里！ 虽然成功找回了眼镜，但小南并没有放心。如果下次有更多的玩具小人藏他的眼镜，或是谜题的长度更长，他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。这样的谜题具体可以描述为： 有n n n个玩具小人围成一圈，已知它们的职业和朝向。现在第 111 个玩具小人告诉小南一个包含 mmm 条指令的谜题。其中第 iii 条指令形如「左数/右数第 sis_is​i​​ 个玩具小人」。你需要输出依次数完这些指令后，到达的玩具小人的职业。 链接LYOI#99 题解模拟。 根据朝向，顺加逆减，每次取模，防止越界 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;const int MAXN = 100000;string name[MAXN + 1]; int face[MAXN + 1];int main () &#123; freopen(\"toy.in\", \"r\", stdin); freopen(\"toy.out\", \"w\", stdout); int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = n; i &gt;= 1; i--) &#123; scanf(\"%d\", &amp;face[i]); cin &gt;&gt; name[i]; &#125; name[0] = name[n]; face[0] = face[n]; // for (int i = n; i &gt;= 1; i--) cout &lt;&lt; face[i] &lt;&lt; endl; int dirans = n; for (int i = 0; i &lt; m; i++) &#123; int dir, vec; scanf(\"%d %d\", &amp;dir, &amp;vec); if (face[dirans] == 0 &amp;&amp; dir == 0) &#123; int mov = (dirans + vec) % n; dirans = mov; &#125; else if (face[dirans] == 0 &amp;&amp; dir == 1) &#123; int mov = ((dirans - vec) + n) % n; dirans = mov; &#125; else if (face[dirans] == 1 &amp;&amp; dir == 0) &#123; int mov = ((dirans - vec) + n) % n; dirans = mov; &#125; else if (face[dirans] == 1 &amp;&amp; dir == 1) &#123; int mov = (dirans + vec) % n; dirans = mov; &#125; &#125; cout &lt;&lt; name[dirans] &lt;&lt; endl; fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.github.io/tags/NOIP/"},{"name":"模拟","slug":"模拟","permalink":"http://sulfur6.github.io/tags/模拟/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"石子归并，区间DP","slug":"mergeStone","date":"2016-11-30T12:31:45.000Z","updated":"2017-06-02T13:42:28.000Z","comments":true,"path":"mergeStone/","link":"","permalink":"http://sulfur6.github.io/mergeStone/","excerpt":"有nnn堆石子排成一列，每堆石子有一个重量wiw_iw​i​​, 每次合并可以合并相邻的两堆石子，一次合并的代价为两堆石子的重量和wi+wi+1w_i+w_{i+1}w​i​​+w​i+1​​，求怎样合并能使合并代价最小，输出最小代价。","text":"有nnn堆石子排成一列，每堆石子有一个重量wiw_iw​i​​, 每次合并可以合并相邻的两堆石子，一次合并的代价为两堆石子的重量和wi+wi+1w_i+w_{i+1}w​i​​+w​i+1​​，求怎样合并能使合并代价最小，输出最小代价。 题解区间DP 记合并[l,r][l,r][l,r]这段区间内的石子所需的代价为f(l,r)f(l,r)f(l,r)，则有: f(l,r)=mink=lr−1(f(l,r), f(l,k)+f(k+1,r))+sum(l,r) f(l,r)=\\min_{k=l}^{r-1}(f(l,r),\\ f(l,k) + f(k+1,r))+sum(l,r) f(l,r)=​k=l​min​r−1​​(f(l,r), f(l,k)+f(k+1,r))+sum(l,r)记sum(l,r)=∑i=lrwisum(l,r)=\\sum\\limits_{i=l}^{r}w_isum(l,r)=​i=l​∑​r​​w​i​​ 那么接下来的工作就是确定递推顺序，这题的递推顺序是从短区间向长区间递推，因为我们发现状态中每次转移需要用到的状态只需要用到从之前的较短的区间中得到的值。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;const int MAXN = 100;int a[MAXN + 1], f[MAXN + 1][MAXN + 1];int main () &#123; int n; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); a[i] = a[i] + a[i - 1]; &#125; for (int i = 1; i &lt;= n; i++) f[i][i] = 0; for (int len = 1; len &lt; n; len++) &#123; int r; for (int l = 1; l &lt;= n - len; l++) &#123; r = l + len; int minn = INT_MAX; for (int k = l; k &lt; r; k++) &#123; minn = min(f[l][k] + f[k + 1][r], minn); &#125; f[l][r] = minn + a[r] - a[l - 1]; &#125; &#125; printf(\"%d\\n\", f[1][n]); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.github.io/tags/DP/"},{"name":"区间DP","slug":"区间DP","permalink":"http://sulfur6.github.io/tags/区间DP/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"火柴排队，贪心，逆序对，NOIP2013","slug":"Sticks-NOIP","date":"2016-11-10T11:47:10.000Z","updated":"2017-06-02T13:43:06.000Z","comments":true,"path":"Sticks-NOIP/","link":"","permalink":"http://sulfur6.github.io/Sticks-NOIP/","excerpt":"给定两个数列 a,b a, b a,b，每个数列中相邻两个数可以交换，求使得 ∑i=1n(ai−bi)2 \\sum\\limits_{i = 1}^{n}(a_i - b_i) ^ 2 ​i=1​∑​n​​(a​i​​−b​i​​)​2​​ 最小的交换次数，答案对 99999997 99999997 99999997 取模","text":"给定两个数列 a,b a, b a,b，每个数列中相邻两个数可以交换，求使得 ∑i=1n(ai−bi)2 \\sum\\limits_{i = 1}^{n}(a_i - b_i) ^ 2 ​i=1​∑​n​​(a​i​​−b​i​​)​2​​ 最小的交换次数，答案对 99999997 99999997 99999997 取模 题解当∣a−b∣|a-b|∣a−b∣尽可能小的时候，(a−b)2(a-b)^2(a−b)​2​​最小，所以，这道题实际上就是让数列aaa中的元素与数列bbb中的元素，按照它们在两个数列中所在的大小位置对应排列，简单来说，比如某个元素aja_ja​j​​在数列aaa中是第三大的，那么满足题意的与他对应的bjb_jb​j​​在数列bbb中也一定是第三大的。详细的证明过程不再赘述（其实是我自己证明困难QwQ） 具体做法就是现将两个数列排序，这样我们就获得了两个数列中哪两个元素应该对应排列在一起，然而实际操作并不需要同时移动两列数，我们只需要固定一列数移动另一列使其满足该大小关系即可，所以我们记录每个元素本来的位置，问题转化为求一个序列中原位置关于另一个序列原位置的逆序对。。确实很绕，上代码理解吧。。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000;const int MOD = 99999997;struct Stick &#123; int id, height; bool operator&lt;(const Stick &amp;other) const &#123; return height &lt; other.height; &#125;&#125; s1[MAXN + 1], s2[MAXN + 1];int t[MAXN + 1], tmp[MAXN + 1];int ans;void mergeSort (int *a, int l, int r) &#123; if (l &gt;= r) return; int mid = (l + r) / 2; mergeSort(a, l, mid); mergeSort(a, mid + 1, r); int i = l, j = mid + 1, k = l; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (a[i] &gt; a[j]) &#123; tmp[k++] = a[j++]; ans = (ans + (mid - i + 1) % MOD) % MOD; &#125; else &#123; tmp[k++] = a[i++]; &#125; &#125; while (i &lt;= mid) tmp[k++] = a[i++]; while (j &lt;= r) tmp[k++] = a[j++]; for (int i = l; i &lt;= r; i++) a[i] = tmp[i]; return;&#125;int main () &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;s1[i].height); s1[i].id = i; &#125; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;s2[i].height); s2[i].id = i; &#125; sort(s1, s1 + n); sort(s2, s2 + n); for (int i = 0; i &lt; n; i++) t[s2[i].id] = s1[i].id; mergeSort(t, 0, n - 1); printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.github.io/tags/NOIP/"},{"name":"贪心","slug":"贪心","permalink":"http://sulfur6.github.io/tags/贪心/"},{"name":"逆序对","slug":"逆序对","permalink":"http://sulfur6.github.io/tags/逆序对/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"花匠，最长波动子序列，NOIP","slug":"Gavin-NicholasAndHisFlower","date":"2016-11-10T11:47:01.000Z","updated":"2017-06-02T13:33:08.000Z","comments":true,"path":"Gavin-NicholasAndHisFlower/","link":"","permalink":"http://sulfur6.github.io/Gavin-NicholasAndHisFlower/","excerpt":"","text":"给定一个序列，求其中最长波动子序列 题解据说这题可以动归，然而感觉动归爆炸，就贪了个心 正解是枚举所有的拐点，将拐点加入子序列中一定比加入其他点更优，因为拐点比可以容纳更多的点在其中波动，最后特判起点和终点是否可以加入序列中即可 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int MAXN = 100000;int height[MAXN + 1];int main () &#123; int n; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;height[i]); &#125; bool isUping = true; int ans = 0; if (height[1] &gt;= height[2]) isUping = false; else isUping = true; for (int i = 2; i &lt;= n - 1; i++) &#123; if (isUping &amp;&amp; height[i] &gt; height[i + 1]) &#123; isUping = false; ans++; &#125; else if (!isUping &amp;&amp; height[i] &lt; height[i + 1]) &#123; isUping = true; ans++; &#125; &#125; if (height[1] == height[2]) ans--; if (height[n - 1] == height[n]) ans--; ans += 2; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.github.io/tags/NOIP/"},{"name":"贪心","slug":"贪心","permalink":"http://sulfur6.github.io/tags/贪心/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"飞扬的小鸟，DP，背包，NOIP2014","slug":"Flappy-Bird","date":"2016-11-08T00:15:09.000Z","updated":"2017-06-16T08:38:42.000Z","comments":true,"path":"Flappy-Bird/","link":"","permalink":"http://sulfur6.github.io/Flappy-Bird/","excerpt":"给定一个长为nnn，高为mmm的二位平面，其中有kkk个管道（不计宽度） 小鸟从平面最左边出发，到达平面最右边时游戏完成 小鸟每单位时间沿横坐标方向右移距离为1，竖直移动距离由玩家控制，如果点击屏幕，小鸟会上升一定高度XXX，每单位时间内可以点击多次，效果叠加，如果不点击屏幕，小鸟会下降一定高度YYY 小鸟位于不同的横坐标位置时，上升高度XXX和下降高度YYY可能互不相同 小鸟高度为mmm时，无法再上升 小鸟高度等于000或小鸟碰到管道时，游戏失败 要求： 如果能完成游戏，输出最少点击屏幕次数 如果不能，输出最多能通过的水管","text":"给定一个长为nnn，高为mmm的二位平面，其中有kkk个管道（不计宽度） 小鸟从平面最左边出发，到达平面最右边时游戏完成 小鸟每单位时间沿横坐标方向右移距离为1，竖直移动距离由玩家控制，如果点击屏幕，小鸟会上升一定高度XXX，每单位时间内可以点击多次，效果叠加，如果不点击屏幕，小鸟会下降一定高度YYY 小鸟位于不同的横坐标位置时，上升高度XXX和下降高度YYY可能互不相同 小鸟高度为mmm时，无法再上升 小鸟高度等于000或小鸟碰到管道时，游戏失败 要求： 如果能完成游戏，输出最少点击屏幕次数 如果不能，输出最多能通过的水管 题解由于每单位时间可以点击多次屏幕，所以对于上升的过程，可以看做一个完全背包。 设f(i,j)f(i,j)f(i,j)表示到达坐标为(i,j)(i,j)(i,j)的点时，所需最少点击次数，这个状态由可以由前一个单位时间中点击若干次屏幕得到，也可以由前一个单位时间中不点击屏幕掉落一段高度得到，由此可得方程： f(i,j)=mink=1j÷Xi−1(f(i−1,j−kXi−1)+k,f(i−1,j+Yi−1)) f(i,j)=\\min\\limits_{k=1}^{j\\div X_{i-1}}(f(i-1,j-kX_{i-1})+k,f(i-1,j+Y_{i-1})) f(i,j)=​k=1​min​j÷X​i−1​​​​(f(i−1,j−kX​i−1​​)+k,f(i−1,j+Y​i−1​​))然而这种情况下每一次枚举的时间复杂度为O(m)O(m)O(m)，总时间复杂度为O(nm2)O(nm^2)O(nm​2​​)，无法通过全部数据 考虑点击kkk次和点击k−1k-1k−1次之间的联系，如果点击kkk次，则可以到达纵坐标为jjj的位置，点击k−1k-1k−1次，可以到达纵坐标为j−Xi−1j-X_{i-1}j−X​i−1​​的位置，由此可得方程（仅考虑点击时的情况）： f(i,j)=min(f(i−1,j−Xi−1)+1,f(i,j−Xi−1)+1) f(i,j)=\\min(f(i-1,j-X_{i-1})+1,f(i,j-X_{i-1})+1) f(i,j)=min(f(i−1,j−X​i−1​​)+1,f(i,j−X​i−1​​)+1)在上述仅考虑点击时的方程中，从f(i,j−Xi−1)f(i,j-X_{i-1})f(i,j−X​i−1​​)转移到f(i,j)f(i,j)f(i,j)的过程，可看做由f(i−1,j−2Xi−1)f(i-1,j-2X_{i-1})f(i−1,j−2X​i−1​​)转移到f(i,j)f(i,j)f(i,j)，得到f(i,j−Xi−1)f(i,j-X_{i-1})f(i,j−X​i−1​​)的过程同理，这样枚举是完整的完全背包，可以保证可点击多次 在使用优化过的方程的时候，我们不能在处理点击的同时处理不点击，因为在同一时刻我们不能既点击又不点击，所以说对于不点击的处理应该放在处理完所有的点击之后。 而且，由于我们的某个状态f(i,j)f(i,j)f(i,j)可能由f(i,j−Xi−1)f(i,j-X_{i-1})f(i,j−X​i−1​​)递推得来，而(i,j−Xi−1)(i,j-X_{i-1})(i,j−X​i−1​​)这个位置可能是障碍，所以我们不能直接将所有的障碍的答案设为INT_MAX（不可达到），而是递推得到某列的所有答案后，再将该列的水管位置的对应答案设为INT_MAX 前面递推的答案只针对(i,1)→(i,m−1)(i,1) \\rightarrow (i,m-1)(i,1)→(i,m−1)，对于(i,m)(i,m)(i,m)，我们要做特殊处理 最终输出答案时，对所有最右列的fff值取最小，若最右列的值全部都为INT_MAX，则证明游戏不可完成，我们就从第n−1n-1n−1列向左寻找可以通过的某一列，记录包括这一列之前一共有多少个障碍，此为小鸟最终能通过的障碍数量 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;const int MAXN = 10000;const int MAXM = 1000;struct Pipe &#123; bool exist; int top, bot;&#125; a[MAXN + 1];int n, m, k, X[MAXN + 1], Y[MAXN + 1];template &lt;typename T&gt; bool cmin (T &amp;a, const T &amp;b) &#123; return (a &gt; b) ? (a = b, true) : false;&#125;int main () &#123; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d %d\", &amp;X[i], &amp;Y[i]); &#125; for (int i = 0; i &lt; k; i++) &#123; int x; scanf(\"%d\", &amp;x); a[x].exist = true; scanf(\"%d %d\", &amp;a[x].bot, &amp;a[x].top); &#125; static int f[MAXN + 1][MAXM + 1]; f[0][0] = INT_MAX; for (int i = 1; i &lt;= n; i++) &#123; f[i][0] = INT_MAX; for (int j = 1; j &lt; m; j++) &#123; f[i][j] = INT_MAX; if (j &gt;= X[i - 1]) &#123; if (f[i - 1][j - X[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j - X[i - 1]] + 1); if (f[i][j - X[i - 1]] != INT_MAX) cmin(f[i][j], f[i][j - X[i - 1]] + 1); &#125; &#125; for (int j = 1; j &lt;= m - Y[i - 1]; j++) &#123; if (f[i - 1][j + Y[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + Y[i - 1]]); &#125; f[i][m] = INT_MAX; for (k = m - X[i - 1]; k &lt;= m; k++) &#123; if (f[i - 1][k] != INT_MAX) cmin(f[i][m], f[i - 1][k] + 1); if (f[i][k] != INT_MAX) cmin(f[i][m], f[i][k] + 1); &#125; if (a[i].exist) for (int j = 1; j &lt;= m; j++) if (j &gt;= a[i].top || j &lt;= a[i].bot) f[i][j] = INT_MAX; &#125; int clicks = INT_MAX; for (int i = 1; i &lt;= m; i++) cmin(clicks, f[n][i]); //printf(\"%d\\n\", clicks); if (clicks != INT_MAX) &#123; printf(\"1\\n%d\\n\", clicks); &#125; else &#123; int pos = -1; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (f[i][j] != INT_MAX) &#123; pos = i; break; &#125; &#125; if (pos != -1) break; &#125; int cnt = 0; for (int i = 1; i &lt;= pos; i++) if (a[i].exist) cnt++; printf(\"0\\n%d\\n\", cnt); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.github.io/tags/NOIP/"},{"name":"DP","slug":"DP","permalink":"http://sulfur6.github.io/tags/DP/"},{"name":"背包","slug":"背包","permalink":"http://sulfur6.github.io/tags/背包/"},{"name":"完全背包","slug":"完全背包","permalink":"http://sulfur6.github.io/tags/完全背包/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"挖矿，DP，扩展欧几里德","slug":"mining-dp","date":"2016-11-07T12:01:29.000Z","updated":"2017-06-02T13:44:32.000Z","comments":true,"path":"mining-dp/","link":"","permalink":"http://sulfur6.github.io/mining-dp/","excerpt":"有m+1m+1m+1个星球，从000到mmm编号，yqy最初在000号星球 有nnn处矿体，第iii出矿体有aia_ia​i​​单位原矿，在编号为bib_ib​i​​的星球上 飞船每次只能从xxx号星球移动到x+4x+4x+4或x+7x+7x+7号星球，每到一个星球yqy会采走该星球上所有的原矿 求yqy最多能采走多少原矿 注意： yqy不必最终到达mmm号星球 对于100%100\\%100%的数据，n≤105,m≤109n\\leq 10^5, m\\leq 10^9n≤10​5​​,m≤10​9​​","text":"有m+1m+1m+1个星球，从000到mmm编号，yqy最初在000号星球 有nnn处矿体，第iii出矿体有aia_ia​i​​单位原矿，在编号为bib_ib​i​​的星球上 飞船每次只能从xxx号星球移动到x+4x+4x+4或x+7x+7x+7号星球，每到一个星球yqy会采走该星球上所有的原矿 求yqy最多能采走多少原矿 注意： yqy不必最终到达mmm号星球 对于100%100\\%100%的数据，n≤105,m≤109n\\leq 10^5, m\\leq 10^9n≤10​5​​,m≤10​9​​ 题解设f(i)f(i)f(i)表示走到第iii个星球时最多可以得到的原矿数量，用viv_iv​i​​表示第iii个星球上有的原矿数量，易得： f(i)=max(f(i−4),f(i−7))+wi f(i)=\\max(f(i-4),f(i-7))+w_i f(i)=max(f(i−4),f(i−7))+w​i​​然而对于100%100\\%100%的数据，mmm很大，这样会超时超内存，所以我们需要做一些优化。 首先扯一会Exgcd： 对于一个方程ax+by=cax+by=cax+by=c，此方程有整数解的充要条件是gcd(a,b)∣c\\gcd(a,b)\\mid cgcd(a,b)∣c，对于本题中每一个想要到达的距离ddd，可以写成4x+7y=d4x+7y=d4x+7y=d的形式，由于gcd(4,7)=1\\gcd(4,7)=1gcd(4,7)=1所以ddd为任意正整数时，该方程都有整数解。 然而，本题只有当所求x,yx,yx,y都为正整数时，才称对应ddd为可到达的。 经过枚举，我们发现，当d≥18d\\geq 18d≥18时，对应的x,yx,yx,y都为整数，也就是说，如果某两个有矿物的星球之间距离大于等于181818，我们可以将它们之间的距离压缩成181818，这样的时间复杂度和空间复杂度就达到了O(n×18)O(n\\times 18)O(n×18)，极限数据n=105n=10^5n=10​5​​，轻松过 代码#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;climits&gt;using namespace std;const int MAXN = 1e5;const int MAXM = 1e9;struct Mine &#123; int pos, val; bool operator&lt;(const Mine &amp;other) const &#123; return pos &lt; other.pos; &#125;&#125; a[MAXN];int main () &#123; freopen(\"mining.in\", \"r\", stdin); freopen(\"mining.out\", \"w\", stdout); int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d %d\", &amp;a[i].val, &amp;a[i].pos); &#125; sort(a, a + n); int Del = 0, Last = 0, maxPos = 0; for (int i = 0; i &lt; n; i++) &#123;//压缩距离 a[i].pos -= Del; int Gap = a[i].pos - Last; if (Gap &gt; 18) &#123; int t = Gap - 18; a[i].pos -= t; Del += t; &#125; Last = a[i].pos; maxPos = max(maxPos, a[i].pos); &#125; static int w[MAXN * 18 + 1], f[MAXN * 18 + 1]; for (int i = 0; i &lt; n; i++) w[a[i].pos] += a[i].val; for (int i = 1; i &lt;= maxPos; i++) f[i] = INT_MIN; w[0] = f[0] = 0; int ans = INT_MIN; for (int i = 1; i &lt;= maxPos; i++) &#123; if (i &gt;= 4) f[i] = max(f[i], f[i - 4] + w[i]); if (i &gt;= 7) f[i] = max(f[i], f[i - 7] + w[i]); ans = max(ans, f[i]); &#125; printf(\"%d\\n\", ans); fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.github.io/tags/DP/"},{"name":"数论","slug":"数论","permalink":"http://sulfur6.github.io/tags/数论/"},{"name":"Exgcd","slug":"Exgcd","permalink":"http://sulfur6.github.io/tags/Exgcd/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"子串，DP，NOIP2015","slug":"substring","date":"2016-11-06T11:56:57.000Z","updated":"2017-06-02T13:43:54.000Z","comments":true,"path":"substring/","link":"","permalink":"http://sulfur6.github.io/substring/","excerpt":"有两个仅包含小写英文字母的字符串A和B 现在要从字符串A中取出k个互不重叠的非空子串，然后把这k个子串按照其在字符串A中出现的顺序依次连接起来得到一个新的字符串 求使得新串与B串相同的方案数 子串取出的位置不同，认为是不同的方案。","text":"有两个仅包含小写英文字母的字符串A和B 现在要从字符串A中取出k个互不重叠的非空子串，然后把这k个子串按照其在字符串A中出现的顺序依次连接起来得到一个新的字符串 求使得新串与B串相同的方案数 子串取出的位置不同，认为是不同的方案。 题解设f(i,j,t)f(i,j,t)f(i,j,t)表示使用从串A中前iii位取出的ttt个子串匹配串B前jjj位（必选AiA_iA​i​​）的方案数，g(i,j,t)g(i,j,t)g(i,j,t)表示使用串A中前iii位取出的ttt个子串匹配串B的前jjj位（不必选AiA_iA​i​​）的方案数。 计算f(i,j,t)f(i,j,t)f(i,j,t)时，考虑AiA_iA​i​​作为前一个子串的最后一位的方案数，即f(i−1,j−1,t)f(i-1,j-1,t)f(i−1,j−1,t)，与单独作为一个子串的方案数，即g(i−1,j−1,t−1)g(i-1,j-1,t-1)g(i−1,j−1,t−1)，则对于f(i,j,t)f(i,j,t)f(i,j,t)，有： f(i,j,t)={f(i−1,j−1,t)+g(i−1,j−1,t−1)Ai=Bj0Ai≠Bj f(i,j,t)= \\begin{cases} f(i-1,j-1,t)+g(i-1,j-1,t-1) &amp; A_i = B_j \\\\ 0 &amp; A_i\\neq B_j \\end{cases} f(i,j,t)={​f(i−1,j−1,t)+g(i−1,j−1,t−1)​0​​​A​i​​=B​j​​​A​i​​≠B​j​​​​对于g(i,j,t)g(i,j,t)g(i,j,t)，则有： g(i,j,t)={g(i−1,j,t)+f(i,j,t)Ai=Bjg(i−1,j,t)Ai≠Bj g(i,j,t)= \\begin{cases} g(i-1,j,t)+f(i,j,t) &amp; A_i=B_j \\\\ g(i-1,j,t) &amp; A_i\\neq B_j \\end{cases} g(i,j,t)={​g(i−1,j,t)+f(i,j,t)​g(i−1,j,t)​​​A​i​​=B​j​​​A​i​​≠B​j​​​​需要滚动数组优化 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000;const int MAXM = 200;const int MAXK = 200;const int MOD = 1e9 + 7;int main () &#123; static int f[2][MAXN + 1][MAXM + 1], g[2][MAXN + 1][MAXM + 1]; int n, m, k; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k); static char A[MAXN], B[MAXM]; scanf(\"%s\\n%s\", A, B); g[0][0][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; const int cur = i % 2, pre = !cur; memset(f[cur], 0, sizeof(f[cur])); memset(g[cur], 0, sizeof(g[cur])); g[cur][0][0] = f[cur][0][0] = 1; for (int j = 1; j &lt;= m; j++) &#123; for (int t = 1; t &lt;= min(j, k); t++) &#123; if (A[i - 1] == B[j - 1]) &#123; f[cur][j][t] = ((f[pre][j - 1][t] % MOD) + (g[pre][j - 1][t - 1] % MOD)) % MOD; g[cur][j][t] = ((g[pre][j][t] % MOD) + (f[cur][j][t] % MOD)) % MOD; &#125; else &#123; f[cur][j][t] = 0; g[cur][j][t] = g[pre][j][t]; &#125; &#125; &#125; &#125; printf(\"%d\\n\", g[n % 2][m][k]); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.github.io/tags/NOIP/"},{"name":"DP","slug":"DP","permalink":"http://sulfur6.github.io/tags/DP/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"选课，树形DP","slug":"chose-class","date":"2016-11-03T12:16:14.000Z","updated":"2017-06-02T13:46:06.000Z","comments":true,"path":"chose-class/","link":"","permalink":"http://sulfur6.github.io/chose-class/","excerpt":"给定NNN门课，每门课有自己的学分，可能有一门先修课 不同的课程可能有共同的先修课 求在学习课程项目限制MMM内，可能获得的最大学分","text":"给定NNN门课，每门课有自己的学分，可能有一门先修课 不同的课程可能有共同的先修课 求在学习课程项目限制MMM内，可能获得的最大学分 存储这题使用类似邻接表的方式存储树，对每一个节点，记录它的一个孩子节点，对于其他直连它的节点，使用邻接表串起来，对于没有先修课的节点，我们设置一个虚拟000节点。 代码实现： struct Tree &#123; Tree *child, *next; int w; struct Answer &#123; bool solved; int value; inline Answer(): solved(false) &#123;&#125; &#125; ans[MAXM + 1]; inline Tree() &#123;&#125; inline Tree(Tree *parent, int w): w(w), next(parent-&gt;child) &#123;&#125;&#125; trees[MAXN + 1]; 树形DP 设f(i,m)f(i,m)f(i,m)表示选择节点iii，并为节点iii的孩子节点和兄弟节点分配m−1m-1m−1门选课机会所能获得的学分最大值，则有: 枚举kkk，给节点iii的孩子节点分配kkk门课，给节点iii的兄弟节点分配m−k−1m-k-1m−k−1个节点， 不选择节点iii及其孩子节点，全部mmm门课都分给它的兄弟节点 f(i,m)=max(maxk=0m−1(f(i.child,k)+f(i.next,m−k−1)),f(i,next,m)) f(i,m)=\\max(\\max\\limits_{k=0}^{m-1}(f(i.child,k)+f(i.next,m-k-1)), f(i,next,m)) f(i,m)=max(​k=0​max​m−1​​(f(i.child,k)+f(i.next,m−k−1)),f(i,next,m))代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 300;const int MAXM = 300;struct Tree &#123; Tree *child, *next; int w; struct Answer &#123; bool solved; int value; inline Answer(): solved(false) &#123;&#125; &#125; ans[MAXM + 1]; inline Tree() &#123;&#125; inline Tree(Tree *parent, int w): w(w), next(parent-&gt;child) &#123;&#125;&#125; trees[MAXN + 1];int n, m;void addEdge(int parent, int child, int w) &#123; trees[parent].child = new (&amp;trees[child]) Tree(&amp;trees[parent], w);&#125;inline int solve (Tree *t, int m) &#123; if (!t || m &lt; 0) return 0; if (!t-&gt;ans[m].solved) &#123; t-&gt;ans[m].value = 0; for (int i = 0; i &lt; m; i++) &#123; t-&gt;ans[m].value = max(t-&gt;ans[m].value, solve(t-&gt;child, i) + solve(t-&gt;next, m - i - 1) + t-&gt;w); &#125;//枚举k t-&gt;ans[m].value = max(t-&gt;ans[m].value, solve(t-&gt;next, m)); t-&gt;ans[m].solved = true; &#125; return t-&gt;ans[m].value;&#125;int main () &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int parent, w; scanf(\"%d %d\", &amp;parent, &amp;w); addEdge(parent, i, w); &#125; printf(\"%d\\n\", solve(&amp;trees[0], m + 1));//多了一门虚拟课，所以m+1 return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.github.io/tags/DP/"},{"name":"树形DP","slug":"树形DP","permalink":"http://sulfur6.github.io/tags/树形DP/"},{"name":"codevs","slug":"codevs","permalink":"http://sulfur6.github.io/tags/codevs/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"生日蛋糕，DFS，POJ1190","slug":"birthday-cake","date":"2016-10-31T12:07:43.000Z","updated":"2017-06-02T13:45:16.000Z","comments":true,"path":"birthday-cake/","link":"","permalink":"http://sulfur6.github.io/birthday-cake/","excerpt":"制作一个体积为NπN\\piNπ，共MMM层的蛋糕 从上往下数第i,(1≤i≤M)i,(1\\leq i\\leq M)i,(1≤i≤M)的蛋糕是半径为RiR_iR​i​​，高度为HiH_iH​i​​的圆柱 当i&lt;Mi&lt;Mi&lt;M时，要求Ri&gt;Ri+1R_i&gt;R_{i+1}R​i​​&gt;R​i+1​​且Hi&gt;Hi+1H_i&gt;H_{i+1}H​i​​&gt;H​i+1​​ 使得蛋糕的表面积最小 在这里本题需要输出的答案并不是最小的表面积，而是最小表面积除以π\\piπ之后的结果","text":"制作一个体积为NπN\\piNπ，共MMM层的蛋糕 从上往下数第i,(1≤i≤M)i,(1\\leq i\\leq M)i,(1≤i≤M)的蛋糕是半径为RiR_iR​i​​，高度为HiH_iH​i​​的圆柱 当i&lt;Mi&lt;Mi&lt;M时，要求Ri&gt;Ri+1R_i&gt;R_{i+1}R​i​​&gt;R​i+1​​且Hi&gt;Hi+1H_i&gt;H_{i+1}H​i​​&gt;H​i+1​​ 使得蛋糕的表面积最小 在这里本题需要输出的答案并不是最小的表面积，而是最小表面积除以π\\piπ之后的结果 思路 深搜 模拟拼蛋糕 暴力枚举下一层可能的蛋糕半径与高度 只需记录更新侧面积，所有顶面积等于最底层蛋糕的底面积 超时？ 剪枝！！！ 如何剪枝 在这里分可行性剪枝与最优性剪枝 最优性剪枝 当前已拼成的蛋糕表面积比已经记录的最优解大 可行性剪枝 无可用体积 拼成这些层最少体积大于当前需要拼的体积 目前枚举的高度半径不足以拼完蛋糕 当前可能拼成的最大体积比需要拼的体积少 代码#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int n, m;int minArea = 1 &lt;&lt; 30;//记录最优解int area = 0;//记录当前解int minV[30], minA[30];//分别记录拼成i层最小可能的体积和表面积int MaxVforNRH (int n, int r, int h) &#123; int v; for (int i = 0; i &lt; n; ++i) v += (r - i) * (r - i) * (h - i); return v;&#125;//计算在还有n层没拼完，当前一层的半径为r，高度为h时可能拼成的最大体积void dfs (int v, int n, int r, int h) &#123; if (n == 0) &#123; if (v) return; else &#123; minArea = min(minArea, area); return; &#125; &#125; if (v &lt;= 0) return;//可行1 if (minV[n] &gt; v) return;//可行2 if (area + minA[n] &gt;= minArea) return;//最优 if (h &lt; n || r &lt; n) return;//可行3 if (MaxVforNRH(n, r, h) &lt; v) return;//可行4 for (int rr = r; rr &gt;= n; --rr) &#123;//爆搜 if (n == m) area = rr * rr; for (int hh = h; hh &gt;= n; hh--) &#123; area += 2 * rr * hh; dfs (v - rr * rr * hh, n - 1, rr - 1, hh - 1); area -= 2 * rr * hh; &#125; &#125;&#125;int main () &#123; cin &gt;&gt; n &gt;&gt; m; minA[0] = 0; minV[0] = 0; for (int i = 1; i &lt;= m; ++i) &#123; minV[i] = minV[i - 1] + i * i * i; minA[i] = minA[i - 1] + 2 * i * i; &#125; if (minV[m] &gt; n) cout &lt;&lt; 0 &lt;&lt; endl; else &#123;//处理搜索边界 int maxH = (n - minV[m - 1]) / (m * m) + 1; int maxR = sqrt(double(n - minV[m - 1]) / m) + 1; area = 0; minArea = 1 &lt;&lt; 30; dfs (n, m, maxR, maxH); if (minArea == 1 &lt;&lt; 30) cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; minArea &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://sulfur6.github.io/tags/DFS/"},{"name":"POJ","slug":"POJ","permalink":"http://sulfur6.github.io/tags/POJ/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"斗地主，DFS，状态压缩，记忆化搜索","slug":"landlord-NOIP2015","date":"2016-10-29T12:56:32.000Z","updated":"2017-06-02T13:44:48.000Z","comments":true,"path":"landlord-NOIP2015/","link":"","permalink":"http://sulfur6.github.io/landlord-NOIP2015/","excerpt":"给定一副扑克牌，牌面随机，按照斗地主的方式打出，求最少出完要多少次 规则: 单顺子五个起，最多到A，不包括2和王 连对从三对起，最多到A，不包括2和王 飞机两个起，最多到A，不包括2和王，不可带牌 三张可以带一张也可以带一对，可以单打 四张可以带两张或者两对，可以单打 大小王可以当火箭出，但是打带牌的时候不能当对牌带 一对和单牌和斗地主完全一样","text":"给定一副扑克牌，牌面随机，按照斗地主的方式打出，求最少出完要多少次 规则: 单顺子五个起，最多到A，不包括2和王 连对从三对起，最多到A，不包括2和王 飞机两个起，最多到A，不包括2和王，不可带牌 三张可以带一张也可以带一对，可以单打 四张可以带两张或者两对，可以单打 大小王可以当火箭出，但是打带牌的时候不能当对牌带 一对和单牌和斗地主完全一样 思路DFS 大暴力搜索 考虑暴力枚举每一种出发，进行爆搜 状态压缩优化最暴力的爆搜一定会T掉，考虑记忆化搜索:对于某种状态下的牌，如果已经搜过，就不再搜。 所有的状态可以用一个五进制数存下来（因为每种点数的牌最多有四张），然后转化成十进制数，恰好可以用C++中的unsigned long long存下。 接下来我们用一个哈希表（map也是滋磁的），来存储每一种状态，每次搜索前查表，如果已经搜过，则直接返回值，没搜过，在本次搜索结束返回值时记录本种状态下的答案。 代码我用了一个数组来存每种牌有几张，其中0，1表示大小王，2~10代表2~10的对应点数，11~13表示J~K，14表示A #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;tr1/unordered_map&gt;#include &lt;climits&gt;#define MAXN 15#define update() ans = min(ans, dfs() + 1)using namespace std;typedef unsigned long long Status;int Hand[MAXN];inline Status zip () &#123; Status s = 0; for (int i = 0; i &lt; MAXN; i++) &#123; s = s * 5 + Hand[i]; &#125; return s;&#125;/*inline void print()&#123; for(int i = 0; i &lt; MAXN; i++)&#123; printf(\"%d \", Hand[i]); &#125; putchar('\\n');&#125;*/tr1::unordered_map&lt;Status, int&gt; S;int dfs() &#123; //print(); Status s = zip(); if (s == 0) return 0; if (S.count(s)) return S[s]; int ans = INT_MAX; bool SSingle = true; //Joker if (Hand[0] &amp;&amp; Hand[1]) &#123; Hand[0] = Hand[1] = 0; update(); Hand[0] = Hand[1] = 1; SSingle = false; &#125;//某玄学优化，有对王先出对王，好像这样会更快 //34567 for (int i = 3; i &lt; MAXN - 4; i++) &#123; bool flag = false; for (int d = 0; d &lt; 5; d++) &#123; if (!Hand[i + d]) &#123; flag = true; break; &#125; &#125; if (flag) continue; for (int d = 0; d &lt; 5; d++) Hand[i + d]--; update(); int j; for (j = i + 5; j &lt; MAXN &amp;&amp; Hand[j]; j++) &#123; Hand[j]--; update(); &#125; for (int k = i; k &lt; j; k++) Hand[k]++; SSingle = false; &#125; //334455 for (int i = 3; i &lt; MAXN - 2; i++) &#123; bool flag = false; for (int d = 0; d &lt; 3; d++) if (Hand[i + d] &lt; 2) &#123; flag = true; break; &#125; if (flag) continue; for (int d = 0; d &lt; 3; d++) Hand[i + d] -= 2; update(); int j; for (j = i + 3; j &lt; MAXN &amp;&amp; Hand[j] &gt;= 2; j++) &#123; Hand[j] -= 2; update(); &#125; for (int k = i; k &lt; j; k++) Hand[k] += 2; SSingle = false; &#125; //333444 for (int i = 3; i &lt; MAXN - 1; i++) &#123; bool flag = false; for (int d = 0; d &lt; 2; d++) if (Hand[i + d] &lt; 3) &#123; flag = true; break; &#125; if (flag) continue; for (int d = 0; d &lt; 2; d++) Hand[i + d] -= 3; update(); int j; for (j = i + 2; j &lt; MAXN &amp;&amp; Hand[j] &gt;= 3; j++) &#123; Hand[j] -= 3; update(); &#125; for (int k = i; k &lt; j; k++) Hand[k] += 3; SSingle = false; &#125; //3 + x for (int i = 2; i &lt; MAXN; i++) if (Hand[i] &gt;= 3) &#123; Hand[i] -= 3; update(); for (int j = 0; j &lt; MAXN; j++) if (Hand[j] &gt;= 1) &#123; Hand[j]--; update(); Hand[j]++; &#125; for (int j = 2; j &lt; MAXN; j++) if (Hand[j] &gt;= 2) &#123; Hand[j] -= 2; update(); Hand[j] += 2; &#125; Hand[i] += 3; SSingle = false; &#125; //4 + x for (int i = 2; i &lt; MAXN; i++) if (Hand[i] == 4) &#123; Hand[i] -= 4; update(); for (int j = 0; j &lt; MAXN; j++) if (Hand[j] &gt;= 1)&#123; Hand[j]--; for (int k = 0; k &lt; MAXN; k++) if (Hand[k] &gt;= 1) &#123; Hand[k]--; update(); Hand[k]++; &#125; Hand[j]++; &#125; for (int j = 2; j &lt; MAXN; j++) if (Hand[j] &gt;= 2) &#123; Hand[j] -= 2; for (int k = 2; k &lt; MAXN; k++) if (Hand[k] &gt;= 2) &#123; Hand[k] -= 2; update(); Hand[k] += 2; &#125; Hand[j] += 2; &#125; Hand[i] += 4; SSingle = false; &#125; //2 for (int i = 2; i &lt; MAXN; i++) if (Hand[i] &gt;= 2) &#123; Hand[i] -= 2; update(); Hand[i] += 2; SSingle = false; &#125; //1 if (SSingle) &#123; ans = 0; for (int i = 0; i &lt; MAXN; i++) &#123; ans += Hand[i]; &#125; &#125; return S[s] = ans;&#125;int main () &#123; int T, n; scanf(\"%d %d\", &amp;T, &amp;n); while (T--) &#123; memset(Hand, 0, sizeof(Hand)); S.clear(); for (int i = 0; i &lt; n; i++) &#123; int x, y; scanf(\"%d %d\", &amp;x, &amp;y); if (x == 0) Hand[y - 1]++; else if (x == 1) Hand[14]++; else Hand[x]++; &#125; printf(\"%d\\n\", dfs()); &#125; return 0;&#125; 原来感觉难道爆炸的题，真正做完以后却感觉就是一道大暴力的题，想了很久也没有什么可写的。。最后说一句，tr1害死人。。","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.github.io/tags/NOIP/"},{"name":"DFS","slug":"DFS","permalink":"http://sulfur6.github.io/tags/DFS/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://sulfur6.github.io/tags/状态压缩/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://sulfur6.github.io/tags/记忆化搜索/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"灌溉草场，线性DP，POJ2373","slug":"pour-the-grass","date":"2016-10-28T01:24:04.000Z","updated":"2017-06-02T13:45:02.000Z","comments":true,"path":"pour-the-grass/","link":"","permalink":"http://sulfur6.github.io/pour-the-grass/","excerpt":"一片草场上有长度为L(1≤L≤106)(1 \\leq L \\leq 10^6)(1≤L≤10​6​​)，且为偶数的线段 John的NNN头奶牛在操场上沿着这条线段吃草 每头奶牛的活动范围是一个开区间(S,E)(S,E)(S,E)，S,ES,ES,E都是整数 不同奶牛活动范围有重叠 现在要安装若干个可调节的喷水头灌溉草场，每个喷水头的工作半径在可[A,B][A,B][A,B]中调节 要求喷水头满足下列要求 线段上每个整点恰好位于一个喷水头的喷洒范围内 每头奶牛的活动范围要位于一个喷水头的喷洒范围 任何喷水头的喷洒范围不得超过线段两端 求John最少要安装多少个喷水头，若无法刚好安装则输出−1-1−1","text":"一片草场上有长度为L(1≤L≤106)(1 \\leq L \\leq 10^6)(1≤L≤10​6​​)，且为偶数的线段 John的NNN头奶牛在操场上沿着这条线段吃草 每头奶牛的活动范围是一个开区间(S,E)(S,E)(S,E)，S,ES,ES,E都是整数 不同奶牛活动范围有重叠 现在要安装若干个可调节的喷水头灌溉草场，每个喷水头的工作半径在可[A,B][A,B][A,B]中调节 要求喷水头满足下列要求 线段上每个整点恰好位于一个喷水头的喷洒范围内 每头奶牛的活动范围要位于一个喷水头的喷洒范围 任何喷水头的喷洒范围不得超过线段两端 求John最少要安装多少个喷水头，若无法刚好安装则输出−1-1−1 问题分析 从左端点向右端点安装喷水头，设F(X)F(X)F(X)表示:所安装喷水头的喷洒范围恰好覆盖直线上的区间[0,X][0,X][0,X]时，最少需要多少个喷水头 显然，X满足： X为偶数 X所在位置不会出现奶牛，即XXX不属于任何一个(S,E)(S,E)(S,E) X≥2AX\\geq2AX≥2A 当X&gt;2BX&gt;2BX&gt;2B时，存在Y∈[X−2B,X−2A]Y\\in [X-2B,X-2A]Y∈[X−2B,X−2A]且YYY满足上述三个条件使得F(X)=F(Y)+1F(X)=F(Y)+1F(X)=F(Y)+1 解题思路递推计算F(X)F(X)F(X) F(X)=∞:XF(X)=\\infty:XF(X)=∞:X是奇数 F(X)=∞:X&lt;2AF(X)=\\infty:X&lt;2AF(X)=∞:X&lt;2A F(X)=∞:XF(X)=\\infty:XF(X)=∞:X处可能有奶牛出没 F(X)=1:2A≤X≤2BF(X)=1:2A\\leq X \\leq 2BF(X)=1:2A≤X≤2B，且XXX位于任何奶牛活动范围之外 F(X)=1+minY=X−2BX−2AF(Y),YF(X)=1 +\\min\\limits_{Y=X-2B}^{X-2A} F(Y),YF(X)=1+​Y=X−2B​min​X−2A​​F(Y),Y位于任何奶牛的活动范围之外，且X&gt;2B 优化F(X)=1+minY=X−2BX−2AF(Y),YF(X)=1 +\\min\\limits_{Y=X-2B}^{X-2A} F(Y),YF(X)=1+​Y=X−2B​min​X−2A​​F(Y),Y位于任何奶牛的活动范围之外，且X&gt;2B。 对于此转移中的每个XXX求F(X)F(X)F(X)都要便利区间[X−2B,X−2A][X-2B,X-2A][X−2B,X−2A],太慢 所以快速找到此区间使得F(Y)F(Y)F(Y)最小的元素是解题的关键。可以用堆来优化哦 使用C++的STL中的priority_queue 求F(X)F(X)F(X)时，我们维护一个小根堆，保证堆中包含所有的i∈[X−2B,X−2A]i\\in [X-2B,X-2A]i∈[X−2B,X−2A]所对应的F(i)F(i)F(i)值，这样操作时间就从扫区间的O(N)O(N)O(N)级别变成了O(log2N)O(\\log_2N)O(log​2​​N)级别了 求解XXX对应的F(X)F(X)F(X)时，不允许堆中出现坐标大于X−2AX-2AX−2A的点，这样的点不能用来转移F(X)F(X)F(X)，又不能抛弃之，因为它可能对求后续点的FFF值有用 堆中可以出现坐标小于X−2BX-2BX−2B的点，若其出现在对头，则抛弃 求出XXX点的FFF值后，将(X−2A+2,(F(X−2A+2)))(X-2A+2,(F(X-2A+2)))(X−2A+2,(F(X−2A+2)))放入堆，为求F(X+2)F(X+2)F(X+2)作准备 堆中点坐标皆为偶数 代码#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int INF = 1 &lt;&lt; 31;const int MAXL = 1000010;const int MAXN = 1010;int F[MAXL];int cowThere[MAXL];//用于记录某点是否有奶牛出没int n, l, a, b;struct Fx &#123; int x, f; bool operator&lt;(const Fx &amp;a) const &#123;return f &gt; a.f;&#125; Fx(int xx = 0, int ff = 0): x(xx), f(ff) &#123;&#125;&#125;;//优先队列用结构体priority_queue&lt;Fx&gt; q;int main () &#123; cin &gt;&gt; n &gt;&gt; l; cin &gt;&gt; a &gt;&gt; b; a &lt;&lt;= 1; b &lt;&lt;= 1;//线性操作，所以先将半径处理成直径 memset(cowThere, 0, sizeof(cowThere)); for (int i = 0; i &lt; n; i++) &#123; int s, e; cin &gt;&gt; s &gt;&gt; e; cowThere[s + 1]++; cowThere[e]--; &#125; int inCows = 0; for (int i = 0; i &lt;= l; i++) &#123; F[i] = INF; inCows += cowThere[i]; cowThere[i] = inCows &gt; 0; &#125;//利用差分思想实现快速记录某点是否有奶牛出没 for (int i = a; i &lt;= b; i += 2) &#123; if (!cowThere[i]) &#123; F[i] = 1; if (i &lt;= b + 2 - a) q.push(Fx(i, 1));//确保提前进堆的点可以用于首轮递推 &#125; &#125;//首先初始化初始区间，为最开始的边界做准备 for (int i = b + 2; i &lt;= l; i += 2) &#123;//dp() if (!cowThere[i]) &#123; Fx fx; while (!q.empty()) &#123; fx = q.top(); if (fx.x &lt; i - b) q.pop();//如果堆顶元素坐标小于X-2B，抛弃不用 else break; &#125; if (!q.empty()) F[i] = fx.f + 1;//如果堆空了，说明原来所有堆中元素全部不可用 &#125; if (F[i - a + 2] != INF) q.push(Fx(i - a + 2, F[i - a + 2])); &#125; if (F[l] == INF) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; F[l] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.github.io/tags/DP/"},{"name":"POJ","slug":"POJ","permalink":"http://sulfur6.github.io/tags/POJ/"},{"name":"线性DP","slug":"线性DP","permalink":"http://sulfur6.github.io/tags/线性DP/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"小机房的树，LCA，倍增","slug":"gaogay","date":"2016-10-26T09:14:34.000Z","updated":"2017-06-02T13:44:08.000Z","comments":true,"path":"gaogay/","link":"","permalink":"http://sulfur6.github.io/gaogay/","excerpt":"一棵NNN个节点的树，节点编号从000到N−1N-1N−1 每条边有为ccc的边权 求从两个不同的叶节点移动到同一节点最少花费 共MMM次询问","text":"一棵NNN个节点的树，节点编号从000到N−1N-1N−1 每条边有为ccc的边权 求从两个不同的叶节点移动到同一节点最少花费 共MMM次询问 思路 如果只有一次询问，可以用最短路算法，然而询问次数过多，使用堆优化迪杰斯特拉在极限数据下计算次数将会达到101010^{10}10​10​​级别 因为这是一棵树，所以我们可以很容易想到让两个叶子节点在同一高度向上跳，第一次同时跳到的点，维护两个节点跳过的距离就是最小花费 基于这种想法，我们成功引出了LCA——最近公共祖先 做法求LCA 倍增 ST表 Tarjan 树链剖分 针对我现在是一个NOIP选手的现实基础，我选择使用简单好写的倍增求解法。 倍增求解朴素算法朴素LCA算法是先让更深的节点向上跳，跳到和深度较浅的点深度相同时，让两个节点同时向上跳，那么第一个跳到的同一个节点就是这两个节点的最近公共祖先。 可是这样太慢了，极限情况遇到一条链的树就会变成O(N)O(N)O(N)。 如何优化？ 既然一次跳一步太少了，那就一次多跳几步 有一个神奇的东西叫做二进制拆分，就是可以把一个数拆成若干个2k2^k2​k​​加和的形式，这样每个不大于它的正整数都可以用多项式中若干项的和来表示。 所以，我们用二元组f(i,j)f(i,j)f(i,j)表示从编号为iii的节点向上跳2j2^j2​j​​步可以跳到的节点编号，用g(i,j)g(i,j)g(i,j)表示从编号为iii的节点向上跳2j2^j2​j​​步所需花费（即边权和）。 那么对于每一个f(i,j)f(i,j)f(i,j)与g(i,j)g(i,j)g(i,j)，有 f(i,j)=f(f(i,j−1),j−1) f(i,j)=f(f(i,j-1),j-1) f(i,j)=f(f(i,j−1),j−1)g(i,j)=g(i,j−1)+g(f(i,j−1),j−1) g(i,j)=g(i,j-1)+g(f(i,j-1),j-1) g(i,j)=g(i,j−1)+g(f(i,j−1),j−1) 这里用到了倍增的思想，就是从第iii个点往上跳2j2^j2​j​​步相当于从第iii个点往上跳两个2j−12^{j-1}2​j−1​​次方步，即先从iii向上跳2j2^j2​j​​步，再从跳到的点向上跳2j2^j2​j​​步。 BFS预处理前面提到了一个操作，就是让两个点先到达同一深度，所以说我们需要用BFS预处理出深度。 设根节点深度为111，然后一层一层向下广搜，每次广搜出的点的深度为当前深度加一。 查询 qwq先上代码好了 inline int query (int u, int v) &#123; if (N[u].depth &lt; N[v].depth) std::swap(u, v); //保证u是较深的节点 int ans = 0; if (N[u].depth &gt; N[v].depth) &#123;//使两个节点处在相同深度 for (int j = logn; j &gt;= 0; j--) &#123; if (N[f[u][j]].depth &gt;= N[v].depth) &#123; ans += g[u][j]; u = f[u][j]; &#125; &#125;//从大到小枚举指数，保证对应二进制位正常不进位 &#125; if (u != v) &#123; for (int j = logn; j &gt;= 0; j--) &#123;//同时向上跳 if (f[u][j] != f[v][j]) &#123; ans += g[u][j]; ans += g[v][j]; u = f[u][j]; v = f[v][j]; &#125;//让两个节点跳到LCA的儿子 &#125; ans += g[u][0]; ans += g[v][0]; u = f[u][0]; &#125; return ans;//本题需要维护路径和&#125; 代码#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;const int MAXN = 50000;const int MAXLOG = 16;int n, m, logn;int f[MAXN + 5][MAXLOG];int g[MAXN + 5][MAXLOG];struct Node;struct Edge;struct Node &#123; int depth; Edge *h; Node () :depth(0), h(NULL) &#123;&#125;&#125; N[MAXN];struct Edge &#123; Node *fr, *to; int w; Edge *ne; Edge (Node *fr, Node *to, int w) : fr(fr), to(to), w(w) &#123; ne = fr-&gt;h; &#125;&#125;;inline void addEdge (Node *u, Node *v, int w) &#123; u-&gt;h = new Edge(u, v, w); v-&gt;h = new Edge(v, u, w);&#125; //用于BFS的邻接表inline void bfs () &#123; std::queue &lt;Node *&gt; q; q.push(&amp;N[0]); N[0].depth = 1; f[0][0] = 0; g[0][0] = 0; while (!q.empty()) &#123; Node *u = q.front(); q.pop(); for (Edge *e = u-&gt;h; e != NULL; e = e-&gt;ne) &#123; if (!e-&gt;to-&gt;depth) &#123; e-&gt;to-&gt;depth = u-&gt;depth + 1; f[e-&gt;to - N][0] = u - N; g[e-&gt;to - N][0] = e-&gt;w; q.push(e-&gt;to); &#125; &#125; &#125;&#125;inline void prepare () &#123; bfs(); while ((1 &lt;&lt; logn) &lt;= n) logn++; logn--; for (int j = 1; j &lt;= logn; j++) &#123; for (int i = 0; i &lt; n; i++) &#123; f[i][j] = f[f[i][j - 1]][j - 1]; g[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1]; &#125; &#125;&#125; //预处理出f,j数组inline int query (int u, int v) &#123; if (N[u].depth &lt; N[v].depth) std::swap(u, v); int ans = 0; if (N[u].depth &gt; N[v].depth) &#123; for (int j = logn; j &gt;= 0; j--) &#123; if (N[f[u][j]].depth &gt;= N[v].depth) &#123; ans += g[u][j]; u = f[u][j]; &#125; &#125; &#125; if (u != v) &#123; for (int j = logn; j &gt;= 0; j--) &#123; if (f[u][j] != f[v][j]) &#123; ans += g[u][j]; ans += g[v][j]; u = f[u][j]; v = f[v][j]; &#125; &#125; ans += g[u][0]; ans += g[v][0]; u = f[u][0]; &#125; return ans;&#125;int main () &#123; int m; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n - 1; i++) &#123; int u, v, w; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); addEdge(&amp;N[u], &amp;N[v], w); addEdge(&amp;N[v], &amp;N[u], w); &#125; prepare(); scanf(\"%d\", &amp;m); while (m--) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); printf(\"%d\\n\", query(u, v)); &#125; return 0;&#125; 为什么说倍增好写又好用呢？因为Tarjan和ST表不能维护瓶颈路径（比如最大边或最小边），而树链剖分又比较难，所以贴心的队长就只讲了倍增qwq。","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"http://sulfur6.github.io/tags/LCA/"},{"name":"倍增","slug":"倍增","permalink":"http://sulfur6.github.io/tags/倍增/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"迎接仪式，线性DP","slug":"welcome-ceremony","date":"2016-10-25T12:07:34.000Z","updated":"2017-06-02T13:45:54.000Z","comments":true,"path":"welcome-ceremony/","link":"","permalink":"http://sulfur6.github.io/welcome-ceremony/","excerpt":"给定一个仅由j与z组成的的字符串 允许最多交换KKK次字符串中字符 使得字符串中jz子串尽量多","text":"给定一个仅由j与z组成的的字符串 允许最多交换KKK次字符串中字符 使得字符串中jz子串尽量多 思路 看到这道题之后，我就想要暴力求解，然后。。就没有然后了 思路的关键之处在于，交换kkk次，其实意味着kkk个j变成z，kkk个z变成j。 于是，我们就开心的开始DP了 DP状态设f(i,j,z)f(i,j,z)f(i,j,z)表示前iii位中有jjj个j变成了z，有zzz个z变成了j 则，对于f(i,j,z)f(i,j,z)f(i,j,z)，有： f(i,j,z)=max(f(i−2,j−1,z),f(i−2,j,z−1),f(i−2,j−1,z−1),f(i−2,j,z)) f(i,j,z)=\\max(f(i-2,j-1,z),f(i-2,j,z-1),f(i-2,j-1,z-1),f(i-2,j,z)) f(i,j,z)=max(f(i−2,j−1,z),f(i−2,j,z−1),f(i−2,j−1,z−1),f(i−2,j,z)) 状态解释: f(i−2,j−1,z)f(i-2,j-1,z)f(i−2,j−1,z):字符串第i−1i-1i−1位为j，第iii位为j f(i−2,j,z−1)f(i-2,j,z-1)f(i−2,j,z−1):字符串第i−1i-1i−1位为z，第iii位为z f(i−2,j−1,z−1)f(i-2,j-1,z-1)f(i−2,j−1,z−1):字符串第i−1i-1i−1位为z，第iii位为j f(i−2,j,z)f(i-2,j,z)f(i−2,j,z):字符串第i−1i-1i−1位为j，第iii位为z。 只有在f(i,j,z)f(i,j,z)f(i,j,z)中j=zj=zj=z时才可更新答案，因为此时才满足题意中成对更新的意义 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;const int MAXN = 500;const int MAXK = 100;char a[MAXN + 1];int f[MAXN + 1][MAXK + 1][MAXK + 1];int n, k;int dp () &#123; f[0][0][0] = 0, f[1][0][0] = 0; int ans = 0; int x, y; for (int i = 2; i &lt;= n; i++) for (int j = 0; j &lt;= k; j++) for (int z = 0; z &lt;= k; z++) &#123; f[i][j][z] = f[i - 1][j][z]; if (a[i - 1] == 'z') x = 1; else x = 0; if (a[i] == 'j') y = 1; else y = 0; //小表，判断应该如何转移 if (j &gt;= x &amp;&amp; z &gt;= y) f[i][j][z] = std::max(f[i][j][z], f[i - 2][j - x][z - y] + 1); if (j == z) ans = std::max(ans, f[i][j][z]);//满足条件时更新答案 &#125; return ans;&#125;int main () &#123; freopen(\"welcome.in\", \"r\", stdin); freopen(\"welcome.out\", \"w\", stdout); scanf(\"%d %d\", &amp;n, &amp;k); scanf(\"%s\", a + 1); memset(f, -0x777f, sizeof(f)); printf(\"%d\\n\", dp()); fclose(stdin); fclose(stdout); return 0;&#125; 不得不说这题的转移实在是难想，果然我还是个小蒟蒻qwq","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.github.io/tags/DP/"},{"name":"线性DP","slug":"线性DP","permalink":"http://sulfur6.github.io/tags/线性DP/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"线段树学习笔记","slug":"segment-tree","date":"2016-10-24T08:27:26.000Z","updated":"2017-01-04T02:11:18.000Z","comments":true,"path":"segment-tree/","link":"","permalink":"http://sulfur6.github.io/segment-tree/","excerpt":"中国高级数据结构领导者，唐氏线段树！【雾 其实并不是，下面即将介绍的是不会TLE的正版线段树哦","text":"中国高级数据结构领导者，唐氏线段树！【雾 其实并不是，下面即将介绍的是不会TLE的正版线段树哦 引言在线段树之前我们已经学习过了多中维护区间操作的技巧与数据结构。 维护区间最值:ST表 区间更改转化为单点更改:差分数组 区间和:前缀和 但是，它们有一个共同的缺点，就是更适合离线操作，一旦操作与查询为动态的，它们的时间复杂度就会变成 于是，我们开心的迎来了，线段树——SegmentTree\\mathfrak {Segment Tree}SegmentTree 定义摘自百度百科线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN)O(logN)O(logN)。而未优化的空间复杂度为2N2N2N，因此有时需要离散化让空间压缩。 简而言之线段树会让你的动态区间操作不会TLE。有时会MLE 具体构成对于这个二叉树，每一个节点可以维护一段[L,R][L,R][L,R]的区间内的信息，而对于它的左儿子，维护的是[L,⌊R2⌋][L,\\lfloor \\frac{R}{2} \\rfloor][L,⌊​2​​R​​⌋]这段区间中的信息，右儿子则维护的是[⌊R2⌋+1,R][\\lfloor \\frac{R}{2} \\rfloor + 1,R][⌊​2​​R​​⌋+1,R]这段区间内的信息。 Lazy Mark当我们对区间进行操作的时候，我们需要修改这段区间对应的所有后代的信息（因为他们算是这段区间的子集），但是我们并不需要对于每次操作都这样修改，因为有些时候我们并不会使用到它的后代记录的区间信息。 就这样，Lazy Mark（懒标记）应运而生。 void cover(long long delta) &#123; sum += delta * (r - l + 1); tag += delta;&#125;void pushDown() &#123; if (tag) &#123; lc-&gt;cover(tag); rc-&gt;cover(tag); tag = 0; &#125;&#125;//下放标记只下放一次，再向下查询再下放 POJ3468#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;new&gt;const int MAXN = 200000;template&lt;size_t SIZE&gt;struct MemoryPool &#123; char buf[SIZE], *cur; MemoryPool(): cur(buf) &#123;&#125; void init() &#123; cur = buf; &#125; void *alloc(const int &amp;size) &#123; char *p = cur; cur += size; return p; &#125;&#125;;MemoryPool&lt;(4 + 4 + 8 + 8 + 8 + 8) * MAXN * 5&gt; pool;struct SegmentTree &#123; int l, r; SegmentTree *lc, *rc; long long sum, tag; SegmentTree(int l, int r, SegmentTree *lc, SegmentTree *rc): l(l), r(r), lc(lc), rc(rc), sum(0), tag(0) &#123;&#125; void cover(long long delta) &#123; sum += delta * (r - l + 1); tag += delta; &#125; void pushDown() &#123; if (tag) &#123; lc-&gt;cover(tag); rc-&gt;cover(tag); tag = 0; &#125; &#125; void update(int l, int r, long long x) &#123; if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) cover(x); else pushDown(), lc-&gt;update(l, r, x), rc-&gt;update(l, r, x), sum = lc-&gt;sum + rc-&gt;sum; &#125; long long querySum(int l, int r) &#123; if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return sum; else return pushDown(), lc-&gt;querySum(l, r) + rc-&gt;querySum(l, r); &#125;&#125; *root;SegmentTree *build(int l, int r) &#123; if (l == r) return new (pool.alloc(sizeof(SegmentTree))) SegmentTree(l, r, NULL, NULL); else &#123; int mid = l + (r - l) / 2; return new (pool.alloc(sizeof(SegmentTree))) SegmentTree(l, r, build(l, mid), build(mid + 1, r)); &#125;&#125;int main() &#123; int n, m; while (scanf(\"%d %d\", &amp;n, &amp;m) != EOF) &#123; root = NULL; pool.init(); root = build(1, n); for (int i = 1; i &lt;= n; i++) &#123; long long x; scanf(\"%lld\", &amp;x); root-&gt;update(i, i, x); &#125; char s[2]; for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%s\", s); if (s[0] == 'Q') &#123; int a, b; scanf(\"%d %d\", &amp;a, &amp;b); printf(\"%lld\\n\", root-&gt;querySum(a, b)); &#125; else if (s[0] == 'C') &#123; int l, r; long long x; scanf(\"%d %d %lld\", &amp;l, &amp;r, &amp;x); root-&gt;update(l, r, x); &#125; &#125; &#125; return 0;&#125; 入门题 Codevs1080,1081,1082(线段树联系1，2，3) 忠诚，忠诚S %唐氏线段树 数轴染色 借教室(常数大，需要内存池优化) Powered by Sulfur6\\mathfrak {Powered\\ by\\ Sulfur6}Powered by Sulfur6","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://sulfur6.github.io/tags/线段树/"},{"name":"区间操作","slug":"区间操作","permalink":"http://sulfur6.github.io/tags/区间操作/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"Sudoku，暴力DFS，POJ2676","slug":"sudoku","date":"2016-10-23T11:53:10.000Z","updated":"2017-06-04T09:17:02.000Z","comments":true,"path":"sudoku/","link":"","permalink":"http://sulfur6.github.io/sudoku/","excerpt":"数独有趣，爆搜无脑。 还有回不去的还记得的一张张写满算式的纸，和解不出的数独。","text":"数独有趣，爆搜无脑。 还有回不去的还记得的一张张写满算式的纸，和解不出的数独。 题目大意标准 9×9 9 \\times 9 9×9 的数独游戏，由你填上空缺的数 思路 填满每个空格 记录某一行，某一列，某一小格不能填的数 开始爆搜 搜索 搜索过程中，依次往每个格子中填数 简单Hash，O(1)O(1)O(1)判断某行某列某小格是否填写某数 注意事项 本题给定数据的数独矩阵，数和数之间没有空格，所以需要用字符处理。 当然为了某不愿透露姓名的PC同学的幸福生活，交完题我就更改了一下qwq 同时@PC,@SJQ 需要通过行号和列号确定所在小格号 其实也可以打个表解决这种问题 inline int Getblock (int r, int c) &#123; //r表示行，c表示列 int rr = r / 3; int cc = c / 3;; return rr * 3 + cc;&#125; 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;short r[9][10], c[9][10], block[9][10];//分别记录行、列、小格中填数的情况，r表示行，c表示列，block表示小格int board[9][9];struct Pos &#123; int r, c; Pos(int rr, int cc): r(rr), c(cc) &#123; &#125;&#125;;vector&lt;Pos&gt; blank;//结构体+Vector记录空白格inline int Getblock (int r, int c) &#123; int rr = r / 3; int cc = c / 3;; return rr * 3 + cc;&#125; //根据行列求小格void Setflag (int i, int j, int num, int f) &#123; r[i][num] = f; c[j][num] = f; block[Getblock(i, j)][num] = f;&#125; //为某一个元素所在行、列、小格设置上使用过或未使用的标记bool ok (int i, int j, int num) &#123; return !r[i][num] &amp;&amp; !c[j][num] &amp;&amp; !block[Getblock(i, j)][num];&#125; //询问当前位置某元素是否可用bool Dfs (int n) &#123; //n表示现在要填的空格的编号 if (n &lt; 0) return true; int r = blank[n].r, c = blank[n].c; for (int num = 1; num &lt;= 9; ++num) &#123; if (ok(r, c, num)) &#123; board[r][c] = num; Setflag(r, c, num, 1); if (Dfs(n - 1)) return true; Setflag(r, c, num, 0); //回溯 &#125; &#125; return false;&#125; //Based on POJ的毒瘤数据，我们选择右下向左上搜，其实左上向右下搜也可以int main () &#123; int t; cin &gt;&gt; t; //多组数据 while (t--) &#123; memset(r, 0, sizeof(r)); memset(c, 0, sizeof(c)); memset(block, 0, sizeof(block)); blank.clear(); //每组数据都要重置 for (int i = 0; i &lt; 9; ++i) &#123; for (int j = 0; j &lt; 9; ++j) &#123; char c; cin &gt;&gt; c; board[i][j] = c - '0'; //对付每空格的毒瘤数据 if (board[i][j]) Setflag(i, j, board[i][j], 1); else blank.push_back(Pos(i, j)); &#125; &#125; if (Dfs(blank.size() - 1)) &#123; for (int i = 0; i &lt; 9; ++i) &#123; for (int j = 0; j &lt; 9; ++j) cout &lt;&lt; char(board[i][j] + '0'); cout &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 想想当时班里同学整日颓数独的日子，如果我做过这道题的话该是多么好的一个装逼机会啊T ^ T","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://sulfur6.github.io/tags/DFS/"},{"name":"POJ","slug":"POJ","permalink":"http://sulfur6.github.io/tags/POJ/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"矩阵乘法优化递推，NOIP%你赛","slug":"matrix-increase","date":"2016-10-23T07:27:35.000Z","updated":"2017-06-02T13:45:32.000Z","comments":true,"path":"matrix-increase/","link":"","permalink":"http://sulfur6.github.io/matrix-increase/","excerpt":"给定一个坐标系，可以往左，右，上走，已经走过的点（单次访问中）不可以重复走，一共可以走NNN步，求一共有多少种走法。","text":"给定一个坐标系，可以往左，右，上走，已经走过的点（单次访问中）不可以重复走，一共可以走NNN步，求一共有多少种走法。 题目分析 表神，各单位提供丰富成功地证明了递推公式，然而，不适合这样做的蒟蒻Sulfur6更喜欢打表找规律。 这里我们就假装我们已经打完了这个表，然后发现它的前几项分别是： f(0)=1,f(1)=3,f(2)=7,f(3)=17,f(4)=41,f(5)=99 f(0) = 1, f(1) = 3, f(2) = 7, f(3) = 17, f(4) = 41, f(5) = 99 f(0)=1,f(1)=3,f(2)=7,f(3)=17,f(4)=41,f(5)=99后面不打了T ^ T，所以我们发现了一个递推公式： f(i)=f(i−2)+2×f(i−1) f(i) = f(i - 2) + 2 \\times f(i - 1) f(i)=f(i−2)+2×f(i−1)时间复杂度降至O(n)O(n)O(n)，但是极限数据高达10910^910​9​​，这时O(n)O(n)O(n)不靠谱。而且会MLE 矩阵 说矩阵优化之前先说说矩阵 形如 简而言之，矩阵是一坨数 矩阵乘法对于两个大小为N×MN \\times MN×M和P×NP \\times NP×N的矩阵A,BA,BA,B，他们相乘后的结果矩阵CCC是一个大小为M×PM \\times PM×P的矩阵。 对于矩阵CCC的每一位Ci,jC_{i,j}C​i,j​​，有: Ci,j=∑k=1NAi,k×Bk,j C_{i,j} = \\sum\\limits_{k = 1}^{N} A_{i,k} \\times B_{k,j} C​i,j​​=​k=1​∑​N​​A​i,k​​×B​k,j​​矩阵优化递推 团长并不知道这种玄学方法的由来，只知道我们可以用这种技巧来转移 这样相乘以后的结果: 也就是说我们可以通过矩阵相乘的方式来求出某递推公式的某一项，即: 如何优化 矩阵满足结合律 既然如此，我们就可以出动大杀器，快速幂，这样就可以在O(logn)O(logn)O(logn)的时间内求得递推公式的某一项了。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1e9;const int mo = 1e9 + 7;struct Mat &#123; long long a[2][2]; Mat (const bool unit = false) &#123; //构造函数，初始化矩阵值 memset(a, 0, sizeof(a)); if (unit) for (int i = 0; i &lt; 2; i++) a[i][i] = i;//此处矩阵用于快速幂中作为单位矩阵承载答案 &#125; long long &amp;operator()(const int i, const int j = 0) &#123; return a[i][j]; &#125; const long long &amp;operator()(const int i, const int j = 0) const &#123; return a[i][j]; &#125; //重载运算符并引用，快速取得并修改某矩阵的值&#125;;Mat operator*(const Mat &amp;a, const Mat &amp;b) &#123; //重载运算符，矩阵乘法 Mat res(false); for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) (res(i, j) += a(i, k) * b(k, j)) %= mo; return res;&#125;Mat pow(Mat a, int n) &#123; //矩阵快速幂 Mat res(true); for (; n; n &gt;&gt;= 1, a = a * a) if (n &amp; 1) res = res * a; return res;&#125;int main () &#123; freopen(\"coordinate.in\", \"r\", stdin); freopen(\"coordinate.out\", \"w\", stdout); int n; scanf(\"%d\", &amp;n); if (n == 0) printf(\"1\"); else if (n == 1) printf(\"3\"); else &#123; Mat init(false); //初始矩阵 init(0) = 1; init(1) = 3; Mat mat(false); //转移矩阵 mat(0, 0) = 0; mat(0, 1) = 1; mat(1, 0) = 1; mat(1, 1) = 2; Mat res = pow(mat, n - 1) * init; //此处转移矩阵的位置和初始矩阵的位置不可颠倒，因为矩阵不满足交换律 printf(\"%lld\\n\", res(1)); &#125; fclose(stdin); fclose(stdout); return 0;&#125; 最后说几句 这题中使用的矩阵特性就是满足结合律但是不满足交换律 因为是考试的题所以说我还是打了文件输入输出 LaTeX公式和Markdown不兼容真是见鬼了 公式打起来好麻烦 这道题是可以分块打表的 再次%表神cyr","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"递推","slug":"递推","permalink":"http://sulfur6.github.io/tags/递推/"},{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"http://sulfur6.github.io/tags/矩阵乘法/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"拯救少林神棍，POJ1011，DFS","slug":"buddhas-sticks","date":"2016-10-22T00:34:21.000Z","updated":"2016-12-27T13:35:56.000Z","comments":true,"path":"buddhas-sticks/","link":"","permalink":"http://sulfur6.github.io/buddhas-sticks/","excerpt":"一般的，在碰到搜索题的时候，我的反应是：woc，这也能搜索？事实证明，我还是too young. 这是一道重在剪枝的神奇DFS题。","text":"一般的，在碰到搜索题的时候，我的反应是：woc，这也能搜索？事实证明，我还是too young. 这是一道重在剪枝的神奇DFS题。 题面 据说,少林寺的镇寺之宝,是救秦王李世民的十三棍僧留下的若干根一样长的棍子。 在民国某年,少林寺被军阀炮轰,这些棍子被炸成N N N节长度各异的小木棒。 战火过后,少林方丈想要用这些木棒拼回原来的棍子。可他记不得原来到底有几根棍子了,只知道古人比较矮,且为了携带方便,棍子一定比较短。他想知道这些棍子最短可能有多短。 看到这个题面之后，我整个人都不好了qwq 题目大意 给定NNN节长度各异的小木棒，不剩余地拼成若干节长度相等的少林神棍，求神棍最短可以有多短。 解题思路枚举 可能拼成的棍子长度 长度从最长的那根木棒开始枚举到木棒总长的一半 若枚举到的长度不能整除木棒总长度，则不去搜索 搜索 搜索的过程，就是我们尝试着拼神棍的过程 如何拼完这一组神棍呢？ 一根一根的拼棍子 如果拼完第iii根棍子之后，发现第i+1i+1i+1根棍子拼不成了，那就推翻第iii根棍子的拼法 有可能一直向前推翻第一根的拼法 搜索状态 发现能搜索以后，就要确定搜索状态了 我们设状态为一个二元组(R,M)(R,M)(R,M)。 RRR表示还没有用的木棒数 MMM表示当前拼的这根棍子剩余未填满的长度 本题的初始状态和结束状态是什么？ 假设共有NNN根木棒，当前枚举到的长度为LLL。 初始状态：(N,L)(N,L)(N,L) 结束状态：(0,0)(0,0)(0,0) 开始搜索 我也不废话了，伪代码参上 Dfs的基本递推关系:bool Dfs(int R, int M) &#123; if( R == 0 &amp;&amp; M == 0) return true; //拼接任务完成 如果能找到一根长为S(S &lt;= M)的木棒,拼在当前棍子上,然后 Dfs(R – 1,M - S); 如果找不到:return false; &#125; 这里要注意的是我们首先要对长度排序，从大到小枚举 剪枝 如果按照之前的搜法，那么一定会TLE 所以，我们需要出动暴力大杀器——剪枝 剪枝1 如果在当前状态下确定了一根不能使用的木棒，那么当我们弃用它以后，当前状态下和它长度同的木棒都不再使用。 正确性显然 剪枝2 由于拼接失败，我们需要拆掉某根棍子时，如果我们一直拆解到它的第一根木棒，那么我们就不再动它，去看它的上一根棍子，如果它没有上一根棍子，则此长度不合法 如果拆掉第一根木棒，我们假设它在之后能被使用，而现在已知序列是有序的，那么如果之后某种拼法能使得当前第一根棍子被用到，那么它在之前序列一定不会被拆掉。 剪枝3 当我们需要拆解某根已经拼好的棍子时，不要拆掉最后的那根木棒反而用更小的木棒来代替。 如果这样就能拼上，那么我们用用来代替最后长木棒的几根短木棒来代替那根长木棒也能拼上。 剪枝4 如果当前需要加的木棒不是当前棍子的第一根，那么我们不能从最长的木棒往下枚举，而是从最近使用过的那根之后的一根开始向下枚举。 这样可以避免先使用长的后使用短的的情况。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int n, l; bool used[65];vector &lt;int&gt; len;int last;bool dfs (int r, int m) &#123; if (r == 0 &amp;&amp; m == 0) return true;//搜索停止，达到条件返回true，表示枚举的长度可行 if (m == 0) m = l;//如果已经拼完一根，那么就再接着往下拼 int S = 0; if (m != l) S = last + 1;//剪枝4，保证递减拼 for (int i = S; i &lt; n; i++) &#123; if (!used[i] &amp;&amp; len[i] &lt;= m) &#123; if (i &gt; 0) &#123; if (!used[i - 1] &amp;&amp; len[i] == len[i - 1]) continue;//剪枝1，保证相同长度的木棒不在同一位置多次用 &#125; used[i] = true; last = i;//标记此根为使用过，记录本次加入的木棒 if (dfs(r - 1, m - len[i])) return true; else &#123; used[i] = 0;//回溯，有可能之后还能用到这根木棒 if (len[i] == m || m == l) return false;//剪枝2，3 &#125; &#125; &#125; return false;&#125;int main () &#123; while (1) &#123; cin &gt;&gt; n; if (n == 0) break;//Blocks of datas, 读入0终止 len.clear();//每次清一遍储存长度的数组 int totallen = 0; for (int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; len.push_back(x); totallen += x; &#125; sort (len.begin(), len.end(), greater&lt;int&gt;());//从小到大排序 for (l = len[0]; l &lt;= totallen / 2; l++) &#123; if (totallen % l) continue; memset(used, 0, sizeof(used)); if (dfs(n, l)) &#123;cout &lt;&lt; l &lt;&lt; endl; break;&#125;//因为是从小到大枚举，所以验证一个答案正确就可以输出了 &#125; if (l &gt; totallen / 2) cout &lt;&lt; totallen &lt;&lt; endl; &#125; return 0;&#125; 团长在POJ和HDU上都成功拯救了少林神棍，但是原题并不叫拯救少林神棍，而是叫Sticks，很无聊的题面，某不远透露姓名的薛定谔同学竟然告诉我这是一道POJ上的中文题，害的我一阵好找。。。。","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://sulfur6.github.io/tags/DFS/"},{"name":"POJ","slug":"POJ","permalink":"http://sulfur6.github.io/tags/POJ/"},{"name":"剪枝","slug":"剪枝","permalink":"http://sulfur6.github.io/tags/剪枝/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]},{"title":"杨威利与莱因哈特的爱恨情仇","slug":"ywl","date":"2016-10-20T13:05:09.000Z","updated":"2017-06-02T13:43:28.000Z","comments":true,"path":"ywl/","link":"","permalink":"http://sulfur6.github.io/ywl/","excerpt":"蒟蒻Sulfur6在第一次看见这道题的时候感觉它好水啊，然后五分钟打了个自以为是的正解。。肯定是错的太离谱了，那天晚上的代码带崩了我的三个系统。。。 刚刚学习并查集的时候就见过那个题，当时连最水的家族都做不出，真的是连题面都没看就跳过去了。","text":"蒟蒻Sulfur6在第一次看见这道题的时候感觉它好水啊，然后五分钟打了个自以为是的正解。。肯定是错的太离谱了，那天晚上的代码带崩了我的三个系统。。。 刚刚学习并查集的时候就见过那个题，当时连最水的家族都做不出，真的是连题面都没看就跳过去了。 题目大意给定一个最多有30000艘船的船队，初始状态一字排开。 接下来你要读入 T T T 个指令 (1≤T≤5000001 \\leq T \\leq 5000001≤T≤500000)： 若为MijM i jMij，则将iii所在的舰队移动到jjj所在舰队的后面（即将第iii艘舰船所在的战舰队列全部移动到第jjj列舰船所在战舰队列的后面）； 若为CijC i jCij，如果第i,ji,ji,j艘舰船在同一列中，则输出它们中间有的舰船数，如果不在同一列中，则输出−1-1−1。 这里要注意的是（可能只有我一个人这么智障），就是给定合并操作的iji jij可能只是一列舰船中间或末尾的那个，不一定就是某列舰船的第一个。【天真的以为一定给定第一艘的蒟蒻就这么WA挺了。 压缩路径 分析完题目大意之后我们会自然而然的想到一种做法，那就是记录每一列舰船所在的位置 但是这样显然不靠谱，因为不路径压缩的UFS会爆炸。 怎么在压缩路径的基础上维护战舰所在位置的信息呢？某优化如果说大家和我一样记得并查集路径压缩的代码的话，我们会发现，在路径压缩之前并没有维护什么信息，所以我们尝试着来搞一些事情 int a[MAXN];//某列战舰现有的战舰数，初始化为1int b[MAXN];/*某列战舰现在在本列战舰内的深度，初始化为0*/int fa[MAXN];//UFS中用的father数组int find (int x) &#123; int t; if (x != fa[x]) &#123; t = find(fa[x]); b[x] += b[fa[x]];//这一句包括上面一句类似于递归求解确定x战舰在本列中的位置 fa[x] = t; &#125; return fa[x];&#125; 完整代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;const int maxn = 30000;const int maxt = 500000;int fa[maxn + 5], a[maxn + 5], b[maxn + 5];int ans;int find (int x) &#123; int t; if (x != fa[x]) &#123; t = find(fa[x]); b[x] += b[fa[x]]; fa[x] = t; &#125; return fa[x];&#125;int T;int main () &#123; scanf(\"%d\", &amp;T); for (int i = 1; i &lt;= maxn + 1; i++) &#123; fa[i] = i; a[i] = 1; &#125; char c; int x, y; while (T--) &#123; scanf(\"\\n%c %d %d\", &amp;c, &amp;x, &amp;y); int f1 = find(x); int f2 = find(y); if (c == 'M') &#123;//合并操作 fa[f1] = f2;//修改战舰头 b[f1] = a[f2];//修改战舰层数 a[f2] += a[f1];//增加合并后该列的战舰数 &#125; else &#123; if (f1 == f2) &#123; ans = abs(b[x] - b[y]) - 1;//这里要记得-1，因为编号从0开始 printf(\"%d\\n\", ans); &#125; else printf(\"-1\\n\"); &#125; &#125; return 0;&#125; 看这个难度也知道是NOI的一道水题，毕竟我这样的蒟蒻都能A。。 当年看着唐氏Pascal学并查集就死活学不会了，思想都不懂，这里要感谢教会我并查集的神犇Menci和Gty.","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://sulfur6.github.io/tags/并查集/"},{"name":"路径压缩","slug":"路径压缩","permalink":"http://sulfur6.github.io/tags/路径压缩/"},{"name":"NOI","slug":"NOI","permalink":"http://sulfur6.github.io/tags/NOI/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.github.io/categories/OI/"}]}]}