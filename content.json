{"meta":{"title":"Sulfur6's Blog","subtitle":"但行好事，莫问前程","description":"A Kind Father","author":"Sulfur6","url":"http://sulfur6.top"},"pages":[{"title":"Friend","date":"2017-01-12T23:54:55.000Z","updated":"2017-01-12T23:56:10.000Z","comments":true,"path":"Friends/index.html","permalink":"http://sulfur6.top/Friends/index.html","excerpt":"","text":"Friends listLYOI2015Other OIers"},{"title":"","date":"2017-01-26T04:45:47.000Z","updated":"2016-12-23T14:01:36.000Z","comments":false,"path":"categories/index.html","permalink":"http://sulfur6.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-01-26T04:45:47.000Z","updated":"2016-12-23T13:58:16.000Z","comments":false,"path":"tags/index.html","permalink":"http://sulfur6.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Link-Cut Tree 学习笔记","slug":"lct-note","date":"2017-04-02T14:48:46.000Z","updated":"2017-04-02T14:51:41.000Z","comments":true,"path":"lct-note/","link":"","permalink":"http://sulfur6.top/lct-note/","excerpt":"LCT 学习笔记，防忘","text":"LCT 学习笔记，防忘 动态树有一类问题，要求我们维护树上路径的信息，如果树是静态的，即树的结构是不会变的，树链剖分可以解决这类问题。但是如果要求支持我们修改树的结构，比如加边，删边等操作，树剖就 gg 了。。 这种动态维护树上信息的问题，我们称之为动态树问题，上述例子是比较简单的动态树问题，不存在对子树进行操作等丧心病狂的操作，所以我们可以用 Link-Cut Tree 来解决。 Link-Cut TreeLink-Cut Tree 是一种能在 O(logn) O(\\log n) O(logn) 的时间内解决上述问题的数据结构。 简单来说， LCT 与树链剖分一样，会对树中节点的儿子进行划分，轻重链剖分根据子树大小将节点的儿子分为轻儿子和重儿子， LCT 则会将儿子划分为实、虚两种儿子，相应的边被称为实边和虚边，而且任意时刻，一个节点最多会有一个实儿子，也可能没有。 与树剖不同的是， LCT 并不固定划分实虚儿子，由于树的形态不断改变，实虚儿子也有可能变化。 基本定义深度：深度越大，到根节点越远，反之亦然。 实边：一个非叶节点，向它的实儿子连的一条边叫做实边，向其他所有儿子连的边均为虚边。注意，一个非叶节点可以没有实儿子，此时它向所有儿子连边均为虚边。 实路径：由若干条实边首尾相连的，不可伸长的路径称之为实路径。实路径之间并非孤立的，各条实路径之间通过虚边连接。一条实路径中深度最小的点在树中的父节点被称之为实路径的父亲，在代码中用 pathFa 体现。 基本操作用 Splay 来维护实路径。由于实路径中的任意两个节点都是祖先和子孙的关系，则如果我们按照节点的深度进行排序，我们会得到一个唯一的有序深度序列，换言之，在某条实路径对应的 Splay 中，一个节点的左子树中的所有节点一定是其祖先，右子树中的所有子树一定是其子孙，这也是我们用Splay维护实路径的原因。 在实际维护中，并不需要真的在 Splay 中用维护有序集的方法去排序，我们只需要在修改 Splay 的时候满足其中序遍历满足我们的需求即可。 我们设 v 是树中某个节点，v.OPERATION可以使得这个节点进行OPERATION这个操作。 v.access 使得节点 v 到根节点的路径成为实路径。 节点 v v v 可能不是目前属实路径的尾部，所以我们将其旋转到其所属Splay的根节点，此时如果它有右子树，则它右子树中所有的节点都是它目前所处实路径的下方的节点，我们要断掉这条边（注意不是真的断掉，只是转换成虚边），要做的操作是将其右儿子的 pathFa 设成它，同时将其右儿子置空。 如果此时这条实路径包含根节点，操作结束 然后我们要做的是将以节点v为尾部的这条实路径和它的父亲相连，此时我们对这条实路径的父亲执行上述操作，并且将这条实路径的父亲向实路径的顶部节点的边置为实边，即在这条实路径对应的 Splay 中将原来的 pathFa 设为 fa 即可。 继续查询该实路径是否包含根节点，若不包含，则继续执行上述操作。 v.find 找到节点v所处这棵树的根节点。我们只需要执行v.access，此时节点v与根节点处在一条实路径中，而且根节点一定是深度最小的那个节点，所以查找实路径对应Splay的最左节点即可。 v.evert 将节点v置为整棵树的根首先我们将节点v和根置于一条实路径上，即执行v.access，此时我们只需让这条实路径反转即可将v置为整棵树的根。利用平衡树打标记处理即可。 注：维护根不变的树时，不需要此操作。 link(u, v) 将节点u和节点v连起来首先u.evert，然后将u所在实路径上的pathFa置成v即可。 注：这样操作，让节点u成为了节点v的儿子 cut(u, v) 删掉节点u和节点v之间的边 先u.evert使得u成为有根树的根节点，这样保证v一定是节点u的子节点，然后v.access，再将v旋转至Splay的根，这样如果原树中有边(u, v)，那么v的左子树一定只有u这个节点。 附上「BZOJ2049」洞穴勘探 的代码 #include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAXN = 10000;struct LinkCutTree &#123; struct Node &#123; Node *fa, *ch[2], *pathFa; bool rev; void pushDown() &#123; if (rev) &#123; std::swap(ch[0], ch[1]); if (ch[0]) ch[0]-&gt;rev ^= 1; if (ch[1]) ch[1]-&gt;rev ^= 1; rev = false; &#125; &#125; int relation() &#123; return this == fa-&gt;ch[1]; &#125; void rotate() &#123; pushDown(); std::swap(pathFa, fa-&gt;pathFa); Node *old = fa; int x = relation(); fa = old-&gt;fa; if (old-&gt;fa) old-&gt;fa-&gt;ch[old-&gt;relation()] = this; old-&gt;ch[x] = ch[x ^ 1]; if (ch[x ^ 1]) ch[x ^ 1]-&gt;fa = old; ch[x ^ 1] = old; old-&gt;fa = this; &#125; void splay() &#123; while (fa) &#123; if (fa-&gt;fa) fa-&gt;fa-&gt;pushDown(); fa-&gt;pushDown(); if (!fa-&gt;fa) rotate(); else if (fa-&gt;relation() == relation()) fa-&gt;rotate(), rotate(); else rotate(), rotate(); &#125; &#125; void expose() &#123; splay(); pushDown(); if (ch[1]) &#123; std::swap(ch[1]-&gt;pathFa, ch[1]-&gt;fa); ch[1] = NULL; &#125; &#125; bool splice() &#123; splay(); if (!pathFa) return false; pathFa-&gt;expose(); pathFa-&gt;ch[1] = this; std::swap(pathFa, fa); return true; &#125; void access() &#123; expose(); while (splice()); &#125; void evert() &#123; access(); splay(); rev ^= 1; &#125; &#125; N[MAXN + 1]; void link(int a, int b) &#123; Node *u = &amp;N[a], *v = &amp;N[b]; u-&gt;evert(); u-&gt;pathFa = v; &#125; void cut(int a, int b) &#123; Node *u = &amp;N[a], *v = &amp;N[b]; u-&gt;evert(); v-&gt;access(); u-&gt;splay(); u-&gt;pushDown(); u-&gt;ch[1] = NULL; v-&gt;fa = NULL; &#125; int find(int a) &#123; Node *v = &amp;N[a]; v-&gt;access(); v-&gt;splay(); while (v-&gt;pushDown(), v-&gt;ch[0]) v = v-&gt;ch[0]; return v - N; &#125;&#125; lct;int main() &#123; int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; char s[8]; int u, v; scanf(\"%s %d %d\", s, &amp;u, &amp;v); if (s[0] == 'C') lct.link(u, v); else if (s[0] == 'D') lct.cut(u, v); else if (s[0] == 'Q') puts(lct.find(u) == lct.find(v) ? \"Yes\" : \"No\"); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://sulfur6.top/tags/LCT/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://sulfur6.top/tags/学习笔记/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"「CQOI 2015」任务查询系统 - 可持久化权值线段树","slug":"bzoj3932","date":"2017-02-15T01:22:18.000Z","updated":"2017-04-22T01:35:55.000Z","comments":true,"path":"bzoj3932/","link":"","permalink":"http://sulfur6.top/bzoj3932/","excerpt":"哎呀奇怪的类名什么的不要在意了啦。还有当时忽略多个相同优先级的任务调了好久 T^T..","text":"哎呀奇怪的类名什么的不要在意了啦。还有当时忽略多个相同优先级的任务调了好久 T^T.. 题目大意给定若干个任务 (si,ei,pi) (s_i, e_i, p_i) (s​i​​,e​i​​,p​i​​)，表示该任务从第 si s_i s​i​​ 秒运行到第 ei e_i e​i​​ 秒，它的价值为 pi p_i p​i​​，每次询问给定一个 x x x 并由你计算一个 k k k，查询第 x x x 秒时价值最小的 k k k 个任务的价值之和，如果第 x x x 秒时运行的任务不足 k k k 个，则输出此时所有任务的价值和。 题解这里用一种差分的思想来建主席树。 考虑当我们接受到一个任务时，它会从第 si s_i s​i​​ 秒存在到第 ei e_i e​i​​ 秒，而且查询是查询第 x x x 秒存在的的所有任务，所以我们对于时间建主席树，对于一个任务 i i i，我们在建第 si s_i s​i​​ 棵线段树时把它插入主席树，在建 ei+1 e_i + 1 e​i​​+1 棵线段树时把它删掉，这样我们可以保证第 i i i 棵线段树中存储的任务是所有在第 i i i 秒中运行的任务，剩下的就是主席树上二分查询了。。 注意，相同优先级的任务可能有多个。 顺便吐个槽，感觉这种写法叫做可持久化权值线段树更好。。 代码奇怪的类名实例名什么的不要在意啦 qwq #include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;const int MAXN = 100000;const int MAXM = 100000;struct Mission &#123; int val; bool isDelete; Mission() &#123;&#125; Mission(int val, bool isDelete) : val(val), isDelete(isDelete) &#123;&#125;&#125;;std::vector&lt;Mission&gt; a[MAXM + 50];struct PresentTreeByGoldYeInInternationalOlympidInInformaticsHellc &#123; struct Node &#123; int l, r; Node *lc, *rc; int size, sum; Node() &#123;&#125; Node(int l, int r, Node *lc, Node *rc) : l(l), r(r), lc(lc), rc(rc), size(lc-&gt;size + rc-&gt;size), sum(lc-&gt;sum + rc-&gt;sum) &#123;&#125; Node(int l, int r, Node *lc, Node *rc, int size, int sum) : l(l), r(r), lc(lc), rc(rc), size(size), sum(sum) &#123;&#125; &#125; *roots[MAXN + 50], *null, _pool[MAXN * 200], *_curr; int l, r; PresentTreeByGoldYeInInternationalOlympidInInformaticsHellc() &#123; null = new Node(-1, -1, NULL, NULL, 0, 0); null-&gt;lc = null, null-&gt;rc = null; &#125; Node *insert(Node *v, int l, int r, int x, bool isDelete) &#123; if (!isDelete) &#123; if (x &lt; l || x &gt; r) return v; else if (l == r) return new (_curr++) Node(l, r, null, null, v-&gt;size + 1, v-&gt;sum + x); else &#123; int mid = l + (r - l) / 2; return new (_curr++) Node(l, r, insert(v-&gt;lc, l, mid, x, isDelete), insert(v-&gt;rc, mid + 1, r, x, isDelete)); &#125; &#125; else &#123; if (x &lt; l || x &gt; r) return v; else if (l == r) return new (_curr++) Node(l, r, null, null, v-&gt;size - 1, v-&gt;sum - x); else &#123; int mid = l + (r - l) / 2; return new (_curr++) Node(l, r, insert(v-&gt;lc, l, mid, x, isDelete), insert(v-&gt;rc, mid + 1, r, x, isDelete)); &#125; &#125; &#125;/* void update(Node *v, int x, bool isDelete) &#123; if (!isDelete) &#123; v-&gt;size++, v-&gt;sum += x; if (v-&gt;l == v-&gt;r) return; else &#123; int mid = v-&gt;l + (v-&gt;r - v-&gt;l) / 2; if (x &lt;= mid) update(v-&gt;lc, x, isDelete); else update(v-&gt;rc, x, isDelete); &#125; &#125; else &#123; v-&gt;size--, v-&gt;sum -= x; if (v-&gt;l == v-&gt;r) return; else &#123; int mid = v-&gt;l + (v-&gt;r - v-&gt;l) / 2; if (x &lt;= mid) update(v-&gt;lc, x, isDelete); else update(v-&gt;rc, x, isDelete); &#125; &#125; &#125;*/ void build(std::vector&lt;Mission&gt; *a, int n, int l, int r) &#123; _curr = _pool; roots[0] = null; for (int i = 1; i &lt;= n; i++) &#123; std::vector&lt;Mission&gt;::iterator it = a[i].begin(); if (it == a[i].end()) &#123; roots[i] = roots[i - 1]; continue; &#125; else &#123; roots[i] = insert(roots[i - 1], l, r, it-&gt;val, it-&gt;isDelete); it++; for (; it != a[i].end(); it++) &#123; assert(it != a[i].end()); roots[i] = insert(roots[i], l, r, it-&gt;val, it-&gt;isDelete); &#125; &#125; &#125; this-&gt;l = l, this-&gt;r = r; &#125; long long query(int qr, int k) &#123; long long ans = 0, lsize; Node *v = roots[qr]; if (k &gt;= v-&gt;size) return v-&gt;sum; lsize = v-&gt;lc-&gt;size; while (v-&gt;l != v-&gt;r) &#123; if (k &lt;= lsize) &#123; v = v-&gt;lc; lsize = v-&gt;lc-&gt;size; &#125; else &#123; k -= lsize; ans += v-&gt;lc-&gt;sum; v = v-&gt;rc; lsize = v-&gt;lc-&gt;size; &#125; &#125; if (k) ans += v-&gt;l * k; return ans; &#125;&#125; presentTreeByGoldYeInInternationalOlympidInInformaticsHellc;int main() &#123; int m, n; scanf(\"%d %d\", &amp;m, &amp;n); int max = INT_MIN, min = INT_MAX; for (int i = 1; i &lt;= m; i++) &#123; int s, t, val; scanf(\"%d %d %d\", &amp;s, &amp;t, &amp;val); max = std::max(max, val); min = std::min(min, val); a[s].push_back(Mission(val, false)); a[t + 1].push_back(Mission(val, true)); &#125; presentTreeByGoldYeInInternationalOlympidInInformaticsHellc.build(a, n, min, max); long long pre = 1; for (int i = 1; i &lt;= n; i++) &#123; int x, k; long long a, b, c; scanf(\"%d %lld %lld %lld\", &amp;x, &amp;a, &amp;b, &amp;c); k = 1 + (a * pre + b) % c; pre = presentTreeByGoldYeInInternationalOlympidInInformaticsHellc.query(x, k); printf(\"%lld\\n\", pre); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://sulfur6.top/tags/BZOJ/"},{"name":"主席树","slug":"主席树","permalink":"http://sulfur6.top/tags/主席树/"},{"name":"可持久化","slug":"可持久化","permalink":"http://sulfur6.top/tags/可持久化/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"「HDU 5791」Two - DP","slug":"hdu5791","date":"2017-02-07T02:17:06.000Z","updated":"2017-04-22T02:51:36.000Z","comments":true,"path":"hdu5791/","link":"","permalink":"http://sulfur6.top/hdu5791/","excerpt":"有趣小DP","text":"有趣小DP 题目大意给定两个字符串 A A A 和 B B B，求两个字符串的公共子序列个数。 题解设 f(i,j) f(i, j) f(i,j) 为 A A A 串前 i i i 位和 B B B 串前 j j j 位的公共子序列个数，则 f(i,j)={f(i,j−1)+f(i−1,j)+1Ai=Bjf(i,j−1)+f(i−1,j)−f(i−1,j−1)Ai≠Bj f(i, j) = \\begin{cases} f(i, j - 1) + f(i - 1, j) + 1 &amp; A_i = B_j\\\\ f(i, j - 1) + f(i - 1, j) - f(i - 1, j - 1) &amp; A_i \\neq B_j \\end{cases} f(i,j)={​f(i,j−1)+f(i−1,j)+1​f(i,j−1)+f(i−1,j)−f(i−1,j−1)​​​A​i​​=B​j​​​A​i​​≠B​j​​​​代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAXN = 1005;const int MOD = 1000000007;int a[MAXN + 1], b[MAXN + 1], dp[MAXN + 1][MAXN + 1], n, m;int main() &#123; while (scanf(\"%d %d\", &amp;n, &amp;m) != EOF) &#123; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= m; i++) scanf(\"%d\", &amp;b[i]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; if (a[i] == b[j]) dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + 1) % MOD; else dp[i][j] = ( ( (dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]) ) % MOD + MOD ) % MOD; &#125; printf(\"%d\\n\", dp[n][m] % MOD); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.top/tags/DP/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"「BZOJ3223」文艺平衡树","slug":"bzoj3223","date":"2017-02-03T12:16:20.000Z","updated":"2017-04-02T14:46:59.000Z","comments":true,"path":"bzoj3223/","link":"","permalink":"http://sulfur6.top/bzoj3223/","excerpt":"Splay 维护序列入门","text":"Splay 维护序列入门 题目大意给定一个序列，以及若干次反转区间的操作，要求输出经过若干次反转操作之后的序列。 题解用 Splay 维护序列即可。 对于一棵平衡树，满足旋转后其中序遍历始终不变的性质，所以我们按照序列来确定初始的 Splay ，这样做的话， Splay 的每个节点代表的是序列上的某个位置。 而后，对于每次反转，其实就是反转某一棵中序遍历为 [l,r] [l, r] [l,r] 的子树，这里我们将 l−1 l - 1 l−1 位置上的节点旋转到根，将 r+1 r + 1 r+1 位置上的节点旋转到根的右子树，由于这棵 Splay 的中序遍历就是原来的序列，那么 r+1 r + 1 r+1 位置上的节点的左子树的中序遍历一定是我们要的 [l,r] [l, r] [l,r] 这段区间，将这个节点打上反转标记即可。 注意，访问某个节点的儿子的时候一定要记得下放标记。 此外，如果要在函数内修改参数的值，不要忘记引用。。 代码#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#ifdef DBG const int MAXN = 10;#else const int MAXN = 100000;#endifint a[MAXN + 1];struct Splay &#123; struct Node &#123; Node *c[2], *fa, **root; int size, x; bool isBound, rev; Node(Node *fa, Node **root, int x, bool isBound = false) : fa(fa), root(root), size(1), x(x), isBound(isBound), rev(false) &#123; c[0] = c[1] = NULL; &#125; Node *pushDown() &#123; if (rev) &#123; std::swap(c[0], c[1]); if (c[0]) c[0]-&gt;rev ^= 1; if (c[1]) c[1]-&gt;rev ^= 1; rev = false; &#125; return this; &#125; void maintain() &#123; size = (c[0] ? c[0]-&gt;size : 0) + (c[1] ? c[1]-&gt;size : 0) + 1; &#125; int relation() &#123; return this == fa-&gt;c[1]; &#125; void rotate() &#123; pushDown(); Node *old = fa; int x = relation(); if (old-&gt;fa) old-&gt;fa-&gt;c[fa-&gt;relation()] = this; fa = old-&gt;fa; old-&gt;c[x] = c[x ^ 1]; if (c[x ^ 1]) c[x ^ 1]-&gt;fa = old; c[x ^ 1] = old; old-&gt;fa = this; old-&gt;maintain(), maintain(); if (!fa) *root = this; &#125; void splay(Node *target = NULL) &#123; while (fa != target) &#123; if (fa-&gt;fa) fa-&gt;fa-&gt;pushDown(); fa-&gt;pushDown(); if (fa-&gt;fa == target) rotate(); else if (relation() == fa-&gt;relation()) fa-&gt;rotate(), rotate(); else rotate(), rotate(); &#125; &#125; int lSize() &#123; return c[0] ? c[0]-&gt;size : 0; &#125; &#125; *root; Splay() : root(NULL) &#123;&#125; void build(int *a, int n) &#123; root = build(a, 1, n, NULL); Node **v = &amp;root, *fa = NULL; while (*v) &#123; fa = *v; fa-&gt;size++; v = &amp;(*v)-&gt;c[0]; &#125; *v = new Node(fa, &amp;root, 0, true); v = &amp;root, fa = NULL; while (*v) &#123; fa = *v; fa-&gt;size++; v = &amp;(*v)-&gt;c[1]; &#125; *v = new Node(fa, &amp;root, 0, true); &#125; Node *build(int *a, int l, int r, Node *fa) &#123; if (l &gt; r) return NULL; int mid = (l + r) &gt;&gt; 1; Node *v = new Node(fa, &amp;root, a[mid - 1]); if (l != r) &#123; v-&gt;c[0] = build(a, l, mid - 1, v); v-&gt;c[1] = build(a, mid + 1, r, v); v-&gt;maintain(); &#125; return v; &#125; Node *select(int k) &#123; k++; Node *v = root; while (k != v-&gt;pushDown()-&gt;lSize() + 1) &#123; if (k &lt; v-&gt;lSize() + 1) v = v-&gt;c[0]; else k -= v-&gt;lSize() + 1, v = v-&gt;c[1]; &#125;#ifdef DBG printf(\"Result before splay is %d\\n\", v-&gt;x);#endif v-&gt;splay();#ifdef DBG assert(root == v); printf(\"Result is %d\\n\", v-&gt;x); printf(\"------------------------------------------\\n\");#endif return root; &#125; Node *select(int l, int r) &#123; Node *epl = select(l - 1), *epr = select(r + 1); epl-&gt;splay(); epr-&gt;splay(epl); return epr-&gt;c[0]; &#125; void reverse(int l, int r) &#123; Node *range = select(l, r); range-&gt;rev ^= 1; &#125; void getAns(int *a) &#123; dfs(a, root); &#125; void dfs(int *&amp;a, Node *v) &#123; if (v) &#123; v-&gt;pushDown(); dfs(a, v-&gt;c[0]); if (!v-&gt;isBound) *a++ = v-&gt;x; dfs(a, v-&gt;c[1]); &#125; &#125;#ifdef DBG void print(Node *v) &#123; if (v) &#123; v-&gt;pushDown(); print(v-&gt;c[0]); printf(\"Size : %d, value : %d\\n\", v-&gt;size, v-&gt;x); print(v-&gt;c[1]); &#125; &#125;#endif&#125; splay;int main() &#123; int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) a[i] = i + 1; splay.build(a, n);#ifdef DBG splay.print(splay.root); printf(\"--------------------------------------\\n\");#endif while (m--) &#123; int l, r; scanf(\"%d %d\", &amp;l, &amp;r); splay.reverse(l, r);#ifdef DBG splay.print(splay.root); printf(\"---------------------------------------------\\n\");#endif &#125; splay.getAns(a); for (int i = 0; i &lt; n; i++) printf(\"%d \", a[i]); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://sulfur6.top/tags/BZOJ/"},{"name":"Splay","slug":"Splay","permalink":"http://sulfur6.top/tags/Splay/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"愤怒的小鸟 - 状态压缩，BFS，NOIP2016","slug":"NOIP2016-angrybirds","date":"2016-11-30T13:15:36.000Z","updated":"2016-12-27T13:32:11.000Z","comments":true,"path":"NOIP2016-angrybirds/","link":"","permalink":"http://sulfur6.top/NOIP2016-angrybirds/","excerpt":"考场上的我还不知道什么叫状压，感觉这题TM的什么玩意，下场学了状压。。不多说了这可能是近几年最简单的 T3 。。","text":"考场上的我还不知道什么叫状压，感觉这题TM的什么玩意，下场学了状压。。不多说了这可能是近几年最简单的 T3 。。 题面Kiana最近沉迷于一款神奇的游戏无法自拔。 简单来说，这款游戏是在一个平面上进行的。 有一架弹弓位于 (0,0) (0, 0) (0,0) 处，每次Kiana可以用它向第一象限发射一只小鸟，小鸟们的飞行轨迹均为形如 y=ax2+bx y = ax ^ 2 + bx y=ax​2​​+bx 的曲线，其中 a a a，b b b 是Kiana指定的参数，且必须满足 a&lt;0 a &lt; 0 a&lt;0。 当小鸟落回地面（即 x x x 轴）时，它就会瞬间消失。 在游戏的某个关卡里，平面的第一象限中有 n n n 只绿色的猪，其中第 i i i 只猪所在的坐标为 (xi,yi) (x_i, y_i) (x​i​​,y​i​​)。 如果某只小鸟的飞行轨迹经过了(xi,yi) (x_i, y_i) (x​i​​,y​i​​)，那么第 i i i 只猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行； 如果一只小鸟的飞行轨迹没有经过(xi,yi) (x_i, y_i) (x​i​​,y​i​​)，那么这只小鸟飞行的全过程就不会对第 i i i 只猪产生任何影响。 例如，若两只猪分别位于 (1,3) (1, 3) (1,3) 和 (3,3) (3, 3) (3,3)，Kiana可以选择发射一只飞行轨迹为 y=−x2+4x y = -x ^ 2 + 4x y=−x​2​​+4x 的小鸟，这样两只猪就会被这只小鸟一起消灭。 而这个游戏的目的，就是通过发射小鸟消灭所有的猪。 这款神奇游戏的每个关卡对来说都很难，所以Kiana还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在「输入格式」中详述。 假设这款游戏一共有 T T T 个关卡，现在Kiana想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的猪。由于她不会算，所以希望由你告诉她。 链接LYOI#104 题解状压因为猪的数量最多只有 18 18 18 只，所以自然而然地想到状压，这里说一下本题状压的思想。 我们用一个形如 011011001100110010 的二进制数，表示游戏中现存的猪，其中从左往右数第 i i i 位，表示的是编号为 i i i 的猪的状态，该位为 0 0 0 ，表示这只猪死亡或本身就不存在，反之表示这只猪现在还活着。 对于一条抛物线（真·题解中会提到抛物线相关），我们也用一个类似的二进制数记录它的信息，即它的从左往右第 i i i 位为 1 1 1，表示编号为 i i i 的猪可以被这条抛物线杀死，反之此抛物线不会对这只猪造成任何影响。 用位运算乱搞就可以表示杀猪了 QwQ. 真·题解由于弹弓的位置确定，为 (0,0) (0,0) (0,0)，则可以由两个点唯一确定出一条形如题目描述中 ax2+by=0 a x ^ 2 + b y = 0 ax​2​​+by=0 抛物线，枚举每两只猪的坐标，求出 n2 n^2 n​2​​ 条抛物线，并舍去其中不合题意的抛物线（即 a&gt;0 a &gt; 0 a&gt;0 的抛物线），使用一个二进制数来记录每条合法抛物线可击杀的猪。 可以证明，这样枚举一定最优，因为每条击杀猪数目超过 2 2 2 的抛物线，一定会击杀至少两只猪，而所有可至少击杀两只猪的合法抛物线都在枚举的过程中被求出，则如此枚举可以所有击杀猪的数量最多的抛物线。 但是这样还会有几只猪不在我们枚举到的任何一条合法的抛物线上，对于这种猪，我们为其虚拟出一条抛物线，我们不需要知道其方程，只需要标记这条抛物线可以击杀对应的猪即可。 然后建立状态图进行 BFS 即可。 当然在操作的过程中可能会用到各种各样的位运算操作，状压当中常见的奇技淫巧。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 18 + 3;const int MAXS = (1 &lt;&lt; (MAXN + 1));const double EPS = 1e-6; // 精度搞的高一点struct Point &#123; double x, y; Point(double x = 0, double y = 0): x(x), y(y) &#123;&#125;&#125; a[MAXN];inline bool dcmp (double x) &#123; return fabs(x) &lt;= EPS;&#125;inline bool dcmp (double x, double y) &#123; return dcmp(x - y);&#125; // 处理浮点数时常用的根据 EPS 判断相等的技巧struct Line &#123; double a, b; bool valid; unsigned int kill; Line(unsigned int kill = 0): a(0), b(0), valid(true), kill(kill) &#123;&#125; bool operator&lt;(const Line &amp;other) const &#123; return kill &gt; other.kill; &#125; bool operator==(const Line &amp;other) const &#123; return kill == other.kill; &#125;&#125; lines[MAXN * MAXN];struct Node &#123; bool vis; int dist;&#125; N[MAXS];int n, cmd, limit, lineCnt;inline int bfs (int status) &#123; if (!status) return 0; queue&lt;int&gt; q; q.push(status); N[status].vis = true; N[status].dist = 0; while (!q.empty()) &#123; int v = q.front(); q.pop(); if (N[v].dist == limit) continue; for (int i = 1; i &lt;= lineCnt; i++) &#123; Line &amp;l = lines[i]; if (l.valid &amp;&amp; (l.kill &amp; status)) &#123; int u = v; u &amp;= ~l.kill; // 状压通过位运算搞掉 if (!N[u].vis) &#123; N[u].vis = true; N[u].dist = N[v].dist + 1; if (!u) return N[u].dist; q.push(u); &#125; &#125; &#125; &#125; return n;&#125;inline Line getLine (const Point &amp;a, const Point &amp;b) &#123; Line l; l.a = (a.x * b.y - b.x * a.y) / (a.x * b.x * b.x - b.x * a.x * a.x); l.b = (a.y - l.a * a.x * a.x) / a.x; return l;&#125;inline bool onLine (const Line &amp;l, const Point &amp;a) &#123; return dcmp(l.a * a.x * a.x + l.b * a.x, a.y);&#125;inline int solve () &#123; bool flags[MAXN]; for (int i = 1; i &lt;= n; i++) flags[i] = false; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; if (dcmp(a[i].x, a[j].x)) continue; Line l = getLine(a[i], a[j]); if (l.a &gt;= 0) continue; flags[i] = flags[j] = true; lines[++lineCnt] = l; &#125; &#125; for (int i = 1; i &lt;= lineCnt; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (onLine(lines[i], a[j])) &#123; lines[i].kill |= (1u &lt;&lt; (j - 1)); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!flags[i]) &#123; lines[++lineCnt] = Line(1u &lt;&lt; (i - 1)); // 或运算标记能击杀的猪的编号 &#125; &#125; sort(lines + 1, lines + lineCnt + 1); for (int i = 1; i &lt;= lineCnt; i++) &#123; for (int j = i + 1; j &lt;= lineCnt; j++) &#123; if ((lines[i].kill | lines[j].kill) == lines[i].kill) &#123; lines[j].valid = false; &#125; // 如果抛物线i能击杀抛物线j能击杀的所有猪，而且能击杀抛物线j不能击杀的猪，则使用抛物线j明显不优 &#125; &#125; for (unsigned int i = 0; i &lt; (1u &lt;&lt; n); i++) &#123; N[i].vis = false; &#125; return bfs((1u &lt;&lt; n) - 1);&#125;int main() &#123; freopen(\"angrybirds.in\", \"r\", stdin); freopen(\"angrybirds.out\", \"w\", stdout); int t; scanf(\"%d\", &amp;t); while (t--) &#123; scanf(\"%d %d\", &amp;n, &amp;cmd); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%lf %lf\", &amp;a[i].x, &amp;a[i].y); &#125; lineCnt = 0; if (cmd == 1) &#123; limit = ceil(double(n) / 3 + 1); &#125; else &#123; limit = n; &#125; printf(\"%d\\n\", solve()); &#125; fclose(stdin); fclose(stdout);&#125; 最后写完这题才发现，貌似那个作弊指令没有什么卵用","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.top/tags/NOIP/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://sulfur6.top/tags/状态压缩/"},{"name":"BFS","slug":"BFS","permalink":"http://sulfur6.top/tags/BFS/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"蚯蚓 - 单调队列，NOIP2016","slug":"NOIP2016-earthworm","date":"2016-11-30T13:15:33.000Z","updated":"2016-12-27T13:32:46.000Z","comments":true,"path":"NOIP2016-earthworm/","link":"","permalink":"http://sulfur6.top/NOIP2016-earthworm/","excerpt":"代码能力太差，考场上连65分的堆都没打出来。。","text":"代码能力太差，考场上连65分的堆都没打出来。。 题目大意本题中，我们将用符号 ⌊c⌋ \\lfloor c \\rfloor ⌊c⌋ 表示对 c c c 向下取整，例如：⌊3.0⌋=⌊3.1⌋=⌊3.9⌋=3 \\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3 ⌊3.0⌋=⌊3.1⌋=⌊3.9⌋=3。 蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。 蛐蛐国里现在共有 n n n 只蚯蚓（n n n 为正整数）。每只蚯蚓拥有长度，我们设第 i i i 只蚯蚓的长度为 ai a_i a​i​​（i=1,2,…,n i = 1, 2, \\ldots , n i=1,2,…,n），并保证所有的长度都是非负整数（即：可能存在长度为 0 0 0 的蚯蚓）。 每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 p p p（是满足 0&lt;p&lt;1 0 &lt; p &lt; 1 0&lt;p&lt;1 的有理数）决定，设这只蚯蚓长度为 x x x，神刀手会将其切成两只长度分别为 ⌊px⌋ \\lfloor px \\rfloor ⌊px⌋ 和 x−⌊px⌋ x - \\lfloor px \\rfloor x−⌊px⌋ 的蚯蚓。特殊地，如果这两个数的其中一个等于 0 0 0，则这个长度为 0 0 0 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 q q q（是一个非负整常数）。 蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 m m m 秒才能到来 ……（m m m 为非负整数） 蛐蛐国王希望知道这 m m m 秒内的战况。具体来说，他希望知道： m m m 秒内，每一秒被切断的蚯蚓被切断前的长度（有 m m m 个数）； m m m 秒后，所有蚯蚓的长度（有 n+m n + m n+m 个数）。 蛐蛐国王当然知道怎么做啦！但是他想考考你 …… 链接LYOI#103 题解当 q=0 q = 0 q=0 时，首先将蚯蚓排序，然后每次将切割后的两段蚯蚓分别放入两个队列中，则三个队列始终是单调的。设第 i i i 次取出并切开的蚯蚓的长度为 ai a_i a​i​​，切开之后两段的长度分别为 li l_i l​i​​ 和 ri r_i r​i​​，那么对于第 i+1 i + 1 i+1 取出的蚯蚓，一定有 ai+1&lt;ai a_{i + 1} &lt; a_i a​i+1​​&lt;a​i​​，这是因为我们每次取最长的来切并且所有的蚯蚓长度只会减少，由此可得，一定有 li+1&lt;li,ri+1&lt;ri l_{i + 1} &lt; l_i, r_{i + 1} &lt; r_i l​i+1​​&lt;l​i​​,r​i+1​​&lt;r​i​​。 当 q≠0 q \\neq 0 q≠0时，每秒钟除了被切的蚯蚓，其他所有蚯蚓长度增加 q q q，可以将其余蚯蚓增加 q q q 改为被切开的两段减少 q q q ，此时三个序列仍满足单调性，正确性显然。 时间复杂度为 O(nlogn+m) O(n\\log n + m) O(nlogn+m)，如果被辣鸡stl中队列卡常，可以尝试手写队列。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;climits&gt;using namespace std;const int MAXN = 100000;const int MAXM = 70000000;queue&lt;int&gt; q[3];int getMax () &#123; int res = -1; for (int i = 0; i &lt; 3; i++) if (!q[i].empty() &amp;&amp; (res == -1 || q[i].front() &gt; q[res].front())) res = i; return res;&#125;bool cmp (int a, int b) &#123; return a &gt; b; &#125;int len[MAXN + 1];int main () &#123; freopen(\"earthworm.in\", \"r\", stdin); freopen(\"earthworm.out\", \"w\", stdout); int n, m, k, u, v, t; scanf(\"%d %d %d %d %d %d\", &amp;n, &amp;m, &amp;k, &amp;u, &amp;v, &amp;t); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;len[i]); sort(len, len + n, cmp); for (int i = 0; i &lt; n; i++) q[0].push(len[i]); int d = 0, frt; for (int i = 1; i &lt;= m; i++) &#123; int j = getMax(); frt = q[j].front(); q[j].pop(); frt += d; if (i % t == 0) printf(\"%d \", frt); int a = static_cast&lt;long long&gt;(frt) * u / v, b = frt - a; d += k; a -= d, b -= d; q[1].push(a); q[2].push(b); &#125; printf(\"\\n\"); for (int i = 1; i &lt;= n + m; i++) &#123; int j = getMax(); int ans = q[j].front(); q[j].pop(); ans += d; if (i % t == 0) printf(\"%d \", ans); &#125; fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.top/tags/NOIP/"},{"name":"单调队列","slug":"单调队列","permalink":"http://sulfur6.top/tags/单调队列/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"组合数问题 - 组合数学，递推，二维前缀和","slug":"NOIP2016-problem","date":"2016-11-30T13:15:30.000Z","updated":"2016-12-27T13:38:16.000Z","comments":true,"path":"NOIP2016-problem/","link":"","permalink":"http://sulfur6.top/NOIP2016-problem/","excerpt":"考场上写了个暴力递推，还忘了取模，下场想想这种题放在平时就是水题。。","text":"考场上写了个暴力递推，还忘了取模，下场想想这种题放在平时就是水题。。 题面组合数表示的是从 n n n 个物品中选出 m m m 个物品的方案数。举个例子，从 (1,2,3) (1, 2, 3) (1,2,3) 三个物品中选择两个物品可以有 (1,2) (1, 2) (1,2)，(1,3) (1, 3) (1,3)，(2,3) (2, 3) (2,3) 这三种选择方法。 根据组合数的定义，我们可以给出计算组合数的一般公式： Cnm=n!m!(n−m)! C_n ^ m = \\frac{n!}{m!(n - m)!} C​n​m​​=​m!(n−m)!​​n!​​其中 n!=1×2×⋯×n n! = 1 \\times 2 \\times \\cdots \\times n n!=1×2×⋯×n。 小葱想知道如果给定 n n n，m m m 和 k k k，对于所有的 0≤i≤n 0 \\leq i \\leq n 0≤i≤n，0≤j≤min(i,m) 0 \\leq j \\leq \\min(i, m) 0≤j≤min(i,m) 有多少对 (i,j) (i, j) (i,j) 满足是 k k k 的倍数。 链接LYOI# 题解组合数递推，你们乐意叫Pascal定理就叫好了反正我叫杨辉三角。。。 Cnm=Cn−1m+Cn−1m−1 C_{n}^{m} = C_{n-1}^{m} + C_{n-1}^{m-1} C​n​m​​=C​n−1​m​​+C​n−1​m−1​​递推过程中每次取模，若该位取模后为000则记该位答案为111，反之为000，对答案数组求二维前缀和，每次O(1)O(1)O(1)查询即可。 总复杂度O(2×20002+T)O(2 \\times 2000^2 + T)O(2×2000​2​​+T) 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2000;int f[MAXN + 1][MAXN + 1], ans[MAXN + 1][MAXN + 1];int main () &#123; freopen(\"problem.in\", \"r\", stdin); freopen(\"problem.out\", \"w\", stdout); int t, k; scanf(\"%d %d\", &amp;t, &amp;k); for (int i = 0; i &lt;= MAXN; i++) f[i][0] = f[i][i] = 1; for (int i = 2; i &lt;= MAXN; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % k; if (f[i][j] == 0) ans[i][j]++; &#125; &#125; for (int i = 1; i &lt;= MAXN; i++) &#123; for (int j = 1; j &lt;= MAXN; j++) &#123; ans[i][j] = ans[i - 1][j] + ans[i][j - 1] - ans[i - 1][j - 1] + ans[i][j]; &#125; &#125; while (t--) &#123; int n, m; scanf(\"%d %d\", &amp;n, &amp;m); printf(\"%d\\n\", ans[n][m]); &#125; fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.top/tags/NOIP/"},{"name":"组合数学","slug":"组合数学","permalink":"http://sulfur6.top/tags/组合数学/"},{"name":"递推","slug":"递推","permalink":"http://sulfur6.top/tags/递推/"},{"name":"前缀和","slug":"前缀和","permalink":"http://sulfur6.top/tags/前缀和/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"换教室 - NOIP2016，Floyd，概率与期望","slug":"NOIP2016-classroom","date":"2016-11-30T13:15:25.000Z","updated":"2016-12-27T13:32:27.000Z","comments":true,"path":"NOIP2016-classroom/","link":"","permalink":"http://sulfur6.top/NOIP2016-classroom/","excerpt":"考场上的我还不会期望，再加上当时由于策略失误被第二题绊了很长时间，导致我没有时间去想第三题，只骗了4分。。","text":"考场上的我还不会期望，再加上当时由于策略失误被第二题绊了很长时间，导致我没有时间去想第三题，只骗了4分。。 题面对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。 在可以选择的课程中，有 2n 2n 2n 节课程安排在 n n n 个时间段上。在第 i i i （1≤i≤n 1 \\leq i \\leq n 1≤i≤n）个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室 ci c_i c​i​​ 上课，而另一节课程在教室 di d_i d​i​​ 进行。 在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的 n n n 节安排好的课程。如果学生想更换第i节课程的教室，则需要提出申请。若申请通过，学生就可以在第 i i i 个时间段去教室 di d_i d​i​​ 上课，否则仍然在教室 ci c_i c​i​​ 上课。 由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第 i i i 节课程的教室时，申请被通过的概率是一个已知的实数 ki k_i k​i​​，并且对于不同课程的申请，被通过的概率是互相独立的。 学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多 m m m 节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请白己最希望更换教室的 m m m 门课程，也可以不用完这 m m m 个申请的机会，甚至可以一门课程都不申请。 因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。 牛牛所在的大学有 v v v 个教室，有 e e e 条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第 i i i（1≤i≤n−1 1 \\leq i \\leq n - 1 1≤i≤n−1）节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。 现在牛牛想知道，申请哪几门课程可以使他因在教室问移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。 链接LYOI#101 题解\u0010这题说是考了期望，然而关于概率的内容只有期望的定义和概率的乘法计算，当然也考了十分冷门的 。 这道题只有 300 300 300 个教室，所以可以用 求出多源最短路，在用 的时候注意判断重边，而且要注意一个教室到它自己的距离为 0 0 0 ，即邻接矩阵中 g(i,i) \\mathrm{g}(i,i) g(i,i) 应设为 0 0 0 而非常用的正无穷。 DP： 设状态 f(i,j,k) f(i,j,k) f(i,j,k) 表示在前 i i i 个阶段，已经用掉了 j j j 次申请机会，本次是否申请（k=0 k = 0 k=0 表示本次不申请，k=1 k = 1 k=1 表示本次申请）， 表示教室 i,ji, ji,j 之间的距离。 考虑 f(i,j,0) f(i,j,0) f(i,j,0) 的转移，上一次可以申请，也可以不申请，反正本次一定不申请是确定的，则有： f(i,j,0)=min{f(i−1,j,0)+dist(c(i−1),c(i))f(i−1,j,1)+dist(d(i−1),c(i))×k(i−1)+dist(c(i−1),c(i))×(1−k(i−1)) f(i, j, 0) = \\min \\begin{cases} f(i - 1, j, 0) + \\mathrm{dist}(c(i - 1), c(i)) \\\\ \\\\ \\begin{aligned} f(i - 1, j, 1) &amp; + \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\\\ &amp; + \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1)) \\end{aligned} \\end{cases} f(i,j,0)=min​⎩​⎪​⎪​⎨​⎪​⎪​⎧​​​f(i−1,j,0)+dist(c(i−1),c(i))​​​f(i−1,j,1)​​​​+dist(d(i−1),c(i))×k(i−1)​+dist(c(i−1),c(i))×(1−k(i−1))​​​​f(i,j,1) f(i,j,1) f(i,j,1) 的转移要长一点： f(i,j,1)=min{f(i−1,j−1,0)+dist(c(i−1),d(i))×k(i)+dist(c(i−1),c(i))×(1−k(i))f(i−1,j−1,1)+dist(d(i−1),d(i))×k(i−1)×k(i)+dist(c(i−1),d(i))×(1−k(i−1))×k(i)+dist(d(i−1),c(i))×k(i−1)×(1−k(i))+dist(c(i−1),c(i))×(1−k(i−1))×(1−k(i)) f(i, j, 1) = \\min \\begin{cases} \\begin{aligned} f(i - 1, j - 1, 0) &amp;+ \\mathrm{dist}(c(i - 1), d(i)) \\times k(i) \\\\ &amp;+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i)) \\end{aligned} \\\\ \\\\ \\begin{aligned} f(i - 1, j - 1, 1) &amp;+ \\mathrm{dist}(d(i - 1), d(i)) \\times k(i - 1) \\times k(i) \\\\ &amp;+ \\mathrm{dist}(c(i - 1), d(i)) \\times (1 - k(i - 1)) \\times k(i) \\\\ &amp;+ \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\times (1 - k(i)) \\\\ &amp;+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1)) \\times (1 - k(i)) \\end{aligned} \\end{cases} f(i,j,1)=min​⎩​⎪​⎪​⎪​⎪​⎪​⎪​⎪​⎪​⎨​⎪​⎪​⎪​⎪​⎪​⎪​⎪​⎪​⎧​​​​f(i−1,j−1,0)​​​​+dist(c(i−1),d(i))×k(i)​+dist(c(i−1),c(i))×(1−k(i))​​​​​f(i−1,j−1,1)​​​​​​+dist(d(i−1),d(i))×k(i−1)×k(i)​+dist(c(i−1),d(i))×(1−k(i−1))×k(i)​+dist(d(i−1),c(i))×k(i−1)×(1−k(i))​+dist(c(i−1),c(i))×(1−k(i−1))×(1−k(i))​​​​边界 f(i,0,1)=+∞f(1,0,0)=0 \\begin{aligned} f(i, 0, 1) &amp;= +\\infty \\\\ f(1, 0, 0) &amp;= 0 \\end{aligned} ​f(i,0,1)​f(1,0,0)​​​=+∞​=0​​时间复杂度为 O(v3+nm) O(v ^ 3 + nm) O(v​3​​+nm)。 代码#include &lt;cstdio&gt;#include &lt;cfloat&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;const int MAXN = 2000;const int MAXM = 2000;const int MAXV = 300;const int MAXE = 90000;int g[MAXV + 1][MAXV + 1], d[MAXN + 1], c[MAXN + 1], n, m, v, e;double k[MAXN + 1];void floyd () &#123; for (int a = 1; a &lt;= v; a++) &#123; for (int b = 1; b &lt;= v; b++) &#123; for (int c = 1; c &lt;= v; c++) &#123; if (g[b][a] != INT_MAX &amp;&amp; g[a][c] != INT_MAX &amp;&amp; g[b][c] &gt; g[b][a] + g[a][c]) &#123; g[b][c] = g[b][a] + g[a][c]; &#125; &#125; &#125; &#125;&#125;double f[MAXN + 1][MAXM + 1][2];int main () &#123; freopen(\"classroom.in\", \"r\", stdin); freopen(\"classroom.out\", \"w\", stdout); scanf(\"%d %d %d %d\", &amp;n, &amp;m, &amp;v, &amp;e); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;c[i]); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;d[i]); for (int i = 1; i &lt;= n; i++) scanf(\"%lf\", &amp;k[i]); for (int i = 1; i &lt;= v; i++) &#123; for (int j = 1; j &lt;= v; j++) &#123; g[i][j] = INT_MAX; &#125; &#125; for (int i = 1; i &lt;= e; i++) &#123; int fr, to, w; scanf(\"%d %d %d\", &amp;fr, &amp;to, &amp;w); g[fr][to] = g[to][fr] = min(w, g[fr][to]); &#125; floyd(); for (int i = 1; i &lt;= v; i++) g[i][i] = 0; f[1][0][0] = 0; f[1][0][1] = DBL_MAX; for (int i = 2; i &lt;= n; i++) &#123; f[i][0][0] = f[i - 1][0][0] + g[c[i - 1]][c[i]]; f[i][0][1] = DBL_MAX; for (int j = 1; j &lt;= m; j++) &#123; f[i][j][0] = f[i][j][1] = DBL_MAX; if (f[i - 1][j][0] != DBL_MAX) &#123; f[i][j][0] = min(f[i][j][0], f[i - 1][j][0] + g[c[i - 1]][c[i]]); &#125; if (f[i - 1][j][1] != DBL_MAX) &#123; f[i][j][0] = min(f[i][j][0], f[i - 1][j][1] + (g[c[i - 1]][c[i]] * (1 - k[i - 1])) + (g[d[i - 1]][c[i]] * k[i - 1])); &#125; if (f[i - 1][j - 1][0] != DBL_MAX) &#123; f[i][j][1] = min(f[i][j][1], f[i - 1][j - 1][0] + (g[c[i - 1]][d[i]] * k[i]) + (g[c[i - 1]][c[i]] * (1 - k[i]))); &#125; if (f[i - 1][j - 1][1] != DBL_MAX) &#123; f[i][j][1] = min(f[i][j][1], f[i - 1][j - 1][1] + (g[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i])) + (g[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i])) + (g[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i]) + (g[d[i - 1]][d[i]] * k[i - 1] * k[i])); &#125; &#125; &#125; double ans = DBL_MAX; for (int j = 0; j &lt;= m; j++) &#123; ans = min(ans, f[n][j][0]); ans = min(ans, f[n][j][1]); &#125; printf(\"%.2lf\\n\", ans); fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.top/tags/NOIP/"},{"name":"Floyd","slug":"Floyd","permalink":"http://sulfur6.top/tags/Floyd/"},{"name":"概率","slug":"概率","permalink":"http://sulfur6.top/tags/概率/"},{"name":"数学期望","slug":"数学期望","permalink":"http://sulfur6.top/tags/数学期望/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"玩具迷题 - NOIP2016，模拟","slug":"NOIP2016-toy","date":"2016-11-30T13:15:19.000Z","updated":"2016-12-27T13:29:50.000Z","comments":true,"path":"NOIP2016-toy/","link":"","permalink":"http://sulfur6.top/NOIP2016-toy/","excerpt":"场上30分钟写完的，手造了几组数据，最后 A 掉了，没翻车很棒","text":"场上30分钟写完的，手造了几组数据，最后 A 掉了，没翻车很棒 题面小南有一套可爱的玩具小人，它们各有不同的职业。 有一天，这些玩具小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外。 这时 singer 告诉小南一个谜题：「眼镜藏在我左数第 3 3 个玩具小人的右数第 111 个玩具小人的左数第 222 个玩具小人那里。」 小南发现，这个谜题中玩具小人的朝向非常关键， 因为朝内和朝外的玩具小人的左右方向是相反的：面朝圈内的玩具小人，它的左边是顺时针方向，右边是逆时针方向；而面向圈外的玩具小人，它的左边是逆时针方向，右边是顺时针方向。 小南一边艰难地辨认着玩具小人，一边数着： singer 朝内，左数第 333 个是 archer。 archer 朝外，右数第 111 个是 thinker。 thinker 朝外，左数第 222 个是 writer。 所以眼镜藏在 writer 这里！ 虽然成功找回了眼镜，但小南并没有放心。如果下次有更多的玩具小人藏他的眼镜，或是谜题的长度更长，他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。这样的谜题具体可以描述为： 有n n n个玩具小人围成一圈，已知它们的职业和朝向。现在第 111 个玩具小人告诉小南一个包含 mmm 条指令的谜题。其中第 iii 条指令形如「左数/右数第 sis_is​i​​ 个玩具小人」。你需要输出依次数完这些指令后，到达的玩具小人的职业。 链接LYOI#99 题解模拟。 根据朝向，顺加逆减，每次取模，防止越界 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;const int MAXN = 100000;string name[MAXN + 1]; int face[MAXN + 1];int main () &#123; freopen(\"toy.in\", \"r\", stdin); freopen(\"toy.out\", \"w\", stdout); int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = n; i &gt;= 1; i--) &#123; scanf(\"%d\", &amp;face[i]); cin &gt;&gt; name[i]; &#125; name[0] = name[n]; face[0] = face[n]; // for (int i = n; i &gt;= 1; i--) cout &lt;&lt; face[i] &lt;&lt; endl; int dirans = n; for (int i = 0; i &lt; m; i++) &#123; int dir, vec; scanf(\"%d %d\", &amp;dir, &amp;vec); if (face[dirans] == 0 &amp;&amp; dir == 0) &#123; int mov = (dirans + vec) % n; dirans = mov; &#125; else if (face[dirans] == 0 &amp;&amp; dir == 1) &#123; int mov = ((dirans - vec) + n) % n; dirans = mov; &#125; else if (face[dirans] == 1 &amp;&amp; dir == 0) &#123; int mov = ((dirans - vec) + n) % n; dirans = mov; &#125; else if (face[dirans] == 1 &amp;&amp; dir == 1) &#123; int mov = (dirans + vec) % n; dirans = mov; &#125; &#125; cout &lt;&lt; name[dirans] &lt;&lt; endl; fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.top/tags/NOIP/"},{"name":"模拟","slug":"模拟","permalink":"http://sulfur6.top/tags/模拟/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"石子归并，区间DP","slug":"mergeStone","date":"2016-11-30T12:31:45.000Z","updated":"2016-12-27T13:23:59.000Z","comments":true,"path":"mergeStone/","link":"","permalink":"http://sulfur6.top/mergeStone/","excerpt":"区间动态规划入门题，难度并不大，注意认真读题。。。","text":"区间动态规划入门题，难度并不大，注意认真读题。。。 题目大意有nnn堆石子排成一列，每堆石子有一个重量wiw_iw​i​​, 每次合并可以合并相邻的两堆石子，一次合并的代价为两堆石子的重量和wi+wi+1w_i+w_{i+1}w​i​​+w​i+1​​，求怎样合并能使合并代价最小，输出最小代价。 题解区间DP 记合并[l,r][l,r][l,r]这段区间内的石子所需的代价为f(l,r)f(l,r)f(l,r)，则有: f(l,r)=mink=lr−1(f(l,r), f(l,k)+f(k+1,r))+sum(l,r) f(l,r)=\\min_{k=l}^{r-1}(f(l,r),\\ f(l,k) + f(k+1,r))+sum(l,r) f(l,r)=​k=l​min​r−1​​(f(l,r), f(l,k)+f(k+1,r))+sum(l,r)记sum(l,r)=∑i=lrwisum(l,r)=\\sum\\limits_{i=l}^{r}w_isum(l,r)=​i=l​∑​r​​w​i​​ 那么接下来的工作就是确定递推顺序，这题的递推顺序是从短区间向长区间递推，因为我们发现状态中每次转移需要用到的状态只需要用到从之前的较短的区间中得到的值。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;const int MAXN = 100;int a[MAXN + 1], f[MAXN + 1][MAXN + 1];int main () &#123; int n; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); a[i] = a[i] + a[i - 1]; &#125; for (int i = 1; i &lt;= n; i++) f[i][i] = 0; for (int len = 1; len &lt; n; len++) &#123; int r; for (int l = 1; l &lt;= n - len; l++) &#123; r = l + len; int minn = INT_MAX; for (int k = l; k &lt; r; k++) &#123; minn = min(f[l][k] + f[k + 1][r], minn); &#125; f[l][r] = minn + a[r] - a[l - 1]; &#125; &#125; printf(\"%d\\n\", f[1][n]); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.top/tags/DP/"},{"name":"区间DP","slug":"区间DP","permalink":"http://sulfur6.top/tags/区间DP/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"火柴排队，贪心，逆序对，NOIP2013","slug":"Sticks-NOIP","date":"2016-11-10T11:47:10.000Z","updated":"2016-12-27T13:23:10.000Z","comments":true,"path":"Sticks-NOIP/","link":"","permalink":"http://sulfur6.top/Sticks-NOIP/","excerpt":"一道NOIP的贪心题，代码难度一般，然而思维含量蛮高（也可以说是很绕）。。","text":"一道NOIP的贪心题，代码难度一般，然而思维含量蛮高（也可以说是很绕）。。 题目大意给定两个数列a,ba,ba,b，每个数列中相邻两个数可以交换，求使得∑i=1n(ai−bi)2\\sum\\limits_{i=1}^{n}(a_i-b_i)^2​i=1​∑​n​​(a​i​​−b​i​​)​2​​最小的交换次数，答案对999999979999999799999997取模 题解当∣a−b∣|a-b|∣a−b∣尽可能小的时候，(a−b)2(a-b)^2(a−b)​2​​最小，所以，这道题实际上就是让数列aaa中的元素与数列bbb中的元素，按照它们在两个数列中所在的大小位置对应排列，简单来说，比如某个元素aja_ja​j​​在数列aaa中是第三大的，那么满足题意的与他对应的bjb_jb​j​​在数列bbb中也一定是第三大的。详细的证明过程不再赘述（其实是我自己证明困难QwQ） 具体做法就是现将两个数列排序，这样我们就获得了两个数列中哪两个元素应该对应排列在一起，然而实际操作并不需要同时移动两列数，我们只需要固定一列数移动另一列使其满足该大小关系即可，所以我们记录每个元素本来的位置，问题转化为求一个序列中原位置关于另一个序列原位置的逆序对。。确实很绕，上代码理解吧。。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000;const int MOD = 99999997;struct Stick &#123; int id, height; bool operator&lt;(const Stick &amp;other) const &#123; return height &lt; other.height; &#125;&#125; s1[MAXN + 1], s2[MAXN + 1];int t[MAXN + 1], tmp[MAXN + 1];int ans;void mergeSort (int *a, int l, int r) &#123; if (l &gt;= r) return; int mid = (l + r) / 2; mergeSort(a, l, mid); mergeSort(a, mid + 1, r); int i = l, j = mid + 1, k = l; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (a[i] &gt; a[j]) &#123; tmp[k++] = a[j++]; ans = (ans + (mid - i + 1) % MOD) % MOD; &#125; else &#123; tmp[k++] = a[i++]; &#125; &#125; while (i &lt;= mid) tmp[k++] = a[i++]; while (j &lt;= r) tmp[k++] = a[j++]; for (int i = l; i &lt;= r; i++) a[i] = tmp[i]; return;&#125;int main () &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;s1[i].height); s1[i].id = i; &#125; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;s2[i].height); s2[i].id = i; &#125; sort(s1, s1 + n); sort(s2, s2 + n); for (int i = 0; i &lt; n; i++) t[s2[i].id] = s1[i].id; mergeSort(t, 0, n - 1); printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.top/tags/NOIP/"},{"name":"贪心","slug":"贪心","permalink":"http://sulfur6.top/tags/贪心/"},{"name":"逆序对","slug":"逆序对","permalink":"http://sulfur6.top/tags/逆序对/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"花匠，最长波动子序列，NOIP","slug":"Gavin-NicholasAndHisFlower","date":"2016-11-10T11:47:01.000Z","updated":"2016-12-27T13:23:14.000Z","comments":true,"path":"Gavin-NicholasAndHisFlower/","link":"","permalink":"http://sulfur6.top/Gavin-NicholasAndHisFlower/","excerpt":"经典的栋栋系列题目！好吧我承认这是一道很不错的贪心题","text":"经典的栋栋系列题目！好吧我承认这是一道很不错的贪心题 题目大意给定一个序列，求其中最长波动子序列 题解据说这题可以动归，然而感觉动归爆炸，就贪了个心 正解是枚举所有的拐点，将拐点加入子序列中一定比加入其他点更优，因为拐点比可以容纳更多的点在其中波动，最后特判起点和终点是否可以加入序列中即可 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;const int MAXN = 100000;int height[MAXN + 1];int main () &#123; int n; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;height[i]); &#125; bool isUping = true; int ans = 0; if (height[1] &gt;= height[2]) isUping = false; else isUping = true; for (int i = 2; i &lt;= n - 1; i++) &#123; if (isUping &amp;&amp; height[i] &gt; height[i + 1]) &#123; isUping = false; ans++; &#125; else if (!isUping &amp;&amp; height[i] &lt; height[i + 1]) &#123; isUping = true; ans++; &#125; &#125; if (height[1] == height[2]) ans--; if (height[n - 1] == height[n]) ans--; ans += 2; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.top/tags/NOIP/"},{"name":"贪心","slug":"贪心","permalink":"http://sulfur6.top/tags/贪心/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"飞扬的小鸟，DP，背包，NOIP2014","slug":"Flappy-Bird","date":"2016-11-08T00:15:09.000Z","updated":"2016-12-27T13:23:49.000Z","comments":true,"path":"Flappy-Bird/","link":"","permalink":"http://sulfur6.top/Flappy-Bird/","excerpt":"四个月前我尝试着做过这道题，当时在天宇哥哥的课上自认为听懂了，然后。。就没有然后了","text":"四个月前我尝试着做过这道题，当时在天宇哥哥的课上自认为听懂了，然后。。就没有然后了 题目大意 给定一个长为nnn，高为mmm的二位平面，其中有kkk个管道（不计宽度） 小鸟从平面最左边出发，到达平面最右边时游戏完成 小鸟每单位时间沿横坐标方向右移距离为1，竖直移动距离由玩家控制，如果点击屏幕，小鸟会上升一定高度XXX，每单位时间内可以点击多次，效果叠加，如果不点击屏幕，小鸟会下降一定高度YYY 小鸟位于不同的横坐标位置时，上升高度XXX和下降高度YYY可能互不相同 小鸟高度为mmm时，无法再上升 小鸟高度等于000或小鸟碰到管道时，游戏失败 要求： 如果能完成游戏，输出最少点击屏幕次数 如果不能，输出最多能通过的水管 题解由于每单位时间可以点击多次屏幕，所以对于上升的过程，可以看做一个完全背包。 设f(i,j)f(i,j)f(i,j)表示到达坐标为(i,j)(i,j)(i,j)的点时，所需最少点击次数，这个状态由可以由前一个单位时间中点击若干次屏幕得到，也可以由前一个单位时间中不点击屏幕掉落一段高度得到，由此可得方程： f(i,j)=mink=1j÷Xi−1(f(i−1,j−kXi−1)+k,f(i−1,j+Yi−1)) f(i,j)=\\min\\limits_{k=1}^{j\\div X_{i-1}}(f(i-1,j-kX_{i-1})+k,f(i-1,j+Y_{i-1})) f(i,j)=​k=1​min​j÷X​i−1​​​​(f(i−1,j−kX​i−1​​)+k,f(i−1,j+Y​i−1​​))然而这种情况下每一次枚举的时间复杂度为O(m)O(m)O(m)，总时间复杂度为O(nm2)O(nm^2)O(nm​2​​)，无法通过全部数据 考虑点击kkk次和点击k−1k-1k−1次之间的联系，如果点击kkk次，则可以到达纵坐标为jjj的位置，点击k−1k-1k−1次，可以到达纵坐标为j−Xi−1j-X_{i-1}j−X​i−1​​的位置，由此可得方程（仅考虑点击时的情况）： f(i,j)=min(f(i−1,j−Xi−1)+1,f(i,j−Xi−1)+1) f(i,j)=\\min(f(i-1,j-X_{i-1})+1,f(i,j-X_{i-1})+1) f(i,j)=min(f(i−1,j−X​i−1​​)+1,f(i,j−X​i−1​​)+1)在上述仅考虑点击时的方程中，从f(i,j−Xi−1)f(i,j-X_{i-1})f(i,j−X​i−1​​)转移到f(i,j)f(i,j)f(i,j)的过程，可看做由f(i−1,j−2Xi−1)f(i-1,j-2X_{i-1})f(i−1,j−2X​i−1​​)转移到f(i,j)f(i,j)f(i,j)，得到f(i,j−Xi−1)f(i,j-X_{i-1})f(i,j−X​i−1​​)的过程同理，这样枚举是完整的完全背包，可以保证可点击多次 在使用优化过的方程的时候，我们不能在处理点击的同时处理不点击，因为在同一时刻我们不能既点击又不点击，所以说对于不点击的处理应该放在处理完所有的点击之后。 而且，由于我们的某个状态f(i,j)f(i,j)f(i,j)可能由f(i,j−Xi−1)f(i,j-X_{i-1})f(i,j−X​i−1​​)递推得来，而(i,j−Xi−1)(i,j-X_{i-1})(i,j−X​i−1​​)这个位置可能是障碍，所以我们不能直接将所有的障碍的答案设为INT_MAX（不可达到），而是递推得到某列的所有答案后，再将该列的水管位置的对应答案设为INT_MAX 前面递推的答案只针对(i,1)−&gt;(i,m−1)(i,1)-&gt;(i,m-1)(i,1)−&gt;(i,m−1)，对于(i,m)(i,m)(i,m)，我们要做特殊处理 最终输出答案时，对所有最右列的fff值取最小，若最右列的值全部都为INT_MAX，则证明游戏不可完成，我们就从第n−1n-1n−1列向左寻找可以通过的某一列，记录包括这一列之前一共有多少个障碍，此为小鸟最终能通过的障碍数量 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;const int MAXN = 10000;const int MAXM = 1000;struct Pipe &#123; bool exist; int top, bot;&#125; a[MAXN + 1];int n, m, k, X[MAXN + 1], Y[MAXN + 1];template &lt;typename T&gt; bool cmin (T &amp;a, const T &amp;b) &#123; return (a &gt; b) ? (a = b, true) : false;&#125;int main () &#123; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d %d\", &amp;X[i], &amp;Y[i]); &#125; for (int i = 0; i &lt; k; i++) &#123; int x; scanf(\"%d\", &amp;x); a[x].exist = true; scanf(\"%d %d\", &amp;a[x].bot, &amp;a[x].top); &#125; static int f[MAXN + 1][MAXM + 1]; f[0][0] = INT_MAX; for (int i = 1; i &lt;= n; i++) &#123; f[i][0] = INT_MAX; for (int j = 1; j &lt; m; j++) &#123; f[i][j] = INT_MAX; if (j &gt;= X[i - 1]) &#123; if (f[i - 1][j - X[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j - X[i - 1]] + 1); if (f[i][j - X[i - 1]] != INT_MAX) cmin(f[i][j], f[i][j - X[i - 1]] + 1); &#125; &#125; for (int j = 1; j &lt;= m - Y[i - 1]; j++) &#123; if (f[i - 1][j + Y[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + Y[i - 1]]); &#125; f[i][m] = INT_MAX; for (k = m - X[i - 1]; k &lt;= m; k++) &#123; if (f[i - 1][k] != INT_MAX) cmin(f[i][m], f[i - 1][k] + 1); if (f[i][k] != INT_MAX) cmin(f[i][m], f[i][k] + 1); &#125; if (a[i].exist) for (int j = 1; j &lt;= m; j++) if (j &gt;= a[i].top || j &lt;= a[i].bot) f[i][j] = INT_MAX; &#125; int clicks = INT_MAX; for (int i = 1; i &lt;= m; i++) cmin(clicks, f[n][i]); //printf(\"%d\\n\", clicks); if (clicks != INT_MAX) &#123; printf(\"1\\n%d\\n\", clicks); &#125; else &#123; int pos = -1; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (f[i][j] != INT_MAX) &#123; pos = i; break; &#125; &#125; if (pos != -1) break; &#125; int cnt = 0; for (int i = 1; i &lt;= pos; i++) if (a[i].exist) cnt++; printf(\"0\\n%d\\n\", cnt); &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.top/tags/NOIP/"},{"name":"DP","slug":"DP","permalink":"http://sulfur6.top/tags/DP/"},{"name":"背包","slug":"背包","permalink":"http://sulfur6.top/tags/背包/"},{"name":"完全背包","slug":"完全背包","permalink":"http://sulfur6.top/tags/完全背包/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"挖矿，DP，扩展欧几里德","slug":"mining-dp","date":"2016-11-07T12:01:29.000Z","updated":"2016-12-27T13:23:45.000Z","comments":true,"path":"mining-dp/","link":"","permalink":"http://sulfur6.top/mining-dp/","excerpt":"模拟赛上的题，贪心贪了一上午，然后，就没有然后了","text":"模拟赛上的题，贪心贪了一上午，然后，就没有然后了 题目大意 有m+1m+1m+1个星球，从000到mmm编号，yqy最初在000号星球 有nnn处矿体，第iii出矿体有aia_ia​i​​单位原矿，在编号为bib_ib​i​​的星球上 飞船每次只能从xxx号星球移动到x+4x+4x+4或x+7x+7x+7号星球，每到一个星球yqy会采走该星球上所有的原矿 求yqy最多能采走多少原矿 注意： yqy不必最终到达mmm号星球 对于100%100\\%100%的数据，n≤105,m≤109n\\leq 10^5, m\\leq 10^9n≤10​5​​,m≤10​9​​ 题解设f(i)f(i)f(i)表示走到第iii个星球时最多可以得到的原矿数量，用viv_iv​i​​表示第iii个星球上有的原矿数量，易得： f(i)=max(f(i−4),f(i−7))+wi f(i)=\\max(f(i-4),f(i-7))+w_i f(i)=max(f(i−4),f(i−7))+w​i​​然而对于100%100\\%100%的数据，mmm很大，这样会超时超内存，所以我们需要做一些优化。 首先扯一会Exgcd： 对于一个方程ax+by=cax+by=cax+by=c，此方程有整数解的充要条件是gcd(a,b)∣c\\gcd(a,b)\\mid cgcd(a,b)∣c，对于本题中每一个想要到达的距离ddd，可以写成4x+7y=d4x+7y=d4x+7y=d的形式，由于gcd(4,7)=1\\gcd(4,7)=1gcd(4,7)=1所以ddd为任意正整数时，该方程都有整数解。 然而，本题只有当所求x,yx,yx,y都为正整数时，才称对应ddd为可到达的。 经过枚举，我们发现，当d≥18d\\geq 18d≥18时，对应的x,yx,yx,y都为整数，也就是说，如果某两个有矿物的星球之间距离大于等于181818，我们可以将它们之间的距离压缩成181818，这样的时间复杂度和空间复杂度就达到了O(n×18)O(n\\times 18)O(n×18)，极限数据n=105n=10^5n=10​5​​，轻松过 代码#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;climits&gt;using namespace std;const int MAXN = 1e5;const int MAXM = 1e9;struct Mine &#123; int pos, val; bool operator&lt;(const Mine &amp;other) const &#123; return pos &lt; other.pos; &#125;&#125; a[MAXN];int main () &#123; freopen(\"mining.in\", \"r\", stdin); freopen(\"mining.out\", \"w\", stdout); int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d %d\", &amp;a[i].val, &amp;a[i].pos); &#125; sort(a, a + n); int Del = 0, Last = 0, maxPos = 0; for (int i = 0; i &lt; n; i++) &#123;//压缩距离 a[i].pos -= Del; int Gap = a[i].pos - Last; if (Gap &gt; 18) &#123; int t = Gap - 18; a[i].pos -= t; Del += t; &#125; Last = a[i].pos; maxPos = max(maxPos, a[i].pos); &#125; static int w[MAXN * 18 + 1], f[MAXN * 18 + 1]; for (int i = 0; i &lt; n; i++) w[a[i].pos] += a[i].val; for (int i = 1; i &lt;= maxPos; i++) f[i] = INT_MIN; w[0] = f[0] = 0; int ans = INT_MIN; for (int i = 1; i &lt;= maxPos; i++) &#123; if (i &gt;= 4) f[i] = max(f[i], f[i - 4] + w[i]); if (i &gt;= 7) f[i] = max(f[i], f[i - 7] + w[i]); ans = max(ans, f[i]); &#125; printf(\"%d\\n\", ans); fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.top/tags/DP/"},{"name":"数论","slug":"数论","permalink":"http://sulfur6.top/tags/数论/"},{"name":"Exgcd","slug":"Exgcd","permalink":"http://sulfur6.top/tags/Exgcd/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"子串，DP，NOIP2015","slug":"substring","date":"2016-11-06T11:56:57.000Z","updated":"2017-02-07T00:55:02.000Z","comments":true,"path":"substring/","link":"","permalink":"http://sulfur6.top/substring/","excerpt":"一个子序列可以不连续，子串必须连续，遂有一句笑话：连续的子序列。。。某蒟蒻因为没搞清子串和子序列看了一晚上题解都没看懂。。。。。","text":"一个子序列可以不连续，子串必须连续，遂有一句笑话：连续的子序列。。。某蒟蒻因为没搞清子串和子序列看了一晚上题解都没看懂。。。。。 题目大意 有两个仅包含小写英文字母的字符串A和B 现在要从字符串A中取出k个互不重叠的非空子串，然后把这k个子串按照其在字符串A中出现的顺序依次连接起来得到一个新的字符串 求使得新串与B串相同的方案数 子串取出的位置不同，认为是不同的方案。 题解设f(i,j,t)f(i,j,t)f(i,j,t)表示使用从串A中前iii位取出的ttt个子串匹配串B前jjj位（必选AiA_iA​i​​）的方案数，g(i,j,t)g(i,j,t)g(i,j,t)表示使用串A中前iii位取出的ttt个子串匹配串B的前jjj位（不必选AiA_iA​i​​）的方案数。 计算f(i,j,t)f(i,j,t)f(i,j,t)时，考虑AiA_iA​i​​作为前一个子串的最后一位的方案数，即f(i−1,j−1,t)f(i-1,j-1,t)f(i−1,j−1,t)，与单独作为一个子串的方案数，即g(i−1,j−1,t−1)g(i-1,j-1,t-1)g(i−1,j−1,t−1)，则对于f(i,j,t)f(i,j,t)f(i,j,t)，有： f(i,j,t)={f(i−1,j−1,t)+g(i−1,j−1,t−1)Ai=Bj0Ai≠Bj f(i,j,t)= \\begin{cases} f(i-1,j-1,t)+g(i-1,j-1,t-1) &amp; A_i = B_j \\\\ 0 &amp; A_i\\neq B_j \\end{cases} f(i,j,t)={​f(i−1,j−1,t)+g(i−1,j−1,t−1)​0​​​A​i​​=B​j​​​A​i​​≠B​j​​​​对于g(i,j,t)g(i,j,t)g(i,j,t)，则有： g(i,j,t)={g(i−1,j,t)+f(i,j,t)Ai=Bjg(i−1,j,t)Ai≠Bj g(i,j,t)= \\begin{cases} g(i-1,j,t)+f(i,j,t) &amp; A_i=B_j \\\\ g(i-1,j,t) &amp; A_i\\neq B_j \\end{cases} g(i,j,t)={​g(i−1,j,t)+f(i,j,t)​g(i−1,j,t)​​​A​i​​=B​j​​​A​i​​≠B​j​​​​需要滚动数组优化 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000;const int MAXM = 200;const int MAXK = 200;const int MOD = 1e9 + 7;int main () &#123; static int f[2][MAXN + 1][MAXM + 1], g[2][MAXN + 1][MAXM + 1]; int n, m, k; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k); static char A[MAXN], B[MAXM]; scanf(\"%s\\n%s\", A, B); g[0][0][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; const int cur = i % 2, pre = !cur; memset(f[cur], 0, sizeof(f[cur])); memset(g[cur], 0, sizeof(g[cur])); g[cur][0][0] = f[cur][0][0] = 1; for (int j = 1; j &lt;= m; j++) &#123; for (int t = 1; t &lt;= min(j, k); t++) &#123; if (A[i - 1] == B[j - 1]) &#123; f[cur][j][t] = ((f[pre][j - 1][t] % MOD) + (g[pre][j - 1][t - 1] % MOD)) % MOD; g[cur][j][t] = ((g[pre][j][t] % MOD) + (f[cur][j][t] % MOD)) % MOD; &#125; else &#123; f[cur][j][t] = 0; g[cur][j][t] = g[pre][j][t]; &#125; &#125; &#125; &#125; printf(\"%d\\n\", g[n % 2][m][k]); return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.top/tags/NOIP/"},{"name":"DP","slug":"DP","permalink":"http://sulfur6.top/tags/DP/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"选课，树形DP","slug":"chose-class","date":"2016-11-03T12:16:14.000Z","updated":"2016-12-27T13:23:01.000Z","comments":true,"path":"chose-class/","link":"","permalink":"http://sulfur6.top/chose-class/","excerpt":"据说存储树的结构叫做左儿子右兄弟，管他呢，我也不知道，当年CTSC的一道树形DP。","text":"据说存储树的结构叫做左儿子右兄弟，管他呢，我也不知道，当年CTSC的一道树形DP。 题目大意 给定NNN门课，每门课有自己的学分，可能有一门先修课 不同的课程可能有共同的先修课 求在学习课程项目限制MMM内，可能获得的最大学分 存储这题使用类似邻接表的方式存储树，对每一个节点，记录它的一个孩子节点，对于其他直连它的节点，使用邻接表串起来，对于没有先修课的节点，我们设置一个虚拟000节点。 代码实现： struct Tree &#123; Tree *child, *next; int w; struct Answer &#123; bool solved; int value; inline Answer(): solved(false) &#123;&#125; &#125; ans[MAXM + 1]; inline Tree() &#123;&#125; inline Tree(Tree *parent, int w): w(w), next(parent-&gt;child) &#123;&#125;&#125; trees[MAXN + 1]; 树形DP 设f(i,m)f(i,m)f(i,m)表示选择节点iii，并为节点iii的孩子节点和兄弟节点分配m−1m-1m−1门选课机会所能获得的学分最大值，则有: 枚举kkk，给节点iii的孩子节点分配kkk门课，给节点iii的兄弟节点分配m−k−1m-k-1m−k−1个节点， 不选择节点iii及其孩子节点，全部mmm门课都分给它的兄弟节点 f(i,m)=max(maxk=0m−1(f(i.child,k)+f(i.next,m−k−1)),f(i,next,m)) f(i,m)=\\max(\\max\\limits_{k=0}^{m-1}(f(i.child,k)+f(i.next,m-k-1)), f(i,next,m)) f(i,m)=max(​k=0​max​m−1​​(f(i.child,k)+f(i.next,m−k−1)),f(i,next,m))代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 300;const int MAXM = 300;struct Tree &#123; Tree *child, *next; int w; struct Answer &#123; bool solved; int value; inline Answer(): solved(false) &#123;&#125; &#125; ans[MAXM + 1]; inline Tree() &#123;&#125; inline Tree(Tree *parent, int w): w(w), next(parent-&gt;child) &#123;&#125;&#125; trees[MAXN + 1];int n, m;void addEdge(int parent, int child, int w) &#123; trees[parent].child = new (&amp;trees[child]) Tree(&amp;trees[parent], w);&#125;inline int solve (Tree *t, int m) &#123; if (!t || m &lt; 0) return 0; if (!t-&gt;ans[m].solved) &#123; t-&gt;ans[m].value = 0; for (int i = 0; i &lt; m; i++) &#123; t-&gt;ans[m].value = max(t-&gt;ans[m].value, solve(t-&gt;child, i) + solve(t-&gt;next, m - i - 1) + t-&gt;w); &#125;//枚举k t-&gt;ans[m].value = max(t-&gt;ans[m].value, solve(t-&gt;next, m)); t-&gt;ans[m].solved = true; &#125; return t-&gt;ans[m].value;&#125;int main () &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int parent, w; scanf(\"%d %d\", &amp;parent, &amp;w); addEdge(parent, i, w); &#125; printf(\"%d\\n\", solve(&amp;trees[0], m + 1));//多了一门虚拟课，所以m+1 return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.top/tags/DP/"},{"name":"树形DP","slug":"树形DP","permalink":"http://sulfur6.top/tags/树形DP/"},{"name":"codevs","slug":"codevs","permalink":"http://sulfur6.top/tags/codevs/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"生日蛋糕，DFS，POJ1190","slug":"birthday-cake","date":"2016-10-31T12:07:43.000Z","updated":"2016-12-27T13:23:27.000Z","comments":true,"path":"birthday-cake/","link":"","permalink":"http://sulfur6.top/birthday-cake/","excerpt":"生日蛋糕带我走上深搜不归路","text":"生日蛋糕带我走上深搜不归路 题目大意 制作一个体积为NπN\\piNπ，共MMM层的蛋糕 从上往下数第i,(1≤i≤M)i,(1\\leq i\\leq M)i,(1≤i≤M)的蛋糕是半径为RiR_iR​i​​，高度为HiH_iH​i​​的圆柱 当i&lt;Mi&lt;Mi&lt;M时，要求Ri&gt;Ri+1R_i&gt;R_{i+1}R​i​​&gt;R​i+1​​且Hi&gt;Hi+1H_i&gt;H_{i+1}H​i​​&gt;H​i+1​​ 使得蛋糕的表面积最小 在这里本题需要输出的答案并不是最小的表面积，而是最小表面积除以π\\piπ之后的结果 思路 深搜 模拟拼蛋糕 暴力枚举下一层可能的蛋糕半径与高度 只需记录更新侧面积，所有顶面积等于最底层蛋糕的底面积 超时？ 剪枝！！！ 如何剪枝 在这里分可行性剪枝与最优性剪枝 最优性剪枝 当前已拼成的蛋糕表面积比已经记录的最优解大 可行性剪枝 无可用体积 拼成这些层最少体积大于当前需要拼的体积 目前枚举的高度半径不足以拼完蛋糕 当前可能拼成的最大体积比需要拼的体积少 代码#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int n, m;int minArea = 1 &lt;&lt; 30;//记录最优解int area = 0;//记录当前解int minV[30], minA[30];//分别记录拼成i层最小可能的体积和表面积int MaxVforNRH (int n, int r, int h) &#123; int v; for (int i = 0; i &lt; n; ++i) v += (r - i) * (r - i) * (h - i); return v;&#125;//计算在还有n层没拼完，当前一层的半径为r，高度为h时可能拼成的最大体积void dfs (int v, int n, int r, int h) &#123; if (n == 0) &#123; if (v) return; else &#123; minArea = min(minArea, area); return; &#125; &#125; if (v &lt;= 0) return;//可行1 if (minV[n] &gt; v) return;//可行2 if (area + minA[n] &gt;= minArea) return;//最优 if (h &lt; n || r &lt; n) return;//可行3 if (MaxVforNRH(n, r, h) &lt; v) return;//可行4 for (int rr = r; rr &gt;= n; --rr) &#123;//爆搜 if (n == m) area = rr * rr; for (int hh = h; hh &gt;= n; hh--) &#123; area += 2 * rr * hh; dfs (v - rr * rr * hh, n - 1, rr - 1, hh - 1); area -= 2 * rr * hh; &#125; &#125;&#125;int main () &#123; cin &gt;&gt; n &gt;&gt; m; minA[0] = 0; minV[0] = 0; for (int i = 1; i &lt;= m; ++i) &#123; minV[i] = minV[i - 1] + i * i * i; minA[i] = minA[i - 1] + 2 * i * i; &#125; if (minV[m] &gt; n) cout &lt;&lt; 0 &lt;&lt; endl; else &#123;//处理搜索边界 int maxH = (n - minV[m - 1]) / (m * m) + 1; int maxR = sqrt(double(n - minV[m - 1]) / m) + 1; area = 0; minArea = 1 &lt;&lt; 30; dfs (n, m, maxR, maxH); if (minArea == 1 &lt;&lt; 30) cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; minArea &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://sulfur6.top/tags/DFS/"},{"name":"POJ","slug":"POJ","permalink":"http://sulfur6.top/tags/POJ/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"斗地主，DFS，状态压缩，记忆化搜索","slug":"landlord-NOIP2015","date":"2016-10-29T12:56:32.000Z","updated":"2016-12-27T13:22:57.000Z","comments":true,"path":"landlord-NOIP2015/","link":"","permalink":"http://sulfur6.top/landlord-NOIP2015/","excerpt":"大概两周前，我还是一个不会DFS的小蒟蒻，当时看到斗地主这题，心中简直是千万匹草泥马飘过","text":"大概两周前，我还是一个不会DFS的小蒟蒻，当时看到斗地主这题，心中简直是千万匹草泥马飘过 题目大意 给定一副扑克牌，牌面随机，按照斗地主的方式打出，求最少出完要多少次 规则: 单顺子五个起，最多到A，不包括2和王 连对从三对起，最多到A，不包括2和王 飞机两个起，最多到A，不包括2和王，不可带牌 三张可以带一张也可以带一对，可以单打 四张可以带两张或者两对，可以单打 大小王可以当火箭出，但是打带牌的时候不能当对牌带 一对和单牌和斗地主完全一样 思路DFS 大暴力搜索 考虑暴力枚举每一种出发，进行爆搜 状态压缩优化最暴力的爆搜一定会T掉，考虑记忆化搜索:对于某种状态下的牌，如果已经搜过，就不再搜。 所有的状态可以用一个五进制数存下来（因为每种点数的牌最多有四张），然后转化成十进制数，恰好可以用C++中的unsigned long long存下。 接下来我们用一个哈希表（map也是滋磁的），来存储每一种状态，每次搜索前查表，如果已经搜过，则直接返回值，没搜过，在本次搜索结束返回值时记录本种状态下的答案。 代码我用了一个数组来存每种牌有几张，其中0，1表示大小王，2~10代表2~10的对应点数，11~13表示J~K，14表示A #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;tr1/unordered_map&gt;#include &lt;climits&gt;#define MAXN 15#define update() ans = min(ans, dfs() + 1)using namespace std;typedef unsigned long long Status;int Hand[MAXN];inline Status zip () &#123; Status s = 0; for (int i = 0; i &lt; MAXN; i++) &#123; s = s * 5 + Hand[i]; &#125; return s;&#125;/*inline void print()&#123; for(int i = 0; i &lt; MAXN; i++)&#123; printf(\"%d \", Hand[i]); &#125; putchar('\\n');&#125;*/tr1::unordered_map&lt;Status, int&gt; S;int dfs() &#123; //print(); Status s = zip(); if (s == 0) return 0; if (S.count(s)) return S[s]; int ans = INT_MAX; bool SSingle = true; //Joker if (Hand[0] &amp;&amp; Hand[1]) &#123; Hand[0] = Hand[1] = 0; update(); Hand[0] = Hand[1] = 1; SSingle = false; &#125;//某玄学优化，有对王先出对王，好像这样会更快 //34567 for (int i = 3; i &lt; MAXN - 4; i++) &#123; bool flag = false; for (int d = 0; d &lt; 5; d++) &#123; if (!Hand[i + d]) &#123; flag = true; break; &#125; &#125; if (flag) continue; for (int d = 0; d &lt; 5; d++) Hand[i + d]--; update(); int j; for (j = i + 5; j &lt; MAXN &amp;&amp; Hand[j]; j++) &#123; Hand[j]--; update(); &#125; for (int k = i; k &lt; j; k++) Hand[k]++; SSingle = false; &#125; //334455 for (int i = 3; i &lt; MAXN - 2; i++) &#123; bool flag = false; for (int d = 0; d &lt; 3; d++) if (Hand[i + d] &lt; 2) &#123; flag = true; break; &#125; if (flag) continue; for (int d = 0; d &lt; 3; d++) Hand[i + d] -= 2; update(); int j; for (j = i + 3; j &lt; MAXN &amp;&amp; Hand[j] &gt;= 2; j++) &#123; Hand[j] -= 2; update(); &#125; for (int k = i; k &lt; j; k++) Hand[k] += 2; SSingle = false; &#125; //333444 for (int i = 3; i &lt; MAXN - 1; i++) &#123; bool flag = false; for (int d = 0; d &lt; 2; d++) if (Hand[i + d] &lt; 3) &#123; flag = true; break; &#125; if (flag) continue; for (int d = 0; d &lt; 2; d++) Hand[i + d] -= 3; update(); int j; for (j = i + 2; j &lt; MAXN &amp;&amp; Hand[j] &gt;= 3; j++) &#123; Hand[j] -= 3; update(); &#125; for (int k = i; k &lt; j; k++) Hand[k] += 3; SSingle = false; &#125; //3 + x for (int i = 2; i &lt; MAXN; i++) if (Hand[i] &gt;= 3) &#123; Hand[i] -= 3; update(); for (int j = 0; j &lt; MAXN; j++) if (Hand[j] &gt;= 1) &#123; Hand[j]--; update(); Hand[j]++; &#125; for (int j = 2; j &lt; MAXN; j++) if (Hand[j] &gt;= 2) &#123; Hand[j] -= 2; update(); Hand[j] += 2; &#125; Hand[i] += 3; SSingle = false; &#125; //4 + x for (int i = 2; i &lt; MAXN; i++) if (Hand[i] == 4) &#123; Hand[i] -= 4; update(); for (int j = 0; j &lt; MAXN; j++) if (Hand[j] &gt;= 1)&#123; Hand[j]--; for (int k = 0; k &lt; MAXN; k++) if (Hand[k] &gt;= 1) &#123; Hand[k]--; update(); Hand[k]++; &#125; Hand[j]++; &#125; for (int j = 2; j &lt; MAXN; j++) if (Hand[j] &gt;= 2) &#123; Hand[j] -= 2; for (int k = 2; k &lt; MAXN; k++) if (Hand[k] &gt;= 2) &#123; Hand[k] -= 2; update(); Hand[k] += 2; &#125; Hand[j] += 2; &#125; Hand[i] += 4; SSingle = false; &#125; //2 for (int i = 2; i &lt; MAXN; i++) if (Hand[i] &gt;= 2) &#123; Hand[i] -= 2; update(); Hand[i] += 2; SSingle = false; &#125; //1 if (SSingle) &#123; ans = 0; for (int i = 0; i &lt; MAXN; i++) &#123; ans += Hand[i]; &#125; &#125; return S[s] = ans;&#125;int main () &#123; int T, n; scanf(\"%d %d\", &amp;T, &amp;n); while (T--) &#123; memset(Hand, 0, sizeof(Hand)); S.clear(); for (int i = 0; i &lt; n; i++) &#123; int x, y; scanf(\"%d %d\", &amp;x, &amp;y); if (x == 0) Hand[y - 1]++; else if (x == 1) Hand[14]++; else Hand[x]++; &#125; printf(\"%d\\n\", dfs()); &#125; return 0;&#125; 原来感觉难道爆炸的题，真正做完以后却感觉就是一道大暴力的题，想了很久也没有什么可写的。。最后说一句，tr1害死人。。","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://sulfur6.top/tags/NOIP/"},{"name":"DFS","slug":"DFS","permalink":"http://sulfur6.top/tags/DFS/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://sulfur6.top/tags/状态压缩/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://sulfur6.top/tags/记忆化搜索/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"灌溉草场，线性DP，POJ2373","slug":"pour-the-grass","date":"2016-10-28T01:24:04.000Z","updated":"2016-12-27T13:23:05.000Z","comments":true,"path":"pour-the-grass/","link":"","permalink":"http://sulfur6.top/pour-the-grass/","excerpt":"一道比较难的线性DP，主要是限制条件太多，而且我又太弱。","text":"一道比较难的线性DP，主要是限制条件太多，而且我又太弱。 题目大意 一片草场上有长度为L(1≤L≤106)(1 \\leq L \\leq 10^6)(1≤L≤10​6​​)，且为偶数的线段 John的NNN头奶牛在操场上沿着这条线段吃草 每头奶牛的活动范围是一个开区间(S,E)(S,E)(S,E)，S,ES,ES,E都是整数 不同奶牛活动范围有重叠 现在要安装若干个可调节的喷水头灌溉草场，每个喷水头的工作半径在可[A,B][A,B][A,B]中调节 要求喷水头满足下列要求 线段上每个整点恰好位于一个喷水头的喷洒范围内 每头奶牛的活动范围要位于一个喷水头的喷洒范围 任何喷水头的喷洒范围不得超过线段两端 求John最少要安装多少个喷水头，若无法刚好安装则输出−1-1−1 问题分析 从左端点向右端点安装喷水头，设F(X)F(X)F(X)表示:所安装喷水头的喷洒范围恰好覆盖直线上的区间[0,X][0,X][0,X]时，最少需要多少个喷水头 显然，X满足： X为偶数 X所在位置不会出现奶牛，即XXX不属于任何一个(S,E)(S,E)(S,E) X≥2AX\\geq2AX≥2A 当X&gt;2BX&gt;2BX&gt;2B时，存在Y∈[X−2B,X−2A]Y\\in [X-2B,X-2A]Y∈[X−2B,X−2A]且YYY满足上述三个条件使得F(X)=F(Y)+1F(X)=F(Y)+1F(X)=F(Y)+1 解题思路递推计算F(X)F(X)F(X) F(X)=∞:XF(X)=\\infty:XF(X)=∞:X是奇数 F(X)=∞:X&lt;2AF(X)=\\infty:X&lt;2AF(X)=∞:X&lt;2A F(X)=∞:XF(X)=\\infty:XF(X)=∞:X处可能有奶牛出没 F(X)=1:2A≤X≤2BF(X)=1:2A\\leq X \\leq 2BF(X)=1:2A≤X≤2B，且XXX位于任何奶牛活动范围之外 F(X)=1+minY=X−2BX−2AF(Y),YF(X)=1 +\\min\\limits_{Y=X-2B}^{X-2A} F(Y),YF(X)=1+​Y=X−2B​min​X−2A​​F(Y),Y位于任何奶牛的活动范围之外，且X&gt;2B 优化F(X)=1+minY=X−2BX−2AF(Y),YF(X)=1 +\\min\\limits_{Y=X-2B}^{X-2A} F(Y),YF(X)=1+​Y=X−2B​min​X−2A​​F(Y),Y位于任何奶牛的活动范围之外，且X&gt;2B。 对于此转移中的每个XXX求F(X)F(X)F(X)都要便利区间[X−2B,X−2A][X-2B,X-2A][X−2B,X−2A],太慢 所以快速找到此区间使得F(Y)F(Y)F(Y)最小的元素是解题的关键。可以用堆来优化哦 使用C++的STL中的priority_queue 求F(X)F(X)F(X)时，我们维护一个小根堆，保证堆中包含所有的i∈[X−2B,X−2A]i\\in [X-2B,X-2A]i∈[X−2B,X−2A]所对应的F(i)F(i)F(i)值，这样操作时间就从扫区间的O(N)O(N)O(N)级别变成了O(log2N)O(\\log_2N)O(log​2​​N)级别了 求解XXX对应的F(X)F(X)F(X)时，不允许堆中出现坐标大于X−2AX-2AX−2A的点，这样的点不能用来转移F(X)F(X)F(X)，又不能抛弃之，因为它可能对求后续点的FFF值有用 堆中可以出现坐标小于X−2BX-2BX−2B的点，若其出现在对头，则抛弃 求出XXX点的FFF值后，将(X−2A+2,(F(X−2A+2)))(X-2A+2,(F(X-2A+2)))(X−2A+2,(F(X−2A+2)))放入堆，为求F(X+2)F(X+2)F(X+2)作准备 堆中点坐标皆为偶数 代码#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int INF = 1 &lt;&lt; 31;const int MAXL = 1000010;const int MAXN = 1010;int F[MAXL];int cowThere[MAXL];//用于记录某点是否有奶牛出没int n, l, a, b;struct Fx &#123; int x, f; bool operator&lt;(const Fx &amp;a) const &#123;return f &gt; a.f;&#125; Fx(int xx = 0, int ff = 0): x(xx), f(ff) &#123;&#125;&#125;;//优先队列用结构体priority_queue&lt;Fx&gt; q;int main () &#123; cin &gt;&gt; n &gt;&gt; l; cin &gt;&gt; a &gt;&gt; b; a &lt;&lt;= 1; b &lt;&lt;= 1;//线性操作，所以先将半径处理成直径 memset(cowThere, 0, sizeof(cowThere)); for (int i = 0; i &lt; n; i++) &#123; int s, e; cin &gt;&gt; s &gt;&gt; e; cowThere[s + 1]++; cowThere[e]--; &#125; int inCows = 0; for (int i = 0; i &lt;= l; i++) &#123; F[i] = INF; inCows += cowThere[i]; cowThere[i] = inCows &gt; 0; &#125;//利用差分思想实现快速记录某点是否有奶牛出没 for (int i = a; i &lt;= b; i += 2) &#123; if (!cowThere[i]) &#123; F[i] = 1; if (i &lt;= b + 2 - a) q.push(Fx(i, 1));//确保提前进堆的点可以用于首轮递推 &#125; &#125;//首先初始化初始区间，为最开始的边界做准备 for (int i = b + 2; i &lt;= l; i += 2) &#123;//dp() if (!cowThere[i]) &#123; Fx fx; while (!q.empty()) &#123; fx = q.top(); if (fx.x &lt; i - b) q.pop();//如果堆顶元素坐标小于X-2B，抛弃不用 else break; &#125; if (!q.empty()) F[i] = fx.f + 1;//如果堆空了，说明原来所有堆中元素全部不可用 &#125; if (F[i - a + 2] != INF) q.push(Fx(i - a + 2, F[i - a + 2])); &#125; if (F[l] == INF) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; F[l] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"POJ","slug":"POJ","permalink":"http://sulfur6.top/tags/POJ/"},{"name":"DP","slug":"DP","permalink":"http://sulfur6.top/tags/DP/"},{"name":"线性DP","slug":"线性DP","permalink":"http://sulfur6.top/tags/线性DP/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"小机房的树，LCA，倍增","slug":"gaogay","date":"2016-10-26T09:14:34.000Z","updated":"2016-12-27T13:22:18.000Z","comments":true,"path":"gaogay/","link":"","permalink":"http://sulfur6.top/gaogay/","excerpt":"终于学会了三个多月前学习的倍增求LCA，最近几年经常出很恶心的带LCA的题。。看看就浑身难受。。","text":"终于学会了三个多月前学习的倍增求LCA，最近几年经常出很恶心的带LCA的题。。看看就浑身难受。。 题目大意 一棵NNN个节点的树，节点编号从000到N−1N-1N−1 每条边有为ccc的边权 求从两个不同的叶节点移动到同一节点最少花费 共MMM次询问 思路 如果只有一次询问，可以用最短路算法，然而询问次数过多，使用堆优化迪杰斯特拉在极限数据下计算次数将会达到101010^{10}10​10​​级别 因为这是一棵树，所以我们可以很容易想到让两个叶子节点在同一高度向上跳，第一次同时跳到的点，维护两个节点跳过的距离就是最小花费 基于这种想法，我们成功引出了LCA——最近公共祖先 做法求LCA 倍增 ST表 Tarjan 树链剖分 针对我现在是一个NOIP选手的现实基础，我选择使用简单好写的倍增求解法。 倍增求解朴素算法朴素LCA算法是先让更深的节点向上跳，跳到和深度较浅的点深度相同时，让两个节点同时向上跳，那么第一个跳到的同一个节点就是这两个节点的最近公共祖先。 可是这样太慢了，极限情况遇到一条链的树就会变成O(N)O(N)O(N)。 如何优化？ 既然一次跳一步太少了，那就一次多跳几步 有一个神奇的东西叫做二进制拆分，就是可以把一个数拆成若干个2k2^k2​k​​加和的形式，这样每个不大于它的正整数都可以用多项式中若干项的和来表示。 所以，我们用二元组f(i,j)f(i,j)f(i,j)表示从编号为iii的节点向上跳2j2^j2​j​​步可以跳到的节点编号，用g(i,j)g(i,j)g(i,j)表示从编号为iii的节点向上跳2j2^j2​j​​步所需花费（即边权和）。 那么对于每一个f(i,j)f(i,j)f(i,j)与g(i,j)g(i,j)g(i,j)，有 f(i,j)=f(f(i,j−1),j−1) f(i,j)=f(f(i,j-1),j-1) f(i,j)=f(f(i,j−1),j−1)g(i,j)=g(i,j−1)+g(f(i,j−1),j−1) g(i,j)=g(i,j-1)+g(f(i,j-1),j-1) g(i,j)=g(i,j−1)+g(f(i,j−1),j−1) 这里用到了倍增的思想，就是从第iii个点往上跳2j2^j2​j​​步相当于从第iii个点往上跳两个2j−12^{j-1}2​j−1​​次方步，即先从iii向上跳2j2^j2​j​​步，再从跳到的点向上跳2j2^j2​j​​步。 BFS预处理前面提到了一个操作，就是让两个点先到达同一深度，所以说我们需要用BFS预处理出深度。 设根节点深度为111，然后一层一层向下广搜，每次广搜出的点的深度为当前深度加一。 查询 qwq先上代码好了 inline int query (int u, int v) &#123; if (N[u].depth &lt; N[v].depth) std::swap(u, v); //保证u是较深的节点 int ans = 0; if (N[u].depth &gt; N[v].depth) &#123;//使两个节点处在相同深度 for (int j = logn; j &gt;= 0; j--) &#123; if (N[f[u][j]].depth &gt;= N[v].depth) &#123; ans += g[u][j]; u = f[u][j]; &#125; &#125;//从大到小枚举指数，保证对应二进制位正常不进位 &#125; if (u != v) &#123; for (int j = logn; j &gt;= 0; j--) &#123;//同时向上跳 if (f[u][j] != f[v][j]) &#123; ans += g[u][j]; ans += g[v][j]; u = f[u][j]; v = f[v][j]; &#125;//让两个节点跳到LCA的儿子 &#125; ans += g[u][0]; ans += g[v][0]; u = f[u][0]; &#125; return ans;//本题需要维护路径和&#125; 代码#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;const int MAXN = 50000;const int MAXLOG = 16;int n, m, logn;int f[MAXN + 5][MAXLOG];int g[MAXN + 5][MAXLOG];struct Node;struct Edge;struct Node &#123; int depth; Edge *h; Node () :depth(0), h(NULL) &#123;&#125;&#125; N[MAXN];struct Edge &#123; Node *fr, *to; int w; Edge *ne; Edge (Node *fr, Node *to, int w) : fr(fr), to(to), w(w) &#123; ne = fr-&gt;h; &#125;&#125;;inline void addEdge (Node *u, Node *v, int w) &#123; u-&gt;h = new Edge(u, v, w); v-&gt;h = new Edge(v, u, w);&#125; //用于BFS的邻接表inline void bfs () &#123; std::queue &lt;Node *&gt; q; q.push(&amp;N[0]); N[0].depth = 1; f[0][0] = 0; g[0][0] = 0; while (!q.empty()) &#123; Node *u = q.front(); q.pop(); for (Edge *e = u-&gt;h; e != NULL; e = e-&gt;ne) &#123; if (!e-&gt;to-&gt;depth) &#123; e-&gt;to-&gt;depth = u-&gt;depth + 1; f[e-&gt;to - N][0] = u - N; g[e-&gt;to - N][0] = e-&gt;w; q.push(e-&gt;to); &#125; &#125; &#125;&#125;inline void prepare () &#123; bfs(); while ((1 &lt;&lt; logn) &lt;= n) logn++; logn--; for (int j = 1; j &lt;= logn; j++) &#123; for (int i = 0; i &lt; n; i++) &#123; f[i][j] = f[f[i][j - 1]][j - 1]; g[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1]; &#125; &#125;&#125; //预处理出f,j数组inline int query (int u, int v) &#123; if (N[u].depth &lt; N[v].depth) std::swap(u, v); int ans = 0; if (N[u].depth &gt; N[v].depth) &#123; for (int j = logn; j &gt;= 0; j--) &#123; if (N[f[u][j]].depth &gt;= N[v].depth) &#123; ans += g[u][j]; u = f[u][j]; &#125; &#125; &#125; if (u != v) &#123; for (int j = logn; j &gt;= 0; j--) &#123; if (f[u][j] != f[v][j]) &#123; ans += g[u][j]; ans += g[v][j]; u = f[u][j]; v = f[v][j]; &#125; &#125; ans += g[u][0]; ans += g[v][0]; u = f[u][0]; &#125; return ans;&#125;int main () &#123; int m; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n - 1; i++) &#123; int u, v, w; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); addEdge(&amp;N[u], &amp;N[v], w); addEdge(&amp;N[v], &amp;N[u], w); &#125; prepare(); scanf(\"%d\", &amp;m); while (m--) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); printf(\"%d\\n\", query(u, v)); &#125; return 0;&#125; 为什么说倍增好写又好用呢？因为Tarjan和ST表不能维护瓶颈路径（比如最大边或最小边），而树链剖分又比较难，所以贴心的队长就只讲了倍增qwq。","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"倍增","slug":"倍增","permalink":"http://sulfur6.top/tags/倍增/"},{"name":"LCA","slug":"LCA","permalink":"http://sulfur6.top/tags/LCA/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"迎接仪式，线性DP","slug":"welcome-ceremony","date":"2016-10-25T12:07:34.000Z","updated":"2016-12-27T13:23:54.000Z","comments":true,"path":"welcome-ceremony/","link":"","permalink":"http://sulfur6.top/welcome-ceremony/","excerpt":"这种DP让人不知所措，果然我还是Too young.. 多做题多积累。。","text":"这种DP让人不知所措，果然我还是Too young.. 多做题多积累。。 题目大意 给定一个仅由j与z组成的的字符串 允许最多交换KKK次字符串中字符 使得字符串中jz子串尽量多 思路 看到这道题之后，我就想要暴力求解，然后。。就没有然后了 思路的关键之处在于，交换kkk次，其实意味着kkk个j变成z，kkk个z变成j。 于是，我们就开心的开始DP了 DP状态设f(i,j,z)f(i,j,z)f(i,j,z)表示前iii位中有jjj个j变成了z，有zzz个z变成了j 则，对于f(i,j,z)f(i,j,z)f(i,j,z)，有： f(i,j,z)=max(f(i−2,j−1,z),f(i−2,j,z−1),f(i−2,j−1,z−1),f(i−2,j,z)) f(i,j,z)=\\max(f(i-2,j-1,z),f(i-2,j,z-1),f(i-2,j-1,z-1),f(i-2,j,z)) f(i,j,z)=max(f(i−2,j−1,z),f(i−2,j,z−1),f(i−2,j−1,z−1),f(i−2,j,z)) 状态解释: f(i−2,j−1,z)f(i-2,j-1,z)f(i−2,j−1,z):字符串第i−1i-1i−1位为j，第iii位为j f(i−2,j,z−1)f(i-2,j,z-1)f(i−2,j,z−1):字符串第i−1i-1i−1位为z，第iii位为z f(i−2,j−1,z−1)f(i-2,j-1,z-1)f(i−2,j−1,z−1):字符串第i−1i-1i−1位为z，第iii位为j f(i−2,j,z)f(i-2,j,z)f(i−2,j,z):字符串第i−1i-1i−1位为j，第iii位为z。 只有在f(i,j,z)f(i,j,z)f(i,j,z)中j=zj=zj=z时才可更新答案，因为此时才满足题意中成对更新的意义 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;const int MAXN = 500;const int MAXK = 100;char a[MAXN + 1];int f[MAXN + 1][MAXK + 1][MAXK + 1];int n, k;int dp () &#123; f[0][0][0] = 0, f[1][0][0] = 0; int ans = 0; int x, y; for (int i = 2; i &lt;= n; i++) for (int j = 0; j &lt;= k; j++) for (int z = 0; z &lt;= k; z++) &#123; f[i][j][z] = f[i - 1][j][z]; if (a[i - 1] == 'z') x = 1; else x = 0; if (a[i] == 'j') y = 1; else y = 0; //小表，判断应该如何转移 if (j &gt;= x &amp;&amp; z &gt;= y) f[i][j][z] = std::max(f[i][j][z], f[i - 2][j - x][z - y] + 1); if (j == z) ans = std::max(ans, f[i][j][z]);//满足条件时更新答案 &#125; return ans;&#125;int main () &#123; freopen(\"welcome.in\", \"r\", stdin); freopen(\"welcome.out\", \"w\", stdout); scanf(\"%d %d\", &amp;n, &amp;k); scanf(\"%s\", a + 1); memset(f, -0x777f, sizeof(f)); printf(\"%d\\n\", dp()); fclose(stdin); fclose(stdout); return 0;&#125; 不得不说这题的转移实在是难想，果然我还是个小蒟蒻qwq","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sulfur6.top/tags/DP/"},{"name":"线性DP","slug":"线性DP","permalink":"http://sulfur6.top/tags/线性DP/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"线段树学习笔记","slug":"segment-tree","date":"2016-10-24T08:27:26.000Z","updated":"2017-01-04T02:11:18.000Z","comments":true,"path":"segment-tree/","link":"","permalink":"http://sulfur6.top/segment-tree/","excerpt":"中国高级数据结构领导者，唐氏线段树！【雾 其实并不是，下面即将介绍的是不会TLE的正版线段树哦","text":"中国高级数据结构领导者，唐氏线段树！【雾 其实并不是，下面即将介绍的是不会TLE的正版线段树哦 引言在线段树之前我们已经学习过了多中维护区间操作的技巧与数据结构。 维护区间最值:ST表 区间更改转化为单点更改:差分数组 区间和:前缀和 但是，它们有一个共同的缺点，就是更适合离线操作，一旦操作与查询为动态的，它们的时间复杂度就会变成 于是，我们开心的迎来了，线段树——SegmentTree\\mathfrak {Segment Tree}SegmentTree 定义摘自百度百科线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN)O(logN)O(logN)。而未优化的空间复杂度为2N2N2N，因此有时需要离散化让空间压缩。 简而言之线段树会让你的动态区间操作不会TLE。有时会MLE 具体构成对于这个二叉树，每一个节点可以维护一段[L,R][L,R][L,R]的区间内的信息，而对于它的左儿子，维护的是[L,⌊R2⌋][L,\\lfloor \\frac{R}{2} \\rfloor][L,⌊​2​​R​​⌋]这段区间中的信息，右儿子则维护的是[⌊R2⌋+1,R][\\lfloor \\frac{R}{2} \\rfloor + 1,R][⌊​2​​R​​⌋+1,R]这段区间内的信息。 Lazy Mark当我们对区间进行操作的时候，我们需要修改这段区间对应的所有后代的信息（因为他们算是这段区间的子集），但是我们并不需要对于每次操作都这样修改，因为有些时候我们并不会使用到它的后代记录的区间信息。 就这样，Lazy Mark（懒标记）应运而生。 void cover(long long delta) &#123; sum += delta * (r - l + 1); tag += delta;&#125;void pushDown() &#123; if (tag) &#123; lc-&gt;cover(tag); rc-&gt;cover(tag); tag = 0; &#125;&#125;//下放标记只下放一次，再向下查询再下放 POJ3468#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;new&gt;const int MAXN = 200000;template&lt;size_t SIZE&gt;struct MemoryPool &#123; char buf[SIZE], *cur; MemoryPool(): cur(buf) &#123;&#125; void init() &#123; cur = buf; &#125; void *alloc(const int &amp;size) &#123; char *p = cur; cur += size; return p; &#125;&#125;;MemoryPool&lt;(4 + 4 + 8 + 8 + 8 + 8) * MAXN * 5&gt; pool;struct SegmentTree &#123; int l, r; SegmentTree *lc, *rc; long long sum, tag; SegmentTree(int l, int r, SegmentTree *lc, SegmentTree *rc): l(l), r(r), lc(lc), rc(rc), sum(0), tag(0) &#123;&#125; void cover(long long delta) &#123; sum += delta * (r - l + 1); tag += delta; &#125; void pushDown() &#123; if (tag) &#123; lc-&gt;cover(tag); rc-&gt;cover(tag); tag = 0; &#125; &#125; void update(int l, int r, long long x) &#123; if (l &gt; this-&gt;r || r &lt; this-&gt;l) return; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) cover(x); else pushDown(), lc-&gt;update(l, r, x), rc-&gt;update(l, r, x), sum = lc-&gt;sum + rc-&gt;sum; &#125; long long querySum(int l, int r) &#123; if (l &gt; this-&gt;r || r &lt; this-&gt;l) return 0; else if (l &lt;= this-&gt;l &amp;&amp; r &gt;= this-&gt;r) return sum; else return pushDown(), lc-&gt;querySum(l, r) + rc-&gt;querySum(l, r); &#125;&#125; *root;SegmentTree *build(int l, int r) &#123; if (l == r) return new (pool.alloc(sizeof(SegmentTree))) SegmentTree(l, r, NULL, NULL); else &#123; int mid = l + (r - l) / 2; return new (pool.alloc(sizeof(SegmentTree))) SegmentTree(l, r, build(l, mid), build(mid + 1, r)); &#125;&#125;int main() &#123; int n, m; while (scanf(\"%d %d\", &amp;n, &amp;m) != EOF) &#123; root = NULL; pool.init(); root = build(1, n); for (int i = 1; i &lt;= n; i++) &#123; long long x; scanf(\"%lld\", &amp;x); root-&gt;update(i, i, x); &#125; char s[2]; for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%s\", s); if (s[0] == 'Q') &#123; int a, b; scanf(\"%d %d\", &amp;a, &amp;b); printf(\"%lld\\n\", root-&gt;querySum(a, b)); &#125; else if (s[0] == 'C') &#123; int l, r; long long x; scanf(\"%d %d %lld\", &amp;l, &amp;r, &amp;x); root-&gt;update(l, r, x); &#125; &#125; &#125; return 0;&#125; 入门题 Codevs1080,1081,1082(线段树联系1，2，3) 忠诚，忠诚S %唐氏线段树 数轴染色 借教室(常数大，需要内存池优化) Powered by Sulfur6\\mathfrak {Powered\\ by\\ Sulfur6}Powered by Sulfur6","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"区间操作","slug":"区间操作","permalink":"http://sulfur6.top/tags/区间操作/"},{"name":"线段树","slug":"线段树","permalink":"http://sulfur6.top/tags/线段树/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"Sudoku，暴力DFS，POJ2676","slug":"sudoku","date":"2016-10-23T11:53:10.000Z","updated":"2016-12-27T13:22:43.000Z","comments":true,"path":"sudoku/","link":"","permalink":"http://sulfur6.top/sudoku/","excerpt":"数独有趣，爆搜无脑。 还有回不去的还记得的一张张写满算式的纸，和解不出的Sudoku。","text":"数独有趣，爆搜无脑。 还有回不去的还记得的一张张写满算式的纸，和解不出的Sudoku。 题目大意标准9×99\\times 99×9的数独游戏，由你填上空缺的数 思路 填满每个空格 记录某一行，某一列，某一小格不能填的数 开始爆搜 搜索 搜索过程中，依次往每个格子中填数 简单Hash，O(1)O(1)O(1)判断某行某列某小格是否填写某数 注意事项 本题给定数据的数独矩阵，数和数之间没有空格，所以需要用字符处理。 当然为了某不愿透露姓名的PC同学的幸福生活，交完题我就更改了一下qwq 同时@PC,@SJQ 需要通过行号和列号确定所在小格号 其实也可以打个表解决这种问题 inline int Getblock (int r, int c) &#123; //r表示行，c表示列 int rr = r / 3; int cc = c / 3;; return rr * 3 + cc;&#125; 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;short r[9][10], c[9][10], block[9][10];//分别记录行、列、小格中填数的情况，r表示行，c表示列，block表示小格int board[9][9];struct Pos &#123; int r, c; Pos(int rr, int cc): r(rr), c(cc) &#123; &#125;&#125;;vector&lt;Pos&gt; blank;//结构体+Vector记录空白格inline int Getblock (int r, int c) &#123; int rr = r / 3; int cc = c / 3;; return rr * 3 + cc;&#125; //根据行列求小格void Setflag (int i, int j, int num, int f) &#123; r[i][num] = f; c[j][num] = f; block[Getblock(i, j)][num] = f;&#125; //为某一个元素所在行、列、小格设置上使用过或未使用的标记bool ok (int i, int j, int num) &#123; return !r[i][num] &amp;&amp; !c[j][num] &amp;&amp; !block[Getblock(i, j)][num];&#125; //询问当前位置某元素是否可用bool Dfs (int n) &#123; //n表示现在要填的空格的编号 if (n &lt; 0) return true; int r = blank[n].r, c = blank[n].c; for (int num = 1; num &lt;= 9; ++num) &#123; if (ok(r, c, num)) &#123; board[r][c] = num; Setflag(r, c, num, 1); if (Dfs(n - 1)) return true; Setflag(r, c, num, 0); //回溯 &#125; &#125; return false;&#125; //Based on POJ的毒瘤数据，我们选择右下向左上搜，其实左上向右下搜也可以int main () &#123; int t; cin &gt;&gt; t; //多组数据 while (t--) &#123; memset(r, 0, sizeof(r)); memset(c, 0, sizeof(c)); memset(block, 0, sizeof(block)); blank.clear(); //每组数据都要重置 for (int i = 0; i &lt; 9; ++i) &#123; for (int j = 0; j &lt; 9; ++j) &#123; char c; cin &gt;&gt; c; board[i][j] = c - '0'; //对付每空格的毒瘤数据 if (board[i][j]) Setflag(i, j, board[i][j], 1); else blank.push_back(Pos(i, j)); &#125; &#125; if (Dfs(blank.size() - 1)) &#123; for (int i = 0; i &lt; 9; ++i) &#123; for (int j = 0; j &lt; 9; ++j) cout &lt;&lt; char(board[i][j] + '0'); cout &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 想想当时班里同学整日颓数独的日子，如果我做过这道题的话该是多么好的一个装逼机会啊T\\^T","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://sulfur6.top/tags/DFS/"},{"name":"POJ","slug":"POJ","permalink":"http://sulfur6.top/tags/POJ/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"矩阵乘法优化递推，NOIP%你赛","slug":"matrix-increase","date":"2016-10-23T07:27:35.000Z","updated":"2016-12-27T13:35:38.000Z","comments":true,"path":"matrix-increase/","link":"","permalink":"http://sulfur6.top/matrix-increase/","excerpt":"今天的欢乐%你赛，由于第一题是大水题，第二题良心出题人良心部分分，第三题不严格卡迪杰斯特拉，让人心神愉悦，话虽如此，第二题想要拿满分还是很麻烦的（我才不要分块打表），所以，我们要请出矩阵乘法来优化递推","text":"今天的欢乐%你赛，由于第一题是大水题，第二题良心出题人良心部分分，第三题不严格卡迪杰斯特拉，让人心神愉悦，话虽如此，第二题想要拿满分还是很麻烦的（我才不要分块打表），所以，我们要请出矩阵乘法来优化递推 题目大意给定一个坐标系，可以往左，右，上走，已经走过的点（单次访问中）不可以重复走，一共可以走NNN步，求一共有多少种走法。 题目分析 表神，各单位提供丰富成功地证明了递推公式，然而，不适合这样做的蒟蒻Sulfur6更喜欢打表找规律。 这里我们就假装我们已经打完了这个表，然后发现它的前几项分别是： f(0)=1,f(1)=3,f(2)=7,f(3)=17,f(4)=41,f(5)=99 f(0) = 1, f(1) = 3, f(2) = 7, f(3) = 17, f(4) = 41, f(5) = 99 f(0)=1,f(1)=3,f(2)=7,f(3)=17,f(4)=41,f(5)=99后面不打了T ^ T，所以我们发现了一个递推公式： f(i)=f(i−2)+2×f(i−1) f(i) = f(i - 2) + 2 \\times f(i - 1) f(i)=f(i−2)+2×f(i−1)时间复杂度降至O(n)O(n)O(n)，但是极限数据高达10910^910​9​​，这时O(n)O(n)O(n)不靠谱。而且会MLE 矩阵 说矩阵优化之前先说说矩阵 形如 简而言之，矩阵是一坨数 矩阵乘法对于两个大小为N×MN \\times MN×M和P×NP \\times NP×N的矩阵A,BA,BA,B，他们相乘后的结果矩阵CCC是一个大小为M×PM \\times PM×P的矩阵。 对于矩阵CCC的每一位Ci,jC_{i,j}C​i,j​​，有: Ci,j=∑k=1NAi,k×Bk,j C_{i,j} = \\sum\\limits_{k = 1}^{N} A_{i,k} \\times B_{k,j} C​i,j​​=​k=1​∑​N​​A​i,k​​×B​k,j​​矩阵优化递推 团长并不知道这种玄学方法的由来，只知道我们可以用这种技巧来转移 这样相乘以后的结果: 也就是说我们可以通过矩阵相乘的方式来求出某递推公式的某一项，即: 如何优化 矩阵满足结合律 既然如此，我们就可以出动大杀器，快速幂，这样就可以在O(logn)O(logn)O(logn)的时间内求得递推公式的某一项了。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1e9;const int mo = 1e9 + 7;struct Mat &#123; long long a[2][2]; Mat (const bool unit = false) &#123; //构造函数，初始化矩阵值 memset(a, 0, sizeof(a)); if (unit) for (int i = 0; i &lt; 2; i++) a[i][i] = i;//此处矩阵用于快速幂中作为单位矩阵承载答案 &#125; long long &amp;operator()(const int i, const int j = 0) &#123; return a[i][j]; &#125; const long long &amp;operator()(const int i, const int j = 0) const &#123; return a[i][j]; &#125; //重载运算符并引用，快速取得并修改某矩阵的值&#125;;Mat operator*(const Mat &amp;a, const Mat &amp;b) &#123; //重载运算符，矩阵乘法 Mat res(false); for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) (res(i, j) += a(i, k) * b(k, j)) %= mo; return res;&#125;Mat pow(Mat a, int n) &#123; //矩阵快速幂 Mat res(true); for (; n; n &gt;&gt;= 1, a = a * a) if (n &amp; 1) res = res * a; return res;&#125;int main () &#123; freopen(\"coordinate.in\", \"r\", stdin); freopen(\"coordinate.out\", \"w\", stdout); int n; scanf(\"%d\", &amp;n); if (n == 0) printf(\"1\"); else if (n == 1) printf(\"3\"); else &#123; Mat init(false); //初始矩阵 init(0) = 1; init(1) = 3; Mat mat(false); //转移矩阵 mat(0, 0) = 0; mat(0, 1) = 1; mat(1, 0) = 1; mat(1, 1) = 2; Mat res = pow(mat, n - 1) * init; //此处转移矩阵的位置和初始矩阵的位置不可颠倒，因为矩阵不满足交换律 printf(\"%lld\\n\", res(1)); &#125; fclose(stdin); fclose(stdout); return 0;&#125; 最后说几句 这题中使用的矩阵特性就是满足结合律但是不满足交换律 因为是考试的题所以说我还是打了文件输入输出 LaTeX公式和Markdown不兼容真是见鬼了 公式打起来好麻烦 这道题是可以分块打表的 再次%表神cyr","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"递推","slug":"递推","permalink":"http://sulfur6.top/tags/递推/"},{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"http://sulfur6.top/tags/矩阵乘法/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"拯救少林神棍，POJ1011，DFS","slug":"buddhas-sticks","date":"2016-10-22T00:34:21.000Z","updated":"2016-12-27T13:35:56.000Z","comments":true,"path":"buddhas-sticks/","link":"","permalink":"http://sulfur6.top/buddhas-sticks/","excerpt":"一般的，在碰到搜索题的时候，我的反应是：woc，这也能搜索？事实证明，我还是too young. 这是一道重在剪枝的神奇DFS题。","text":"一般的，在碰到搜索题的时候，我的反应是：woc，这也能搜索？事实证明，我还是too young. 这是一道重在剪枝的神奇DFS题。 题面 据说,少林寺的镇寺之宝,是救秦王李世民的十三棍僧留下的若干根一样长的棍子。 在民国某年,少林寺被军阀炮轰,这些棍子被炸成N N N节长度各异的小木棒。 战火过后,少林方丈想要用这些木棒拼回原来的棍子。可他记不得原来到底有几根棍子了,只知道古人比较矮,且为了携带方便,棍子一定比较短。他想知道这些棍子最短可能有多短。 看到这个题面之后，我整个人都不好了qwq 题目大意 给定NNN节长度各异的小木棒，不剩余地拼成若干节长度相等的少林神棍，求神棍最短可以有多短。 解题思路枚举 可能拼成的棍子长度 长度从最长的那根木棒开始枚举到木棒总长的一半 若枚举到的长度不能整除木棒总长度，则不去搜索 搜索 搜索的过程，就是我们尝试着拼神棍的过程 如何拼完这一组神棍呢？ 一根一根的拼棍子 如果拼完第iii根棍子之后，发现第i+1i+1i+1根棍子拼不成了，那就推翻第iii根棍子的拼法 有可能一直向前推翻第一根的拼法 搜索状态 发现能搜索以后，就要确定搜索状态了 我们设状态为一个二元组(R,M)(R,M)(R,M)。 RRR表示还没有用的木棒数 MMM表示当前拼的这根棍子剩余未填满的长度 本题的初始状态和结束状态是什么？ 假设共有NNN根木棒，当前枚举到的长度为LLL。 初始状态：(N,L)(N,L)(N,L) 结束状态：(0,0)(0,0)(0,0) 开始搜索 我也不废话了，伪代码参上 Dfs的基本递推关系:bool Dfs(int R, int M) &#123; if( R == 0 &amp;&amp; M == 0) return true; //拼接任务完成 如果能找到一根长为S(S &lt;= M)的木棒,拼在当前棍子上,然后 Dfs(R – 1,M - S); 如果找不到:return false; &#125; 这里要注意的是我们首先要对长度排序，从大到小枚举 剪枝 如果按照之前的搜法，那么一定会TLE 所以，我们需要出动暴力大杀器——剪枝 剪枝1 如果在当前状态下确定了一根不能使用的木棒，那么当我们弃用它以后，当前状态下和它长度同的木棒都不再使用。 正确性显然 剪枝2 由于拼接失败，我们需要拆掉某根棍子时，如果我们一直拆解到它的第一根木棒，那么我们就不再动它，去看它的上一根棍子，如果它没有上一根棍子，则此长度不合法 如果拆掉第一根木棒，我们假设它在之后能被使用，而现在已知序列是有序的，那么如果之后某种拼法能使得当前第一根棍子被用到，那么它在之前序列一定不会被拆掉。 剪枝3 当我们需要拆解某根已经拼好的棍子时，不要拆掉最后的那根木棒反而用更小的木棒来代替。 如果这样就能拼上，那么我们用用来代替最后长木棒的几根短木棒来代替那根长木棒也能拼上。 剪枝4 如果当前需要加的木棒不是当前棍子的第一根，那么我们不能从最长的木棒往下枚举，而是从最近使用过的那根之后的一根开始向下枚举。 这样可以避免先使用长的后使用短的的情况。 代码#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int n, l; bool used[65];vector &lt;int&gt; len;int last;bool dfs (int r, int m) &#123; if (r == 0 &amp;&amp; m == 0) return true;//搜索停止，达到条件返回true，表示枚举的长度可行 if (m == 0) m = l;//如果已经拼完一根，那么就再接着往下拼 int S = 0; if (m != l) S = last + 1;//剪枝4，保证递减拼 for (int i = S; i &lt; n; i++) &#123; if (!used[i] &amp;&amp; len[i] &lt;= m) &#123; if (i &gt; 0) &#123; if (!used[i - 1] &amp;&amp; len[i] == len[i - 1]) continue;//剪枝1，保证相同长度的木棒不在同一位置多次用 &#125; used[i] = true; last = i;//标记此根为使用过，记录本次加入的木棒 if (dfs(r - 1, m - len[i])) return true; else &#123; used[i] = 0;//回溯，有可能之后还能用到这根木棒 if (len[i] == m || m == l) return false;//剪枝2，3 &#125; &#125; &#125; return false;&#125;int main () &#123; while (1) &#123; cin &gt;&gt; n; if (n == 0) break;//Blocks of datas, 读入0终止 len.clear();//每次清一遍储存长度的数组 int totallen = 0; for (int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; len.push_back(x); totallen += x; &#125; sort (len.begin(), len.end(), greater&lt;int&gt;());//从小到大排序 for (l = len[0]; l &lt;= totallen / 2; l++) &#123; if (totallen % l) continue; memset(used, 0, sizeof(used)); if (dfs(n, l)) &#123;cout &lt;&lt; l &lt;&lt; endl; break;&#125;//因为是从小到大枚举，所以验证一个答案正确就可以输出了 &#125; if (l &gt; totallen / 2) cout &lt;&lt; totallen &lt;&lt; endl; &#125; return 0;&#125; 团长在POJ和HDU上都成功拯救了少林神棍，但是原题并不叫拯救少林神棍，而是叫Sticks，很无聊的题面，某不远透露姓名的薛定谔同学竟然告诉我这是一道POJ上的中文题，害的我一阵好找。。。。","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://sulfur6.top/tags/DFS/"},{"name":"POJ","slug":"POJ","permalink":"http://sulfur6.top/tags/POJ/"},{"name":"剪枝","slug":"剪枝","permalink":"http://sulfur6.top/tags/剪枝/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]},{"title":"杨威利与莱因哈特的爱恨情仇","slug":"ywl","date":"2016-10-20T13:05:09.000Z","updated":"2016-12-27T13:35:46.000Z","comments":true,"path":"ywl/","link":"","permalink":"http://sulfur6.top/ywl/","excerpt":"蒟蒻Sulfur6在第一次看见这道题的时候感觉它好水啊，然后五分钟打了个自以为是的正解。。肯定是错的太离谱了，那天晚上的代码带崩了我的三个系统。。。 刚刚学习并查集的时候就见过那个题，当时连最水的家族都做不出，真的是连题面都没看就跳过去了。","text":"蒟蒻Sulfur6在第一次看见这道题的时候感觉它好水啊，然后五分钟打了个自以为是的正解。。肯定是错的太离谱了，那天晚上的代码带崩了我的三个系统。。。 刚刚学习并查集的时候就见过那个题，当时连最水的家族都做不出，真的是连题面都没看就跳过去了。 题目大意给定一个最多有30000艘船的船队，初始状态一字排开。 接下来你要读入 T T T 个指令 (1≤T≤5000001 \\leq T \\leq 5000001≤T≤500000)： 若为MijM i jMij，则将iii所在的舰队移动到jjj所在舰队的后面（即将第iii艘舰船所在的战舰队列全部移动到第jjj列舰船所在战舰队列的后面）； 若为CijC i jCij，如果第i,ji,ji,j艘舰船在同一列中，则输出它们中间有的舰船数，如果不在同一列中，则输出−1-1−1。 这里要注意的是（可能只有我一个人这么智障），就是给定合并操作的iji jij可能只是一列舰船中间或末尾的那个，不一定就是某列舰船的第一个。【天真的以为一定给定第一艘的蒟蒻就这么WA挺了。 压缩路径 分析完题目大意之后我们会自然而然的想到一种做法，那就是记录每一列舰船所在的位置 但是这样显然不靠谱，因为不路径压缩的UFS会爆炸。 怎么在压缩路径的基础上维护战舰所在位置的信息呢？某优化如果说大家和我一样记得并查集路径压缩的代码的话，我们会发现，在路径压缩之前并没有维护什么信息，所以我们尝试着来搞一些事情 int a[MAXN];//某列战舰现有的战舰数，初始化为1int b[MAXN];/*某列战舰现在在本列战舰内的深度，初始化为0*/int fa[MAXN];//UFS中用的father数组int find (int x) &#123; int t; if (x != fa[x]) &#123; t = find(fa[x]); b[x] += b[fa[x]];//这一句包括上面一句类似于递归求解确定x战舰在本列中的位置 fa[x] = t; &#125; return fa[x];&#125; 完整代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;const int maxn = 30000;const int maxt = 500000;int fa[maxn + 5], a[maxn + 5], b[maxn + 5];int ans;int find (int x) &#123; int t; if (x != fa[x]) &#123; t = find(fa[x]); b[x] += b[fa[x]]; fa[x] = t; &#125; return fa[x];&#125;int T;int main () &#123; scanf(\"%d\", &amp;T); for (int i = 1; i &lt;= maxn + 1; i++) &#123; fa[i] = i; a[i] = 1; &#125; char c; int x, y; while (T--) &#123; scanf(\"\\n%c %d %d\", &amp;c, &amp;x, &amp;y); int f1 = find(x); int f2 = find(y); if (c == 'M') &#123;//合并操作 fa[f1] = f2;//修改战舰头 b[f1] = a[f2];//修改战舰层数 a[f2] += a[f1];//增加合并后该列的战舰数 &#125; else &#123; if (f1 == f2) &#123; ans = abs(b[x] - b[y]) - 1;//这里要记得-1，因为编号从0开始 printf(\"%d\\n\", ans); &#125; else printf(\"-1\\n\"); &#125; &#125; return 0;&#125; 看这个难度也知道是NOI的一道水题，毕竟我这样的蒟蒻都能A。。 当年看着唐氏Pascal学并查集就死活学不会了，思想都不懂，这里要感谢教会我并查集的神犇Menci和Gty.","categories":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://sulfur6.top/tags/并查集/"},{"name":"路径压缩","slug":"路径压缩","permalink":"http://sulfur6.top/tags/路径压缩/"},{"name":"NOI","slug":"NOI","permalink":"http://sulfur6.top/tags/NOI/"}],"keywords":[{"name":"OI","slug":"OI","permalink":"http://sulfur6.top/categories/OI/"}]}]}