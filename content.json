{"meta":{"title":"Sulfur6_L8972","subtitle":"A Blog","description":null,"author":"Sulfur6","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"拯救少林神棍，POJ1011，DFS","slug":"拯救少林神棍，POJ1011，DFS","date":"2016-10-22T00:34:21.000Z","updated":"2016-10-22T00:37:41.000Z","comments":true,"path":"2016/10/22/拯救少林神棍，POJ1011，DFS/","link":"","permalink":"http://yoursite.com/2016/10/22/拯救少林神棍，POJ1011，DFS/","excerpt":"","text":"一般的，在碰到搜索题的时候，我的反应是：woc，这也能搜索？事实证明，我还是too young. 题面 据说,少林寺的镇寺之宝,是救秦王李世民的十三棍僧留下的若干根一样长的棍子。 在民国某年,少林寺被军阀炮轰,这些棍子被炸成$ N $节长度各异的小木棒。 战火过后,少林方丈想要用这些木棒拼回原来的棍子。可他记不得原来到底有几根棍子了,只知道古人比较矮,且为了携带方便,棍子一定比较短。他想知道这些棍子最短可能有多短。 看到这个题面之后，我整个人都不好了qwq 题目大意 给定$N$节长度各异的小木棒，不剩余地拼成若干节长度相等的少林神棍，求神棍最短可以有多短。 解题思路枚举 可能拼成的棍子长度 长度从最长的那根木棒开始枚举到木棒总长的一半 若枚举到的长度不能整除木棒总长度，则不去搜索 搜索 搜索的过程，就是我们尝试着拼神棍的过程 如何拼完这一组神棍呢？ 一根一根的拼棍子 如果拼完第$i$根棍子之后，发现第$i+1$根棍子拼不成了，那就推翻第$i$根棍子的拼法 有可能一直向前推翻第一根的拼法 搜索状态 发现能搜索以后，就要确定搜索状态了 我们设状态为一个二元组$(R,M)$。 $R$表示还没有用的木棒数 $M$表示当前拼的这根棍子剩余未填满的长度 本题的初始状态和结束状态是什么？ 假设共有$N$根木棒，当前枚举到的长度为$L$。 初始状态：$(N,L)$ 结束状态：$(0,0)$ 开始搜索 我也不废话了，伪代码参上 1234Dfs的基本递推关系:bool Dfs(int R, int M) &#123; if( R == 0 &amp;&amp; M == 0) return true; //拼接任务完成 如果能找到一根长为S(S &lt;= M)的木棒,拼在当前棍子上,然后 Dfs(R – 1,M - S); 如果找不到:return false; &#125; 这里要注意的是我们首先要对长度排序，从大到小枚举 剪枝 如果按照之前的搜法，那么一定会TLE 所以，我们需要出动暴力大杀器——剪枝 剪枝1 如果在当前状态下确定了一根不能使用的木棒，那么当我们弃用它以后，当前状态下和它长度同的木棒都不再使用。 正确性显然 剪枝2 由于拼接失败，我们需要拆掉某根棍子时，如果我们一直拆解到它的第一根木棒，那么我们就不再动它，去看它的上一根棍子，如果它没有上一根棍子，则此长度不合法 如果拆掉第一根木棒，我们假设它在之后能被使用，而现在已知序列是有序的，那么如果之后某种拼法能使得当前第一根棍子被用到，那么它在之前序列一定不会被拆掉。 剪枝3 当我们需要拆解某根已经拼好的棍子时，不要拆掉最后的那根木棒反而用更小的木棒来代替。 如果这样就能拼上，那么我们用用来代替最后长木棒的几根短木棒来代替那根长木棒也能拼上。 剪枝4 如果当前需要加的木棒不是当前棍子的第一根，那么我们不能从最长的木棒往下枚举，而是从最近使用过的那根之后的一根开始向下枚举。 这样可以避免先使用长的后使用短的的情况。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int n, l; bool used[65];vector &lt;int&gt; len;int last;bool dfs (int r, int m) &#123; if (r == 0 &amp;&amp; m == 0) return true;//搜索停止，达到条件返回true，表示枚举的长度可行 if (m == 0) m = l;//如果已经拼完一根，那么就再接着往下拼 int S = 0; if (m != l) S = last + 1;//剪枝4，保证递减拼 for (int i = S; i &lt; n; i++) &#123; if (!used[i] &amp;&amp; len[i] &lt;= m) &#123; if (i &gt; 0) &#123; if (!used[i - 1] &amp;&amp; len[i] == len[i - 1]) continue;//剪枝1，保证相同长度的木棒不在同一位置多次用 &#125; used[i] = true; last = i;//标记此根为使用过，记录本次加入的木棒 if (dfs(r - 1, m - len[i])) return true; else &#123; used[i] = 0;//回溯，有可能之后还能用到这根木棒 if (len[i] == m || m == l) return false;//剪枝2，3 &#125; &#125; &#125; return false;&#125;int main () &#123; while (1) &#123; cin &gt;&gt; n; if (n == 0) break;//Blocks of datas, 读入0终止 len.clear();//每次清一遍储存长度的数组 int totallen = 0; for (int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; len.push_back(x); totallen += x; &#125; sort (len.begin(), len.end(), greater&lt;int&gt;());//从小到大排序 for (l = len[0]; l &lt;= totallen / 2; l++) &#123; if (totallen % l) continue; memset(used, 0, sizeof(used)); if (dfs(n, l)) &#123;cout &lt;&lt; l &lt;&lt; endl; break;&#125;//因为是从小到大枚举，所以验证一个答案正确就可以输出了 &#125; if (l &gt; totallen / 2) cout &lt;&lt; totallen &lt;&lt; endl; &#125; return 0;&#125; 团长在POJ和HDU上都成功拯救了少林神棍，但是原题并不叫拯救少林神棍，而是叫Sticks，很无聊的题面，某不远透露姓名的薛定谔同学竟然告诉我这是一道POJ上的中文题，害的我一阵好找。。。。","categories":[],"tags":[],"keywords":[]},{"title":"杨威利与莱因哈特的爱恨情仇","slug":"ywl","date":"2016-10-20T13:05:09.000Z","updated":"2016-10-21T13:34:05.000Z","comments":true,"path":"2016/10/20/ywl/","link":"","permalink":"http://yoursite.com/2016/10/20/ywl/","excerpt":"","text":"蒟蒻Sulfur6在第一次看见这道题的时候感觉它好水啊，然后五分钟打了个自以为是的正解。。肯定是错的太离谱了，那天晚上的代码带崩了我的三个系统。。。 题目大意给定一个最多有30000艘船的船队，初始状态一字排开。接下来你要读入 $ T $ 个指令 ($1 \\leq T \\leq 500000$)：若为$M i j$，则将$i$所在的舰队移动到$j$所在舰队的后面（即将第$i$艘舰船所在的战舰队列全部移动到第$j$列舰船所在战舰队列的后面）；若为$C i j$，如果第$i,j$艘舰船在同一列中，则输出它们中间有的舰船数，如果不在同一列中，则输出$-1$。 这里要注意的是（可能只有我一个人这么智障），就是给定合并操作的$i j$可能只是一列舰船中间或末尾的那个，不一定就是某列舰船的第一个。【天真的以为一定给定第一艘的蒟蒻就这么WA挺了。 压缩路径 分析完题目大意之后我们会自然而然的想到一种做法，那就是记录每一列舰船所在的位置 但是这样显然不靠谱，因为不路径压缩的UFS会爆炸。 怎么在压缩路径的基础上维护战舰所在位置的信息呢？某优化如果说大家和我一样记得并查集路径压缩的代码的话，我们会发现，在路径压缩之前并没有维护什么信息，所以我们尝试着来搞一些事情 12345678910111213int a[MAXN];//某列战舰现有的战舰数，初始化为1int b[MAXN];/*某列战舰现在在本列战舰内的深度，初始化为0*/int fa[MAXN];//UFS中用的father数组int find (int x) &#123; int t; if (x != fa[x]) &#123; t = find(fa[x]); b[x] += b[fa[x]];//这一句包括上面一句类似于递归求解确定x战舰在本列中的位置 fa[x] = t; &#125; return fa[x];&#125; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;const int maxn = 30000;const int maxt = 500000;int fa[maxn + 5], a[maxn + 5], b[maxn + 5];int ans;int find (int x) &#123; int t; if (x != fa[x]) &#123; t = find(fa[x]); b[x] += b[fa[x]]; fa[x] = t; &#125; return fa[x];&#125;int T;int main () &#123; scanf(\"%d\", &amp;T); for (int i = 1; i &lt;= maxn + 1; i++) &#123; fa[i] = i; a[i] = 1; &#125; char c; int x, y; while (T--) &#123; scanf(\"\\n%c %d %d\", &amp;c, &amp;x, &amp;y); int f1 = find(x); int f2 = find(y); if (c == 'M') &#123;//合并操作 fa[f1] = f2;//修改战舰头 b[f1] = a[f2];//修改战舰层数 a[f2] += a[f1];//增加合并后该列的战舰数 &#125; else &#123; if (f1 == f2) &#123; ans = abs(b[x] - b[y]) - 1;//这里要记得-1，因为编号从0开始 printf(\"%d\\n\", ans); &#125; else printf(\"-1\\n\"); &#125; &#125; return 0;&#125; 看这个难度也知道是NOI的一道水题，毕竟我这样的蒟蒻都能A。。当年看着唐氏Pascal学并查集就死活学不会了，思想都不懂，这里要感谢教会我并查集的神犇Menci和Gty.","categories":[],"tags":[],"keywords":[]}]}