<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I Have Just Killed Myself</title>
  <subtitle>但行好事，莫问前程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sulfur6.github.io/"/>
  <updated>2017-11-14T12:57:04.000Z</updated>
  <id>http://sulfur6.github.io/</id>
  
  <author>
    <name>Sulfur6</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写在NOIP2017之后</title>
    <link href="http://sulfur6.github.io/after-NOIP2017/"/>
    <id>http://sulfur6.github.io/after-NOIP2017/</id>
    <published>2017-11-14T12:45:12.000Z</published>
    <updated>2017-11-14T12:57:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>并没有想象中的悔恨和不甘，也没有理应出现的愤怒与疯狂，我站在楼梯上，只是被深深的绝望包围。</p>
<a id="more"></a>
<p>其实仔细想想，得到这么差的成绩也在情理之中。考场上的我一次又一次的心态爆炸，编译原理、临接表、BFS、Treap……一个接一个的写错，应该得到的分全都没有得到，和SDOI Round1，和NOIP2016，全都一样。</p>
<p>我已经不是去年NOIP结束以后就跟教练说「不管怎样我都要参加省选」的热血青年了，去年的我在NOIP失利后马上投入省选的准备，因为我知道我还有一次翻盘的机会，因为我在未来看到了淡淡希望的曙光。</p>
<p>然而现在一切都没了。</p>
<p>哪怕省选失利了，我还可以告诉自己，我还有今年的NOIP，但是现在我还有什么呢？只剩下无穷无尽补不完的文化了吧。可能我真的找不到方向了，两年OI，我成功的与每一次机会失之交臂，我不知道我现如今的状态还能做的好什么。</p>
<p>我已经是个废人了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并没有想象中的悔恨和不甘，也没有理应出现的愤怒与疯狂，我站在楼梯上，只是被深深的绝望包围。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://sulfur6.github.io/categories/Life/"/>
    
    
      <category term="Diary" scheme="http://sulfur6.github.io/tags/Diary/"/>
    
  </entry>
  
  <entry>
    <title>「JSOI2008」生日聚会 - DP</title>
    <link href="http://sulfur6.github.io/bzoj-1037/"/>
    <id>http://sulfur6.github.io/bzoj-1037/</id>
    <published>2017-11-06T08:06:52.000Z</published>
    <updated>2017-11-06T08:28:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>现有 $ n $ 个男生 $ m $ 个女生要坐成一排，需要满足对于任意连续的一段，不存在男女数量之差大于 $ k $ 的情况，其中 $ n, m, k $ 由输入数据给定。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>蛮好的一道DP。可惜我上午做的时候智商不在线。<br>当时没有仔细考虑「任意连续的区间」，这个限制，导致设出了一个奇怪的状态。</p>
<p>一个自然而然的思路就是从左往右确定方案数，如果我们纪录目前已经有 $ i $ 个男生，$ j $ 个女生的方案数，那么转移的话就是看下一个位置坐男生还是坐女生。</p>
<p>但是这个状态不保证满足题目中的限制，而且由于转移分选男生与选女生，所以应分别记录已经确定的区间当中，男生数目减去女生数目的最大值，以及女生数目减去男生数目的最大值。又由于DP的顺序，只需要记录后缀最大值即可。</p>
<p>公式爆炸，具体看代码就好。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">160</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">30</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">12345678</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, m, k;</div><div class="line"><span class="keyword">int</span> f[MAXN][MAXN][MAXK][MAXK];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;k);</div><div class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="built_in">std</span>::min(i, k); a++) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="built_in">std</span>::min(j, k); b++) &#123;</div><div class="line">                    <span class="keyword">if</span> (i &lt; n &amp;&amp; a &lt; k) &#123;</div><div class="line">                        f[i + <span class="number">1</span>][j][a + <span class="number">1</span>][<span class="built_in">std</span>::max(b - <span class="number">1</span>, <span class="number">0</span>)] += f[i][j][a][b];</div><div class="line">                        f[i + <span class="number">1</span>][j][a + <span class="number">1</span>][<span class="built_in">std</span>::max(b - <span class="number">1</span>, <span class="number">0</span>)] %= MOD;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (j &lt; m &amp;&amp; b &lt; k) &#123;</div><div class="line">                        f[i][j + <span class="number">1</span>][<span class="built_in">std</span>::max(a - <span class="number">1</span>, <span class="number">0</span>)][b + <span class="number">1</span>] += f[i][j][a][b];</div><div class="line">                        f[i][j + <span class="number">1</span>][<span class="built_in">std</span>::max(a - <span class="number">1</span>, <span class="number">0</span>)][b + <span class="number">1</span>] %= MOD;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= k; a++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= k; b++) &#123;</div><div class="line">            ans += f[n][m][a][b];</div><div class="line">            ans %= MOD;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现有 $ n $ 个男生 $ m $ 个女生要坐成一排，需要满足对于任意连续的一段，不存在男女数量之差大于 $ k $ 的情况，其中 $ n, m, k $ 由输入数据给定。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://sulfur6.github.io/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>「JSOI2007」字符加密 - 后缀数组</title>
    <link href="http://sulfur6.github.io/bzoj-1031/"/>
    <id>http://sulfur6.github.io/bzoj-1031/</id>
    <published>2017-07-25T11:44:08.000Z</published>
    <updated>2017-11-06T06:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符环，对每个在环上顺时针走一圈可以得到的字符串排序。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>把环断开然后复制一遍，这样能走到的 $ n $ 个字符串相当于从前 $ n $ 个字符向后走 $ n $ 步所得到的字符串，现在要对这些东西排序嘛，就直接用后缀数组对后缀排序就好啦，因为那些起点在后 $ n $ 个字符的后缀对答案没有影响，他们在哪里都无所谓，而所有合法的串后面添上一段字符也不会影响他们的相对位置。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e5</span> * <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">int</span> sa[MAX_N + <span class="number">1</span>], rank[MAX_N + <span class="number">1</span>];</div><div class="line"><span class="keyword">char</span> s[MAX_N + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">suffixArray</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> <span class="built_in">set</span>[MAX_N + <span class="number">1</span>], a[MAX_N + <span class="number">1</span>];</div><div class="line">    <span class="built_in">std</span>::copy(s + <span class="number">1</span>, s + n + <span class="number">1</span>, <span class="built_in">set</span> + <span class="number">1</span>);</div><div class="line">    <span class="built_in">std</span>::sort(<span class="built_in">set</span> + <span class="number">1</span>, <span class="built_in">set</span> + n + <span class="number">1</span>);</div><div class="line">    <span class="keyword">int</span> *end = <span class="built_in">std</span>::unique(<span class="built_in">set</span> + <span class="number">1</span>, <span class="built_in">set</span> + n + <span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = <span class="built_in">std</span>::lower_bound(<span class="built_in">set</span> + <span class="number">1</span>, end, s[i]) - <span class="built_in">set</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> fir[MAX_N + <span class="number">1</span>], sec[MAX_N + <span class="number">1</span>], tmp[MAX_N + <span class="number">1</span>], buc[MAX_N + <span class="number">1</span>];</div><div class="line">    <span class="built_in">std</span>::fill(buc, buc + n + <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) buc[a[i]]++;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) buc[i] += buc[i - <span class="number">1</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) rank[i] = buc[a[i] - <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= n; t *= <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fir[i] = rank[i];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sec[i] = i + t &gt; n ? <span class="number">0</span> : rank[i + t];</div><div class="line"></div><div class="line">        <span class="built_in">std</span>::fill(buc, buc + n + <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) buc[sec[i]]++;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) buc[i] += buc[i - <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tmp[n - --buc[sec[i]]] = i;</div><div class="line"></div><div class="line">        <span class="built_in">std</span>::fill(buc, buc + n + <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) buc[fir[i]]++;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) buc[i] += buc[i - <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, i; j &lt;= n; j++) i = tmp[j], sa[buc[fir[i]]--] = i;</div><div class="line"></div><div class="line">        <span class="keyword">bool</span> unique = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, i, last = <span class="number">0</span>; j &lt;= n; j++) &#123;</div><div class="line">            i = sa[j];</div><div class="line">            <span class="keyword">if</span> (!last) rank[i] = <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (fir[i] == fir[last] &amp;&amp; sec[i] == sec[last]) rank[i] = rank[last], unique = <span class="literal">false</span>;</div><div class="line">            <span class="keyword">else</span> rank[i] = rank[last] + <span class="number">1</span>;</div><div class="line"></div><div class="line">            last = i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (unique) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</div><div class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[n + i] = s[i];</div><div class="line">    n *= <span class="number">2</span>;</div><div class="line"></div><div class="line">    suffixArray();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (sa[i] &lt;= n / <span class="number">2</span>) <span class="built_in">putchar</span>(s[sa[i] + n / <span class="number">2</span> - <span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符环，对每个在环上顺时针走一圈可以得到的字符串排序。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="后缀数组" scheme="http://sulfur6.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>「JSOI2007」文本生成器 - AC自动机，DP</title>
    <link href="http://sulfur6.github.io/bzoj-1030/"/>
    <id>http://sulfur6.github.io/bzoj-1030/</id>
    <published>2017-07-14T07:52:22.000Z</published>
    <updated>2017-07-25T11:40:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定属于字符集 $ A .. Z $ 的若干字符串，求随机生成的所有长度为 $ m $ 的字符串中，给定的某些字符串是生成字符串的子串的数量。</p>
<a id="more"></a>
<p>哎呀团长本来是想把辣鸡题面翻译的简洁易懂的但是感觉越翻译越不可读。。讲真我语文老师人很棒而且活的好好的只是我不听话。。</p>
<p>这个题乍一看和<a href="https://sulfur6.github.io/bzoj1009/">「BZOJ1009」</a>蛮像的，只是把一个串改成了多个串，那么相应的我们就把KMP换成AC自动机就好了嘛。</p>
<p>而且和上述题目不同的是，这个题并不需要用矩阵乘法23333333333333333333333.</p>
<p>好像代码说的比我 xjb bb 来的好得多。。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> BASE = <span class="string">'A'</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">26</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">60</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">100</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">10007</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> AC_Automaton &#123;</div><div class="line">    <span class="keyword">struct</span> Node &#123;</div><div class="line">        <span class="keyword">int</span> id;</div><div class="line">        Node *c[SIZE], *fail, *next;</div><div class="line">        <span class="keyword">bool</span> isWord;</div><div class="line"></div><div class="line">        Node(<span class="keyword">bool</span> isWord = <span class="literal">false</span>) : c(), fail(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>), isWord(isWord) &#123;&#125;</div><div class="line">    &#125; *root;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *begin, <span class="keyword">const</span> <span class="keyword">char</span> *end)</span> </span>&#123;</div><div class="line">        Node **v = &amp;root;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> *p = begin; p != end; p++) &#123;</div><div class="line">            <span class="keyword">if</span> (!*v) *v = <span class="keyword">new</span> Node(<span class="literal">false</span>);</div><div class="line">            v = &amp;(*v)-&gt;c[*p];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!*v) *v = <span class="keyword">new</span> Node(<span class="literal">true</span>);</div><div class="line">        <span class="keyword">else</span> (*v)-&gt;isWord = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node *&gt; q;</div><div class="line">        root-&gt;fail = root, root-&gt;next = <span class="literal">NULL</span>;</div><div class="line">        q.push(root);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</div><div class="line">            Node *v = q.front();</div><div class="line">            q.pop();</div><div class="line"></div><div class="line">            v-&gt;isWord |= v-&gt;fail-&gt;isWord;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</div><div class="line">                Node *&amp;c = v-&gt;c[i];</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!c) &#123;</div><div class="line">                    c = v == root ? root : v-&gt;fail-&gt;c[i];</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                Node *u = v-&gt;fail;</div><div class="line">                c-&gt;fail = v != root &amp;&amp; u-&gt;c[i] ? u-&gt;c[i] : root;</div><div class="line"><span class="comment">//				c-&gt;next = c-&gt;fail-&gt;isWord ? c-&gt;fail : c-&gt;fail-&gt;next;</span></div><div class="line"></div><div class="line">                q.push(c);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNodeList</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node *&gt; &amp;vec)</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node *&gt; q;</div><div class="line">        q.push(root);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</div><div class="line">            Node *v = q.front();</div><div class="line">            q.pop();</div><div class="line"></div><div class="line">            vec.push_back(v);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) <span class="keyword">if</span> (v-&gt;c[i]) q.push(v-&gt;c[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125; ac;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, a = (<span class="keyword">long</span> <span class="keyword">long</span>)a * a % MOD) <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = (<span class="keyword">long</span> <span class="keyword">long</span>)res * a % MOD;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> f[MAX_M + <span class="number">1</span>][MAX_N * MAX_M + <span class="number">100</span>];</div><div class="line"><span class="keyword">char</span> s[MAX_M];</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;AC_Automaton::Node *&gt; nodes;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n, m;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</div><div class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) s[j] -= BASE;</div><div class="line">        ac.insert(s, s + len);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ac.getNodeList(nodes);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DBG</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"size of the node list : %d\n"</span>, nodes.size());</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    ac.build();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); i++) nodes[i]-&gt;id = i;</div><div class="line"></div><div class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</div><div class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nodes.size(); j++) &#123;</div><div class="line">            <span class="keyword">if</span> (!nodes[j]-&gt;isWord &amp;&amp; f[i - <span class="number">1</span>][j] &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; SIZE; k++) &#123;</div><div class="line">                    f[i][nodes[j]-&gt;c[k]-&gt;id] = (f[i][nodes[j]-&gt;c[k]-&gt;id] + f[i - <span class="number">1</span>][j]) % MOD;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!nodes[i]-&gt;isWord) (ans += f[m][i]) %= MOD;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ((<span class="built_in">pow</span>(<span class="number">26</span>, m) - ans) % MOD + MOD) % MOD);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定属于字符集 $ A .. Z $ 的若干字符串，求随机生成的所有长度为 $ m $ 的字符串中，给定的某些字符串是生成字符串的子串的数量。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://sulfur6.github.io/tags/DP/"/>
    
      <category term="AC自动机" scheme="http://sulfur6.github.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>「JSOI2007」建筑抢修 - 贪心，堆</title>
    <link href="http://sulfur6.github.io/bzoj-1029/"/>
    <id>http://sulfur6.github.io/bzoj-1029/</id>
    <published>2017-07-14T07:27:03.000Z</published>
    <updated>2017-07-25T11:10:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>小刚在玩JSOI提供的一个称之为“建筑抢修”的电脑游戏：经过了一场激烈的战斗，T部落消灭了所有Z部落的入侵者。但是T部落的基地里已经有 $ N $ 个建筑设施受到了严重的损伤，如果不尽快修复的话，这些建筑设施将会完全毁坏。现在的情况是：T部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>设修复第 $ i $ 个建筑的时间为 $ a_i $，然后它的 deadline 为 $ b_i $。</p>
<p>一个很显然（但是我没有想到）的贪心思路是对 $ b $ 排序，然后先修理 $ b $ 小的建筑，因为 $ b $ 大的建筑可以拖更长时间，但是 $ b $ 小的建筑 $ a $ 可能很大，这样选择之后或许会导致决策不优。</p>
<p>所以接下来请出正解君 qwq。。</p>
<p>按照上面的思路进行贪心，但是我们维护一个大根堆，堆里维护的是我们要修的建筑的 $ a $ 的值，如果修着修着发现时间不够了，把当前枚举到的建筑的 $ a $ 值和堆顶进行比较，如果当前的 $ a $ 值小于堆顶，就不再修堆顶，改修当前建筑。</p>
<p>这种贪心策略其实就是舍弃耗时大的项目，给后续项目匀时间。</p>
<p>果然团长的贪心还是弱啊。。我好弱啊。。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">150000</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Building &#123;</div><div class="line">    <span class="keyword">int</span> a, b;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Building &amp;other) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">return</span> b &lt; other.b;</div><div class="line">    &#125;</div><div class="line">&#125; buildings[MAX_N + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>&gt; q;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;buildings[i].a, &amp;buildings[i].b);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::sort(buildings + <span class="number">1</span>, buildings + n + <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, now = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (now + buildings[i].a &lt;= buildings[i].b) &#123;</div><div class="line">            now += buildings[i].a;</div><div class="line">            ans++;</div><div class="line">            q.push(buildings[i].a);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (q.empty()) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">int</span> top = q.top();</div><div class="line">            <span class="keyword">if</span> (top &gt; buildings[i].a) &#123;</div><div class="line">                q.pop();</div><div class="line">                q.push(buildings[i].a);</div><div class="line">                now = now - top + buildings[i].a;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小刚在玩JSOI提供的一个称之为“建筑抢修”的电脑游戏：经过了一场激烈的战斗，T部落消灭了所有Z部落的入侵者。但是T部落的基地里已经有 $ N $ 个建筑设施受到了严重的损伤，如果不尽快修复的话，这些建筑设施将会完全毁坏。现在的情况是：T部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="贪心" scheme="http://sulfur6.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="堆" scheme="http://sulfur6.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>「JSOI2007」麻将</title>
    <link href="http://sulfur6.github.io/bzoj-1028/"/>
    <id>http://sulfur6.github.io/bzoj-1028/</id>
    <published>2017-07-07T00:54:30.000Z</published>
    <updated>2017-07-07T07:13:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>麻将是中国传统的娱乐工具之一。麻将牌的牌可以分为字牌（共有东、南、西、北、中、发、白七种）和序数牌（分为条子、饼子、万子三种花色，每种花色各有一到九的九种牌），每种牌各四张。在麻将中，通常情况下一组和了的牌（即完成的牌）由十四张牌组成。十四张牌中的两张组成对子（即完全相同的两张牌），剩余的十二张组成三张一组的四组，每一组须为顺子（即同花色且序数相连的序数牌，例如条子的三、四、五）或者是刻子（即完全相同的三张牌）。一组听牌的牌是指一组十三张牌，且再加上某一张牌就可以组成和牌。那一张加上的牌可以称为等待牌。在这里，我们考虑一种特殊的麻将。在这种特殊的麻将里，没有字牌，花色也只有一种。但是，序数不被限制在一到九的范围内，而是在 $ 1 $ 到 $ n $ 的范围内。同时，也没有每一种牌四张的限制。一组和了的牌由 $ 3m + 2 $ 张牌组成，其中两张组成对子，其余 $ 3m $ 张组成三张一组的 $ m $ 组，每组须为顺子或刻子。现给出一组 $ 3m + 1 $ 张的牌，要求判断该组牌是否为听牌（即还差一张就可以和牌）。如果是的话，输出所有可能的等待牌。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一开始的时候我考虑暴搜和DP，但是没想到DP该怎么设计状态（这么乱的状态不好用DP表示啊），也考虑了暴搜，但是看看数据范围十分不靠谱，没想到是暴力 + 贪心。</p>
<p>看看数据范围，发现 $ n $ 很小，考虑枚举序数 $ i $ 作为等待牌，然后暴力判断 $ i $ 作为等待牌是否可行。</p>
<p>在判断的时候，从 $ 1 $ 枚举到 $ n $ 枚举，首先考虑枚举到的序数作为刻子，剩下的同后两位连成顺子。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">400</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">1000</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, m;</div><div class="line"><span class="keyword">int</span> s[MAX_N + <span class="number">1</span>], f[MAX_N + <span class="number">1</span>];</div><div class="line"><span class="keyword">int</span> ans[MAX_N + <span class="number">1</span>], cnt;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="number">2</span>) &#123;</div><div class="line">            s[i] -= <span class="number">2</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">2</span>; j++) f[j] = s[j];</div><div class="line"></div><div class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">2</span>; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (f[j] &lt; <span class="number">0</span>) &#123;</div><div class="line">                    flag = <span class="literal">false</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                f[j] %= <span class="number">3</span>;</div><div class="line">                f[j + <span class="number">1</span>] -= f[j], f[j + <span class="number">2</span>] -= f[j];</div><div class="line">            &#125;</div><div class="line">            s[i] += <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * <span class="number">3</span> + <span class="number">1</span>; i++) &#123;</div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</div><div class="line">        s[x]++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        s[i]++;</div><div class="line">        <span class="keyword">if</span> (judge()) ans[cnt++] = i, flag = <span class="literal">true</span>;</div><div class="line">        s[i]--;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (flag) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</div><div class="line">        <span class="keyword">if</span> (i != cnt - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;麻将是中国传统的娱乐工具之一。麻将牌的牌可以分为字牌（共有东、南、西、北、中、发、白七种）和序数牌（分为条子、饼子、万子三种花色，每种花色各有一到九的九种牌），每种牌各四张。在麻将中，通常情况下一组和了的牌（即完成的牌）由十四张牌组成。十四张牌中的两张组成对子（即完全相同的两张牌），剩余的十二张组成三张一组的四组，每一组须为顺子（即同花色且序数相连的序数牌，例如条子的三、四、五）或者是刻子（即完全相同的三张牌）。一组听牌的牌是指一组十三张牌，且再加上某一张牌就可以组成和牌。那一张加上的牌可以称为等待牌。在这里，我们考虑一种特殊的麻将。在这种特殊的麻将里，没有字牌，花色也只有一种。但是，序数不被限制在一到九的范围内，而是在 $ 1 $ 到 $ n $ 的范围内。同时，也没有每一种牌四张的限制。一组和了的牌由 $ 3m + 2 $ 张牌组成，其中两张组成对子，其余 $ 3m $ 张组成三张一组的 $ m $ 组，每组须为顺子或刻子。现给出一组 $ 3m + 1 $ 张的牌，要求判断该组牌是否为听牌（即还差一张就可以和牌）。如果是的话，输出所有可能的等待牌。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="贪心" scheme="http://sulfur6.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="暴力" scheme="http://sulfur6.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>「JSOI2007」合金 - 计算几何，Floyd</title>
    <link href="http://sulfur6.github.io/bzoj-1027/"/>
    <id>http://sulfur6.github.io/bzoj-1027/</id>
    <published>2017-07-05T00:47:58.000Z</published>
    <updated>2017-07-05T07:02:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 现在，用户给出了 $ n $ 种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>像我这种菜鸡看了题目描述就开始往网络流和DP上去考虑。。结果发现好像网络流很难这样做，然后DP我死活设计不出状态，打开题解以后发现这题原来是十分巧妙的计算几何。。</p>
<p>首先，由于 $ a + b + c = 1 $，所以我们只需要知道其中两个值就可以，并不需要准确了解第三个值，体现在算法中就是只记录 $ a, b $。这样我们就可以把一种材料或者合金抽象成一个平面上的点，每个点的坐标为 $ (a, b) $。</p>
<p>对于两个点 $ (x_1, y_1), (x_2, y_2) $ 所代表的原料，他们能够合成的合金一定在这两点之间的线段上，其坐标为 $ (ax_1 + bx_2, ay_1 + by_2) $，其中 $ a + b = 1 $。</p>
<p>而对于三个点即以上代表的原料，他们能够合成的合金一定在这些点的凸包上。</p>
<p>记代表原料的点集为 $ A $，代表合金的点集 $ B $，问题实际上就是求出 $ A $ 的一个子集，使得其中点的凸包能够完全覆盖 $ B $ 中的所有点。</p>
<p>讲实话这个东西我不会求。。我不知道用传统的方法该怎么做，所以就学了人家巧妙的转化成最短路的方法。</p>
<p>首先，我们 $ O(n ^ 2) $ 枚举 $ A $ 中的两个点 $ N, M $，对于 $ \overrightarrow{NM} $，如果 $ B $ 中所有点都在 $ \overrightarrow{NM} $ 的同侧（左侧或右侧，按下文判断方法应该是右侧顺时针）或是在 $ \overrightarrow{NM} $ 上，则连接一条 $ N \rightarrow M $ 的边。</p>
<p>判断方法如下：<br>对于枚举到的点 $ N, M $，枚举 $ B $ 中的点 $ K $，若所有 $ K $ 满足<br>$$<br>(\overrightarrow{KN} \times \overrightarrow{KM} &gt; 0) \vee ((\overrightarrow{KN} \times \overrightarrow{KM} \leq 0) \wedge (\overrightarrow{KN} \cdot \overrightarrow{KM} = 0 ))<br>$$</p>
<p>则连接一条 $ N \rightarrow M $ 的边，最后用 Floyd 求最小环即可。</p>
<p>注：程序中的 $ K $ 为小写，$ N, M $ 分别为 $ i, j $，这里是为了表述美观而更改。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfloat&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">500</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">500</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-7</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Point &#123;</div><div class="line">    <span class="keyword">double</span> x, y;</div><div class="line"></div><div class="line">    Point() &#123;&#125;</div><div class="line">    Point(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : x(x), y(y) &#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">friend</span> <span class="keyword">inline</span> Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b) &#123;</div><div class="line">        <span class="keyword">return</span> Point(a.x - b.x, a.y - b.y);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">double</span> <span class="keyword">operator</span>*(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b) &#123;</div><div class="line">        <span class="keyword">return</span> a.x * b.y - a.y * b.x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a.x * b.x + a.y * b.y;</div><div class="line">    &#125;</div><div class="line">&#125; a[MAX_M + <span class="number">1</span>], b[MAX_N + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="keyword">int</span> m, n, <span class="built_in">map</span>[MAX_N + <span class="number">1</span>][MAX_N + <span class="number">1</span>], f[MAX_N + <span class="number">1</span>][MAX_N + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> res = INF;</div><div class="line">    <span class="built_in">memcpy</span>(f, <span class="built_in">map</span>, <span class="keyword">sizeof</span>(f));</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; k++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (f[i][k] &lt; INF) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</div><div class="line">                    f[i][j] = <span class="built_in">std</span>::min(f[i][j], f[i][k] + f[k][j]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) res = <span class="built_in">std</span>::min(res, f[i][i]);</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">memset</span>(<span class="built_in">map</span>, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(<span class="built_in">map</span>));</div><div class="line"></div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%lf%lf%*lf"</span>, &amp;a[i].x, &amp;a[i].y);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lf%lf%*lf"</span>, &amp;b[i].x, &amp;b[i].y);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123; </div><div class="line">            <span class="keyword">int</span> k;</div><div class="line">            <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k++) &#123;</div><div class="line">                <span class="keyword">double</span> det = (a[i] - b[k]) * (a[j] - b[k]);</div><div class="line">                <span class="keyword">if</span> (det &gt; EPS) <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(det) &lt; EPS &amp;&amp; dot(a[i] - b[k], a[j] - b[k]) &gt; EPS) <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (k == n + <span class="number">1</span>) <span class="built_in">map</span>[i][j] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">int</span> ans = floyd();</div><div class="line">    <span class="keyword">if</span> (ans == INF) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</div><div class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 现在，用户给出了 $ n $ 种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="Floyd" scheme="http://sulfur6.github.io/tags/Floyd/"/>
    
      <category term="计算几何" scheme="http://sulfur6.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>「SCOI2009」游戏 - DP，线性筛，置换</title>
    <link href="http://sulfur6.github.io/bzoj-1025/"/>
    <id>http://sulfur6.github.io/bzoj-1025/</id>
    <published>2017-07-04T06:48:54.000Z</published>
    <updated>2017-07-05T09:35:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个长度为 $ n $ 的序列 $ A $，记其置换集合为 $ G $，对于 $ f \in G $，记使得 $ f(f(f (\dots (f(A)))) = A $ 的嵌套次数为其排数，求对于所有 $ f \in<br>G $ 共有多少种不同的排数。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>将置换改写成轮换，一个很显然的结论是：对于一个置换，所求排数为改写成轮换后所有环的点数的最小公倍数 + $ 1 $。</p>
<p>所以问题变为，把 $ n $ 分成 $ k $ 个数 $ a_1, a_2, \dots, a_k $ 满足 $ \sum a_i = n $，求 $ \text{lcm}(a_i) $ 的不同取值个数。</p>
<p>首先要说明一个性质，就是若干个数的最小公倍数一定可以改写成若干个素数的幂的最小公倍数。</p>
<p>以两个数的情况为例：设 $ k_1 = a_1 ^ {p_1} a_2 ^ {p_2} a_3 ^ {p_3} $，$ k_2 = a_1 ^ {p_4} a_2 ^ {p_5} a_3 ^ {p_6} $，并且 $ p_1 &gt; p_4, p_2 &lt; p_5, p_3 &gt; p_6 $，那么 $ \text{lcm}(k_1, k_2) = a_1 ^ {p_1} a_2 ^ {p_5} a_3 ^ {p_3} = \text{lcm}(a_1 ^ {p_1}, a_2 ^ {p_5}, a_3 ^ {p_3}) $。</p>
<p>当然这个证明不是很严谨啦我也知道不要喷我啦。。这不算是证明只是个说明啦。。其他情况和这种情况也都差不多，所以我们知道，只考虑素数的幂就可以取得所有的不同取值。</p>
<p>考虑DP，以使用不同的素数为阶段，可以满足无后效性，设 $ f(i, j) $ 表示目前使用了前 $ i $ 个素数，这些素数的幂的和为 $ j $ 时的不同最小公倍数个数，用类似背包的形式转移，具体转移见代码。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1000</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_CNT = <span class="number">168</span>;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> isNotPrime[MAX_N + <span class="number">1</span>];</div><div class="line"><span class="keyword">int</span> primes[MAX_N + <span class="number">1</span>], cnt;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    isNotPrime[<span class="number">1</span>] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!isNotPrime[i]) primes[++cnt] = i;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; primes[j] * i &lt;= n; j++) &#123;</div><div class="line">            <span class="keyword">int</span> p = primes[j];</div><div class="line">            isNotPrime[i * p] = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> f[MAX_CNT + <span class="number">1</span>][MAX_N + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">    sieve(n);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++) f[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) f[<span class="number">0</span>][j] = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</div><div class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = primes[i]; k &lt;= j; k *= primes[i]) &#123;</div><div class="line">                f[i][j] += f[i - <span class="number">1</span>][j - k];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%llu\n"</span>, f[cnt][n]);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于一个长度为 $ n $ 的序列 $ A $，记其置换集合为 $ G $，对于 $ f \in G $，记使得 $ f(f(f (\dots (f(A)))) = A $ 的嵌套次数为其排数，求对于所有 $ f \in&lt;br&gt;G $ 共有多少种不同的排数。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://sulfur6.github.io/tags/DP/"/>
    
      <category term="线性筛" scheme="http://sulfur6.github.io/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    
      <category term="置换" scheme="http://sulfur6.github.io/tags/%E7%BD%AE%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>「SCOI2009」生日快乐</title>
    <link href="http://sulfur6.github.io/bzoj-1024/"/>
    <id>http://sulfur6.github.io/bzoj-1024/</id>
    <published>2017-07-04T02:39:29.000Z</published>
    <updated>2017-07-04T03:19:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>现有一块长为 $ X $，宽为 $ Y $ 的蛋糕，切 $ N - 1 $ 刀，分成 $ N $ 块，在保证每块蛋糕面积相等的前提下使得 $ N $ 块切好的蛋糕长边比短边的最大值最小，求这个最小值。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>乍一看感觉除了搜好像没有什么更好的做法，但是想了想感觉 $ X, Y $ 的范围看起来让人发虚。。</p>
<p>于是就咸鱼的看了题解。。才注意到 $ N \leq 10 $ 这个可爱的条件。</p>
<p>首先，对于需要被等分成 $ N $ 块的长为 $ X $，宽为 $ Y $ 的蛋糕，若横切，则分成的两块的宽度必须为 $ \lfloor \frac Y N \rfloor $ 的整数倍，否则一定无法满足等分，纵切情况类似。</p>
<p>由于 $ N $ 很小，可以直接暴搜，设当前状态为面对一块长为 $ x $，宽为 $ y $，需要被分成 $ d $ 块的蛋糕，分横切纵切枚举分成的两块的长或宽，搜出来最大的长宽比更新答案即可。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">int</span> d)</span> </span>&#123;</div><div class="line">    <span class="keyword">double</span> res = <span class="number">100000.0</span>;</div><div class="line">    <span class="keyword">if</span> (d == <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (x &lt; y) <span class="built_in">std</span>::swap(x, y);</div><div class="line">        <span class="keyword">return</span> x / y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">double</span> xx = x / d;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d / <span class="number">2</span>; i++) &#123;</div><div class="line">        <span class="keyword">double</span> temp = <span class="built_in">std</span>::max(dfs(xx * i, y, i), dfs(x - xx * i, y, d - i));</div><div class="line">     	res = <span class="built_in">std</span>::min(res, temp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">double</span> yy = y / d;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d / <span class="number">2</span>; i++) &#123;</div><div class="line">        <span class="keyword">double</span> temp = <span class="built_in">std</span>::max(dfs(x, yy * i, i), dfs(x, y - yy * i, d - i));</div><div class="line">        res = <span class="built_in">std</span>::min(res, temp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> x, y, n;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;x, &amp;y, &amp;n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, dfs(x, y, n));</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现有一块长为 $ X $，宽为 $ Y $ 的蛋糕，切 $ N - 1 $ 刀，分成 $ N $ 块，在保证每块蛋糕面积相等的前提下使得 $ N $ 块切好的蛋糕长边比短边的最大值最小，求这个最小值。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="搜索" scheme="http://sulfur6.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>「SHOI2008」仙人掌图 - 仙人掌DP，单调队列</title>
    <link href="http://sulfur6.github.io/bzoj-1023/"/>
    <id>http://sulfur6.github.io/bzoj-1023/</id>
    <published>2017-07-03T13:04:21.000Z</published>
    <updated>2017-07-04T02:40:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个仙人掌图，求其直径。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>仙人掌什么的好难呀，看了好长时间的题解才理解究竟要怎么做，不过感觉还是蛮有趣的，处理树上和环上的方式也很巧妙，那么我就简单口胡一下。。</p>
<p>选一个点为根，DFS 整棵树，设 $ f(i) $ 表示DFS树中以节点 $ i $ 为根的子树的点集在原图中的诱导子图中以 $ i $ 开始的最长路径。</p>
<p>若不考虑环，记 $ S<em>i $ 为节点 $ i $ 的儿子集合，则有 $ f(i) = \max\limits</em>{j \in S_i}(f(j) + 1) $。</p>
<p>然而由于环的存在，会使得某些点之间的距离变小，从而影响维护到的 $ f $ 值的正确性，所以我们在转移 $ f(i) $ 时需要满足转移到他的节点 $ j $ 不和 $ i $ 处在同一个环上，即不在同一个环上转移 $ f $。</p>
<p>判断环的问题，只需要在 DFS 的时候按照 Tarjan 算法的流程记录每个点的 $ \text{low} $ 和 $ \text{dfn} $ 即可。</p>
<p>由于仙人掌的特性，以及 DFS 的过程，对于每个环都可以找到一个深度最小的点，我们称这个点为 <strong>最高点</strong>，显然的，这个环的祖先的 $ f $ 值的更新需要且仅需要用到最高点的 $ f $ 值，所以对于整个环，在用环上的节点的不在环上的子节点更新过自身的 $ f $ 后，只需要再更新最高点的 $ f $ 值即可。</p>
<p>设最高点为 $ u $，则 $ f(u) $ 由环上节点转移的方式为 $ f(u) = f(v) + \text{dist}(u, v) $ ，其中 $ v $ 和 $ u $ 在同一环上，</p>
<p>以上内容全部是关于 $ f $ 值的更新，接下来要说的是更新答案的方式。</p>
<p>对于桥上的答案，我们在 DFS 过程中更新 $ f $ 值的同时更新答案，设答案为 $ \text{ans} $，目前正在更新 $ f $ 值的节点为 $ i $，则此时有 $ \text{ans} =  f(i) + f(j) + 1, j \in S_i $。注意要在尝试从节点 $ j $ 转移 $ f $ 值之前更新答案，否则不能涵盖所有情况，还可能导致状态出现错误。</p>
<p>显然地，环上的节点也可以用来更新答案。对于环上的节点 $ i, j $ 来说，其导致的答案的形式应该是 $ f(i) + f(j) + \text{dist}(i, j) $。设 $ s(i) $ 为节点 $ i $ 在环上的编号（编号按照 DFS树 上的深度为顺序），则原式可以改写成为 $ f(i) + f(j) + |s(i) - s(j)| $。如果按照深度为顺序转移答案，并且保证在枚举到节点 $ i $ 时转移区间连续并且长度不超过环长度的一半，就可以使用单调队列维护 $ f(j) - s(j) $ 的值来优化转移。</p>
<p>具体细节详见代码。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50000</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Node;</div><div class="line"><span class="keyword">struct</span> Edge;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Node &#123;</div><div class="line">    Edge *e;</div><div class="line">    Node *fa;</div><div class="line">    <span class="keyword">int</span> dfn, low;</div><div class="line">    <span class="keyword">int</span> len;</div><div class="line">    <span class="keyword">bool</span> vis;</div><div class="line">&#125; N[MAX_N + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Edge &#123;</div><div class="line">    Node *fr, *to;</div><div class="line">    Edge *ne;</div><div class="line"></div><div class="line">    Edge(Node *fr, Node *to) : fr(fr), to(to), ne(fr-&gt;e) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> fr, <span class="keyword">int</span> to)</span> </span>&#123;</div><div class="line">    N[fr].e = <span class="keyword">new</span> Edge(&amp;N[fr], &amp;N[to]);</div><div class="line">    N[to].e = <span class="keyword">new</span> Edge(&amp;N[to], &amp;N[fr]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">circle</span><span class="params">(Node *top, Node *u, <span class="keyword">int</span> &amp;ans)</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> Node *v[MAX_N * <span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        v[cnt++] = u;</div><div class="line">        <span class="keyword">if</span> (u == top) <span class="keyword">break</span>;</div><div class="line">        u = u-&gt;fa;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::reverse(v, v + cnt);</div><div class="line">    <span class="built_in">std</span>::copy(v, v + cnt, v + cnt);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> half = cnt / <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> q[MAX_N * <span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span> *l = q, *r = q;</div><div class="line">    *r = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt * <span class="number">2</span>; i++) &#123;</div><div class="line">        <span class="keyword">while</span> (i - *l &gt; half) l++;</div><div class="line"></div><div class="line">        ans = <span class="built_in">std</span>::max(ans, v[*l]-&gt;len + v[i]-&gt;len + i - *l);</div><div class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; v[i]-&gt;len - i &gt; v[*r]-&gt;len - *r) r--;</div><div class="line">        *++r = i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt; i++) &#123;</div><div class="line">        res = <span class="built_in">std</span>::max(res, v[i]-&gt;len + <span class="built_in">std</span>::min(i, cnt - i));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    top-&gt;len = <span class="built_in">std</span>::max(top-&gt;len, res);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(Node *v)</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ts = <span class="number">0</span>;</div><div class="line">    v-&gt;dfn = v-&gt;low = ++ts;</div><div class="line">    <span class="keyword">for</span> (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123;</div><div class="line">        <span class="keyword">if</span> (e-&gt;to != v-&gt;fa) &#123;</div><div class="line">            <span class="keyword">if</span> (!e-&gt;to-&gt;dfn) &#123;</div><div class="line">                e-&gt;to-&gt;fa = v;</div><div class="line">                tarjan(e-&gt;to);</div><div class="line">                v-&gt;low = <span class="built_in">std</span>::min(v-&gt;low, e-&gt;to-&gt;low);</div><div class="line">            &#125; <span class="keyword">else</span> v-&gt;low = <span class="built_in">std</span>::min(v-&gt;low, e-&gt;to-&gt;dfn);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (v-&gt;dfn &lt; e-&gt;to-&gt;low) &#123;</div><div class="line">                ans = <span class="built_in">std</span>::max(ans, v-&gt;len + e-&gt;to-&gt;len + <span class="number">1</span>);</div><div class="line">                v-&gt;len = <span class="built_in">std</span>::max(v-&gt;len, e-&gt;to-&gt;len + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123;</div><div class="line">        <span class="keyword">if</span> (e-&gt;to-&gt;fa != v &amp;&amp; e-&gt;to-&gt;dfn &gt; v-&gt;dfn) &#123;</div><div class="line">            circle(v, e-&gt;to, ans);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n, m;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">        <span class="keyword">int</span> k, u;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;k, &amp;u);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= k; j++) &#123;</div><div class="line">            <span class="keyword">int</span> v;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</div><div class="line">            addEdge(u, v);</div><div class="line">            u = v;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tarjan(&amp;N[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个仙人掌图，求其直径。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="单调队列" scheme="http://sulfur6.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="DP" scheme="http://sulfur6.github.io/tags/DP/"/>
    
      <category term="仙人掌图" scheme="http://sulfur6.github.io/tags/%E4%BB%99%E4%BA%BA%E6%8E%8C%E5%9B%BE/"/>
    
      <category term="仙人掌DP" scheme="http://sulfur6.github.io/tags/%E4%BB%99%E4%BA%BA%E6%8E%8CDP/"/>
    
  </entry>
  
  <entry>
    <title>「SHOI2008」循环的债务 - DP</title>
    <link href="http://sulfur6.github.io/bzoj-1021/"/>
    <id>http://sulfur6.github.io/bzoj-1021/</id>
    <published>2017-06-19T03:34:29.000Z</published>
    <updated>2017-06-19T09:39:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>A，B，C 三个人之间互相有一些债务，每个人有面值为 $ 1, 5, 10, 20, 50, 100 $ 的钞票若干，求出他们之间钞票交换次数最少的交换方式。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>最开始看到这道题的时候，我还以为这题是网络流。。现在看看我还是 too young..</p>
<p>好吧可以说团长的DP是真的好差。。</p>
<p>这道题的初始状态就像题目描述中说的那样，终止状态应该是 A，B，C 各自还清债务又收回欠款，由于欠款可以用一个 DAG 来描述（若成环则去掉环中权值最小的边），所以终止状态下 A，B，C 拥有的钱的数目是一定的，所以尝试使用钱数作为状态。</p>
<p>设 $ f(i, a, b) $ 为使用前 $ i $ 种面值的钞票，使得 $ A $ 有 $ a $ 元，$ B $ 有 $ b $ 元的最小交换次数。</p>
<p>枚举交换方式，有如下几种交换：</p>
<p>$<br>a \rightarrow b, c \\<br>b \rightarrow a, c \\<br>c \rightarrow a, c \\<br>a, b \rightarrow c \\<br>a, c \rightarrow b \\<br>b, c \rightarrow a<br>$</p>
<p>其中 $ a \rightarrow b $ 意为 $ a $ 把钱给 $ b $。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">1000</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> VAL[] = &#123; <span class="number">-1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> sum[<span class="number">3</span>], own[<span class="number">3</span>][<span class="number">6</span> + <span class="number">1</span>];</div><div class="line"><span class="keyword">int</span> tot;</div><div class="line"></div><div class="line"><span class="keyword">int</span> f[<span class="number">6</span> + <span class="number">1</span>][MAX_M + <span class="number">1</span>][MAX_M + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a, b, c;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;c);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span> &amp;&amp; c &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> min = <span class="built_in">std</span>::min(<span class="built_in">std</span>::min(a, b), c);</div><div class="line">        a -= min, b -= min, c -= min;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span> &amp;&amp; c &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> max = <span class="built_in">std</span>::max(<span class="built_in">std</span>::max(a, b), c);</div><div class="line">        a -= max, b -= max, c -= max;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;own[i][<span class="number">6</span> - j]);</div><div class="line">            sum[i] += own[i][<span class="number">6</span> - j] * VAL[<span class="number">6</span> - j];</div><div class="line">        &#125;</div><div class="line">        tot += sum[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; i++)</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= MAX_M; j++)</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= MAX_M; k++)</div><div class="line">                f[i][j][k] = INT_MAX;</div><div class="line"></div><div class="line">    f[<span class="number">0</span>][sum[<span class="number">0</span>]][sum[<span class="number">1</span>]] = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= tot; a++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= tot - a; b++) &#123;</div><div class="line">                <span class="keyword">int</span> c = tot - a - b;</div><div class="line">                <span class="keyword">if</span> (f[i][a][b] == INT_MAX) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">                <span class="comment">// a -&gt; b, c</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> tb = <span class="number">0</span>; tb &lt;= own[<span class="number">0</span>][i + <span class="number">1</span>]; tb++) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> tc = <span class="number">0</span>; tc &lt;= own[<span class="number">0</span>][i + <span class="number">1</span>] - tb; tc++) &#123;</div><div class="line">                        <span class="keyword">if</span> (tb + tc == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">                        <span class="keyword">int</span> _a = a - VAL[i + <span class="number">1</span>] * (tb + tc);</div><div class="line">                        <span class="keyword">int</span> _b = b + VAL[i + <span class="number">1</span>] * tb;</div><div class="line">                        <span class="keyword">int</span> _c = c + VAL[i + <span class="number">1</span>] * tc;</div><div class="line">                        f[i + <span class="number">1</span>][_a][_b] = <span class="built_in">std</span>::min(f[i + <span class="number">1</span>][_a][_b], f[i][a][b] + tb + tc);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// b -&gt; a, c</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> ta = <span class="number">0</span>; ta &lt;= own[<span class="number">1</span>][i + <span class="number">1</span>]; ta++) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> tc = <span class="number">0</span>; tc &lt;= own[<span class="number">1</span>][i + <span class="number">1</span>] - ta; tc++) &#123;</div><div class="line">                        <span class="keyword">if</span> (ta + tc == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">                        <span class="keyword">int</span> _a = a + VAL[i + <span class="number">1</span>] * ta;</div><div class="line">                        <span class="keyword">int</span> _b = b - VAL[i + <span class="number">1</span>] * (ta + tc);</div><div class="line">                        <span class="keyword">int</span> _c = c + VAL[i + <span class="number">1</span>] * tc;</div><div class="line">                        f[i + <span class="number">1</span>][_a][_b] = <span class="built_in">std</span>::min(f[i + <span class="number">1</span>][_a][_b], f[i][a][b] + ta + tc);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// c -&gt; a, b</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> ta = <span class="number">0</span>; ta &lt;= own[<span class="number">2</span>][i + <span class="number">1</span>]; ta++) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> tb = <span class="number">0</span>; tb &lt;= own[<span class="number">2</span>][i + <span class="number">1</span>] - ta; tb++) &#123;</div><div class="line">                        <span class="keyword">if</span> (ta + tb == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">                        <span class="keyword">int</span> _a = a + VAL[i + <span class="number">1</span>] * ta;</div><div class="line">                        <span class="keyword">int</span> _b = b + VAL[i + <span class="number">1</span>] * tb;</div><div class="line">                        <span class="keyword">int</span> _c = c - VAL[i + <span class="number">1</span>] * (ta + tb);</div><div class="line">                        f[i + <span class="number">1</span>][_a][_b] = <span class="built_in">std</span>::min(f[i + <span class="number">1</span>][_a][_b], f[i][a][b] + ta + tb);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// a, b -&gt; c</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> fa = <span class="number">0</span>; fa &lt;= own[<span class="number">0</span>][i + <span class="number">1</span>]; fa++) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> fb = <span class="number">0</span>; fb &lt;= own[<span class="number">1</span>][i + <span class="number">1</span>]; fb++) &#123;</div><div class="line">                        <span class="keyword">if</span> (fa + fb == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">                        <span class="keyword">int</span> _a = a - VAL[i + <span class="number">1</span>] * fa;</div><div class="line">                        <span class="keyword">int</span> _b = b - VAL[i + <span class="number">1</span>] * fb;</div><div class="line">                        <span class="keyword">int</span> _c = c + VAL[i + <span class="number">1</span>] * (fa + fb);</div><div class="line">                        f[i + <span class="number">1</span>][_a][_b] = <span class="built_in">std</span>::min(f[i + <span class="number">1</span>][_a][_b], f[i][a][b] + fa + fb);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// a, c -&gt; b</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> fa = <span class="number">0</span>; fa &lt;= own[<span class="number">0</span>][i + <span class="number">1</span>]; fa++) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> fc = <span class="number">0</span>; fc &lt;= own[<span class="number">2</span>][i + <span class="number">1</span>]; fc++) &#123;</div><div class="line">                        <span class="keyword">if</span> (fa + fc == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">                        <span class="keyword">int</span> _a = a - VAL[i + <span class="number">1</span>] * fa;</div><div class="line">                        <span class="keyword">int</span> _b = b + VAL[i + <span class="number">1</span>] * (fa + fc);</div><div class="line">                        <span class="keyword">int</span> _c = c - VAL[i + <span class="number">1</span>] * fc;</div><div class="line">                        f[i + <span class="number">1</span>][_a][_b] = <span class="built_in">std</span>::min(f[i + <span class="number">1</span>][_a][_b], f[i][a][b] + fa + fc);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// b, c -&gt; a</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> fb = <span class="number">0</span>; fb &lt;= own[<span class="number">1</span>][i + <span class="number">1</span>]; fb++) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> fc = <span class="number">0</span>; fc &lt;= own[<span class="number">2</span>][i + <span class="number">1</span>]; fc++) &#123;</div><div class="line">                        <span class="keyword">if</span> (fb + fc == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">                        <span class="keyword">int</span> _a = a + VAL[i + <span class="number">1</span>] * (fb + fc);</div><div class="line">                        <span class="keyword">int</span> _b = b - VAL[i + <span class="number">1</span>] * fb;</div><div class="line">                        <span class="keyword">int</span> _c = c - VAL[i + <span class="number">1</span>] * fc;</div><div class="line">                        f[i + <span class="number">1</span>][_a][_b] = <span class="built_in">std</span>::min(f[i + <span class="number">1</span>][_a][_b], f[i][a][b] + fb + fc);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                f[i + <span class="number">1</span>][a][b] = <span class="built_in">std</span>::min(f[i + <span class="number">1</span>][a][b], f[i][a][b]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> resA = sum[<span class="number">0</span>] - a + c, resB = sum[<span class="number">1</span>] - b + a, resC = sum[<span class="number">2</span>] - c + b;</div><div class="line">    <span class="keyword">if</span> (resA &lt; <span class="number">0</span> || resB &lt; <span class="number">0</span> || resC &lt; <span class="number">0</span> || f[<span class="number">6</span>][resA][resB] == INT_MAX) <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</div><div class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">6</span>][resA][resB]);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A，B，C 三个人之间互相有一些债务，每个人有面值为 $ 1, 5, 10, 20, 50, 100 $ 的钞票若干，求出他们之间钞票交换次数最少的交换方式。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://sulfur6.github.io/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>「SHOI2008」汉诺塔 - DP</title>
    <link href="http://sulfur6.github.io/bzoj-1019/"/>
    <id>http://sulfur6.github.io/bzoj-1019/</id>
    <published>2017-06-13T06:49:15.000Z</published>
    <updated>2017-06-19T03:33:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>用 $ A, B, C $ 分别表示汉诺塔问题中的三根柱子。</p>
<p>用两个字母描述一个操作，例如 <code>AB</code> 就是把柱子 $ A $ 最上面圆盘挪动到柱子 $ B $ 上。</p>
<p>我们为所有的 $ 6 $ 种操作赋予一个优先级，并且利用以下规则进行游戏：</p>
<ol>
<li>选择一种操作，这种操作是所有合法操作中优先级最高的。</li>
<li>本次操作需要移动的圆盘不是上一次操作移动的圆盘。</li>
</ol>
<p>可以证明，上述策略一定能完成汉诺塔游戏。<br>计算给定操作优先级时将 $ A $ 柱子上的 $ n $ 个圆盘全部移动到另一根上所需的操作数。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>由于优先级的限制，不能像传统的汉诺塔问题一样解决，考虑DP。</p>
<p>设 $ f(j, i) $ 表示将 $ i $ 号柱子最上面的 $ j $ 个盘子（不考虑下面的盘子），移动到编号为 $ g(j, i) $ 的柱子上所需要的最小移动次数。</p>
<p>显然的，当 $ j = 1 $ 时，$ g(j, i) $ 由题目给定的优先级确定。按照 $ j $ 从小到大划分阶段，则 $ j &gt; 1 $ 时 $ g(j, i) $ 的值由前一阶段确定。</p>
<p>转移 $ f(j, i) $ 时，考虑 $ f(j - 1, i) $ 和 $ g(j - 1, i) $。</p>
<p>记 $ g(j - 1, i) = a $，则按照传统的汉诺塔问题的思路应该移动到除了柱子 $ i $ 和柱子 $ a $ 的另一根柱子，记作 $ b $，而且有 $ b = 3 - a - i $。</p>
<p>若 $ g(j - 1, a) = b $，则我们需要做的只有将柱子 $ i $ 上的第 $ j $ 个盘子移动到 $ b $ 上，然后把柱子 $ a $ 上的 $ j - 1 $ 个柱子移动到柱子 $ b $ 上。</p>
<p>此时对于 $ f(j, i) $ 有：<br>$$<br>f(j, i) = f(j - 1, i) + 1 + f(j - 1, a)<br>$$</p>
<p>而对于 $ g(j, i) $ 有：<br>$$<br>g(j, i) = b<br>$$</p>
<p>若 $ g(j - 1, a) = i $，则此时的最优解决方案是先将第 $ j $ 个盘子移动到 $ b $ 上，再将柱子 $ a $ 上的 $ j $ 个盘子移动到第 $ i $ 根柱子上，再将盘子 $ j $ 移动到柱子 $ a $ 上，最后将柱子 $ i $ 上的 $ j - 1 $ 个盘子移动到柱子 $ a $ 上。</p>
<p>此时对于 $ f(j, i) $ 有：<br>$$<br>f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) + 1 + f(j - 1, i)<br>$$</p>
<p>对于 $ g(j, i) $ 有：<br>$$<br>g(j, i) = a<br>$$</p>
<p>对于这种奇怪的转移可以通过对于只移动一根柱子的特殊情况的思考来理解。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> g[MAX_N + <span class="number">1</span>][<span class="number">3</span>];</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[MAX_N + <span class="number">1</span>][<span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line"></div><div class="line">    g[<span class="number">1</span>][<span class="number">0</span>] = g[<span class="number">1</span>][<span class="number">1</span>] = g[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</div><div class="line">        <span class="keyword">char</span> rule[<span class="number">4</span>];</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, rule);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> fr = rule[<span class="number">0</span>] - <span class="string">'A'</span>, to = rule[<span class="number">1</span>] - <span class="string">'A'</span>;</div><div class="line">        <span class="keyword">if</span> (g[<span class="number">1</span>][fr] == <span class="number">-1</span>) g[<span class="number">1</span>][fr] = to; <span class="comment">// Good to own a BRAIN..</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = f[<span class="number">1</span>][<span class="number">1</span>] = f[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">int</span> a = g[j - <span class="number">1</span>][i], b = <span class="number">3</span> - a - i;</div><div class="line">            <span class="keyword">if</span> (g[j - <span class="number">1</span>][a] == b) &#123;</div><div class="line">                f[j][i] = f[j - <span class="number">1</span>][i] + <span class="number">1</span> + f[j - <span class="number">1</span>][a];</div><div class="line">                g[j][i] = b;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                f[j][i] = f[j - <span class="number">1</span>][i] + <span class="number">1</span> + f[j - <span class="number">1</span>][a] + <span class="number">1</span> + f[j - <span class="number">1</span>][i];</div><div class="line">                g[j][i] = a;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n][<span class="number">0</span>]);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 $ A, B, C $ 分别表示汉诺塔问题中的三根柱子。&lt;/p&gt;
&lt;p&gt;用两个字母描述一个操作，例如 &lt;code&gt;AB&lt;/code&gt; 就是把柱子 $ A $ 最上面圆盘挪动到柱子 $ B $ 上。&lt;/p&gt;
&lt;p&gt;我们为所有的 $ 6 $ 种操作赋予一个优先级，并且利用以下规则进行游戏：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择一种操作，这种操作是所有合法操作中优先级最高的。&lt;/li&gt;
&lt;li&gt;本次操作需要移动的圆盘不是上一次操作移动的圆盘。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以证明，上述策略一定能完成汉诺塔游戏。&lt;br&gt;计算给定操作优先级时将 $ A $ 柱子上的 $ n $ 个圆盘全部移动到另一根上所需的操作数。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://sulfur6.github.io/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>「SHOI2008」堵塞的交通 - 线段树</title>
    <link href="http://sulfur6.github.io/bzoj-1018/"/>
    <id>http://sulfur6.github.io/bzoj-1018/</id>
    <published>2017-06-11T00:24:44.000Z</published>
    <updated>2017-06-12T03:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>在一个有 $ 2C $ 个点，$ 3C - 2 $ 条边的 $ 2 $ 行 $ C $ 列的网格图中，相邻两个节点有连边，给定以下三种操作。</p>
<ol>
<li><code>Open r1 c1 r2 c2</code> 连接节点 <code>(r1, c1), (r2, c2)</code> 的边连通。</li>
<li><code>Close r1 c1 r2 c2</code> 连接节点 <code>(r1, c1), (r2, c2)</code> 的边断开。</li>
<li><code>Ask r1 c1 r2 c2</code> 查询节点 <code>(r1, c1), (r2, c2)</code> 之间的连通性。</li>
</ol>
<p>开始时每条边都是断开的状态。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>为什么这种特殊的要死的图我第一时间想到的是 LCT，怕不是我失了智。。</p>
<p>但是看了题解的线段树做法，我感觉我整个人都没有智商了。。怕不是我变成了大傻子。。</p>
<p>原图中有上下两行，这里用 $ (i, 0) $ 表示第 $ i $ 列上面的城市，用 $ (i, 1) $ 表示第 $ i $ 列下面的城市。</p>
<p>对于线段树中的一个代表区间 $ [l, r] $ 的节点，其中维护的是 $ (l, 0), (l, 1) $ 分别与 $ (r, 0), (r, 1) $ 的连通性。</p>
<p>对于某个区间 $ [l = i, r = i] $，我们认为这个区间中的 $ (l, 0), (r, 0) $ 是连通的，同样的 $ (l, 1), (r, 1) $ 也是连通的。</p>
<p>若该位置上下连通，则认为 $ (l, 0), (r, 1) $ 连通，同时 $ (r, 0), (l, 1) $ 连通。</p>
<p>合并两个区间 $ [l, m], [m + 1, r] $，枚举 $ m \leftrightarrow m + 1 $ 经过的是上面的还是下面的路径。</p>
<p>回答询问时，假设 $ c1 $ 在 $ c2 $ 左边，二分 $ c1 $ 能够达到的最左位置以及 $ c2 $ 能够达到的最右位置，枚举回答。假如 <code>(r1, c1)</code> 不和 <code>(r2, c2)</code> 直接连通，那么这样做可以包含到 <code>(r1, c1)</code> 先向左走以及 <code>(r2, c2)</code> 先向右走的情况。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_C = <span class="number">100000</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">bool</span> right[MAX_C][<span class="number">2</span>], uad[MAX_C + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Connectivity &#123;</div><div class="line">    <span class="keyword">bool</span> a[<span class="number">2</span>][<span class="number">2</span>];</div><div class="line"></div><div class="line">    Connectivity(<span class="keyword">bool</span> init) &#123;</div><div class="line">        a[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">0</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">0</span>] = a[<span class="number">1</span>][<span class="number">1</span>] = init;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> a[i][j]; &#125;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> j)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> a[i][j]; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> a[<span class="number">0</span>][<span class="number">0</span>] || a[<span class="number">0</span>][<span class="number">1</span>] || a[<span class="number">1</span>][<span class="number">0</span>] || a[<span class="number">1</span>][<span class="number">1</span>]; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> Connectivity <span class="title">merge</span><span class="params">(Connectivity a, Connectivity b, <span class="keyword">int</span> mid)</span> </span>&#123;</div><div class="line">    <span class="function">Connectivity <span class="title">res</span><span class="params">(<span class="literal">false</span>)</span></span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</div><div class="line">                res(i, j) |= a(i, k) &amp;&amp; right[mid][k] &amp;&amp; b(k, j);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Segt &#123;</div><div class="line">    <span class="keyword">int</span> l, r, mid;</div><div class="line">    Segt *lc, *rc;</div><div class="line"></div><div class="line">    <span class="comment">// con(0, 0) : (l, 0) &lt;-&gt; (r, 0)</span></div><div class="line">    <span class="comment">// con(0, 1) : (l, 0) &lt;-&gt; (r, 1)</span></div><div class="line">    <span class="comment">// con(1, 0) : (l, 1) &lt;-&gt; (r, 0)</span></div><div class="line">    <span class="comment">// con(1, 1) : (l, 1) &lt;-&gt; (r, 1)</span></div><div class="line">    Connectivity con;</div><div class="line"></div><div class="line">    Segt(<span class="keyword">int</span> l, <span class="keyword">int</span> r, Segt *lc, Segt *rc) : l(l), r(r), mid(l + (r - l) / <span class="number">2</span>), lc(lc), rc(rc), con(l == r) &#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (l &gt; <span class="keyword">this</span>-&gt;r || r &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;l == <span class="keyword">this</span>-&gt;r) &#123;</div><div class="line">            con(<span class="number">0</span>, <span class="number">0</span>) = con(<span class="number">1</span>, <span class="number">1</span>) = <span class="literal">true</span>;</div><div class="line">            con(<span class="number">0</span>, <span class="number">1</span>) = con(<span class="number">1</span>, <span class="number">0</span>) = uad[mid];</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">else</span> lc-&gt;modify(l, r), rc-&gt;modify(l, r);</div><div class="line">        con = merge(lc-&gt;con, rc-&gt;con, mid);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">Connectivity <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (l &lt;= <span class="keyword">this</span>-&gt;l &amp;&amp; r &gt;= <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> <span class="keyword">this</span>-&gt;con;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> lc-&gt;query(l, r);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> rc-&gt;query(l, r);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> merge(lc-&gt;query(l, r), rc-&gt;query(l, r), mid);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> Segt *<span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> Segt(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Segt(l, r, build(l, mid), build(mid + <span class="number">1</span>, r));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125; *segt;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> c1, <span class="keyword">int</span> r2, <span class="keyword">int</span> c2, <span class="keyword">bool</span> state)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (r1 == r2) &#123;</div><div class="line">        right[<span class="built_in">std</span>::min(c1, c2)][r1] = state;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c1 == c2) &#123;</div><div class="line">        uad[c1] = state;</div><div class="line">    &#125;</div><div class="line">    segt-&gt;modify(<span class="built_in">std</span>::min(c1, c2), <span class="built_in">std</span>::max(c1, c2));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> c1, <span class="keyword">int</span> r2, <span class="keyword">int</span> c2)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> l, r;</div><div class="line"></div><div class="line">    l = <span class="number">1</span>, r = c1;</div><div class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</div><div class="line">         <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</div><div class="line">         Connectivity res = segt-&gt;query(mid, c1);</div><div class="line">         <span class="keyword">if</span> (res(<span class="number">0</span>, r1) || res(<span class="number">1</span>, r1)) r = mid;</div><div class="line">         <span class="keyword">else</span> l = mid + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> lpos = l;</div><div class="line">    Connectivity lcon = segt-&gt;query(lpos, c1);</div><div class="line"></div><div class="line">    l = c2, r = n;</div><div class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</div><div class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">        Connectivity res = segt-&gt;query(c2, mid);</div><div class="line">        <span class="keyword">if</span> (res(r2, <span class="number">0</span>) || res(r2, <span class="number">1</span>)) l = mid;</div><div class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rpos = l;</div><div class="line">    Connectivity rcon = segt-&gt;query(c2, rpos);</div><div class="line"></div><div class="line">    Connectivity con = segt-&gt;query(lpos, rpos);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (lcon(i, r1) &amp;&amp; rcon(r2, j) &amp;&amp; con(i, j)) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">    segt = Segt::build(<span class="number">1</span>, n);</div><div class="line">    <span class="keyword">char</span> cmd[<span class="number">5</span>];</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd) != EOF) &#123;</div><div class="line">        <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'E'</span>) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> r1, c1, r2, c2;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;r1, &amp;c1, &amp;r2, &amp;c2);</div><div class="line">            r1--, r2--;</div><div class="line">            <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'O'</span>) modify(r1, c1, r2, c2, <span class="literal">true</span>);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'C'</span>) modify(r1, c1, r2, c2, <span class="literal">false</span>);</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (c1 &gt; c2) <span class="built_in">std</span>::swap(r1, r2), <span class="built_in">std</span>::swap(c1, c2);</div><div class="line">                <span class="built_in">puts</span>(query(r1, c1, r2, c2) ? <span class="string">"Y"</span> : <span class="string">"N"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个有 $ 2C $ 个点，$ 3C - 2 $ 条边的 $ 2 $ 行 $ C $ 列的网格图中，相邻两个节点有连边，给定以下三种操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Open r1 c1 r2 c2&lt;/code&gt; 连接节点 &lt;code&gt;(r1, c1), (r2, c2)&lt;/code&gt; 的边连通。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Close r1 c1 r2 c2&lt;/code&gt; 连接节点 &lt;code&gt;(r1, c1), (r2, c2)&lt;/code&gt; 的边断开。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ask r1 c1 r2 c2&lt;/code&gt; 查询节点 &lt;code&gt;(r1, c1), (r2, c2)&lt;/code&gt; 之间的连通性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;开始时每条边都是断开的状态。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="线段树" scheme="http://sulfur6.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>「JSOI2008」魔兽地图 - 树形DP，多重背包</title>
    <link href="http://sulfur6.github.io/bzoj-1017/"/>
    <id>http://sulfur6.github.io/bzoj-1017/</id>
    <published>2017-06-03T11:30:33.000Z</published>
    <updated>2017-06-03T12:29:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定 $ n $ 件物品，$ m $ 个金币，每个物品有自己的价值。低级物品可以直接购买，高级物品需要若干件较低级的物品来合成，并且具有合成的数量限制，求能够获得的最大价值。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>很不错的树形DP，反正我一开始是没想出来。</p>
<p>设 $ p_i, c_i, w_i $ 分别表示物品 $ i $ 的价值，合成数量限制和价格。</p>
<p>高级装备的 $ w, c $ 用子树的信息合并一下就好。</p>
<p>设 $ f(i, j, k) $ 为合成 $ j $ 件物品 $ i $ 贡献给父节点，花费了 $ k $ 个金币所能获得的最大价值。记 $ son_i $ 为节点 $ i $ 的子节点集合。</p>
<p>枚举合成 $ a $ 件 $ i $ 物品，余下的钱用来购买一些子树中的物品来获得价值。</p>
<p>对于枚举到的合成数目 $ a $，设 $ g(t, j) $ 表示在某个节点的前 $ t $ 棵子树花费 $ j $ 个金币所能获得的最大收益，$ q_i(k) $ 表示合成物品 $ i $ 所需物品 $ k $ 的数量。</p>
<p>$$<br>g(t, j) = \max\limits_{k = 0}^{j}{g(t, j), g(t - 1, j - k) + f(son_i(t), a \times q_i(son_i(t)), j)}<br>$$</p>
<p>从合成的 $ a $ 件中挑选 $ j $ 件贡献给父节点，由此转移 $ f(i, j, k) $。</p>
<p>$$<br>f(i, j, k) = \max{ g(|son_i|, k) + p_i \times (a - j) }<br>$$</p>
<p>这道题最巧妙的决策点在确定合成一件物品时用来获得价值的数目和拿来合成更高级物品的数目。</p>
<p>然后，如果没有任何高级装备的话，需要另写一个多重背包来特判。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">51</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">2000</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_K = <span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, m;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Node;</div><div class="line"><span class="keyword">struct</span> Edge;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Node &#123;</div><div class="line">    Edge *e;</div><div class="line">    <span class="keyword">int</span> cnt, cost, p, d;</div><div class="line">    <span class="keyword">int</span> f[MAX_K + <span class="number">1</span>][MAX_M + <span class="number">1</span>];</div><div class="line">    <span class="keyword">bool</span> basic;</div><div class="line">&#125; N[MAX_N + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Edge &#123;</div><div class="line">    Node *fr, *to;</div><div class="line">    Edge *ne;</div><div class="line">    <span class="keyword">int</span> w;</div><div class="line"></div><div class="line">    Edge(Node *fr, Node *to, <span class="keyword">int</span> w) : fr(fr), to(to), ne(fr-&gt;e), w(w) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> fr, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">    N[to].d++;</div><div class="line">    N[fr].e = <span class="keyword">new</span> Edge(&amp;N[fr], &amp;N[to], w);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> g[MAX_N + <span class="number">1</span>][MAX_M + <span class="number">1</span>], h[MAX_N + <span class="number">1</span>][MAX_M + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dp</span><span class="params">(Node *v)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> (&amp;f)[MAX_K + <span class="number">1</span>][MAX_M + <span class="number">1</span>] = v-&gt;f;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (v-&gt;basic) &#123;</div><div class="line">        v-&gt;cnt = <span class="built_in">std</span>::min(v-&gt;cnt, m / v-&gt;cost);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= v-&gt;cnt; i++)</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= v-&gt;cnt; j++)</div><div class="line">                f[i][j * v-&gt;cost] = (j - i) * v-&gt;p;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        v-&gt;cnt = INT_MAX;</div><div class="line">        <span class="keyword">for</span> (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123;</div><div class="line">            dp(e-&gt;to);</div><div class="line">            v-&gt;cnt = <span class="built_in">std</span>::min(v-&gt;cnt, e-&gt;to-&gt;cnt / e-&gt;w);</div><div class="line">            v-&gt;cost += e-&gt;w * e-&gt;to-&gt;cost;</div><div class="line">        &#125;</div><div class="line">        v-&gt;cnt = <span class="built_in">std</span>::min(v-&gt;cnt, m / v-&gt;cost);</div><div class="line"></div><div class="line">        <span class="built_in">memset</span>(g, <span class="number">-0x3f3f3f3f</span>, <span class="keyword">sizeof</span>(g));</div><div class="line"></div><div class="line">        g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = v-&gt;cnt; a &gt;= <span class="number">0</span>; a--) &#123;</div><div class="line">            <span class="keyword">int</span> id = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (Edge *e = v-&gt;e; e; e = e-&gt;ne) &#123;</div><div class="line">                id++;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; k++)</div><div class="line">                        g[id][j] = <span class="built_in">std</span>::max(g[id][j], g[id - <span class="number">1</span>][j - k] + e-&gt;to-&gt;f[e-&gt;w * a][k]);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a; i++)</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= m; k++)</div><div class="line">                    f[i][k] = <span class="built_in">std</span>::max(f[i][k], g[id][k] + v-&gt;p * (a - i));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solveTree</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= MAX_K; j++)</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= MAX_M; k++)</div><div class="line">                N[i].f[j][k] = <span class="number">-100000000</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123;</div><div class="line">        Node *v = &amp;N[x];</div><div class="line">        <span class="keyword">if</span> (!v-&gt;d) &#123;</div><div class="line">            dp(v);</div><div class="line">            tot++;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= v-&gt;cnt; k++)</div><div class="line">                        h[tot][i] = <span class="built_in">std</span>::max(h[tot][i], h[tot - <span class="number">1</span>][j] + v-&gt;f[k][i - j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> ans = INT_MIN;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) ans = <span class="built_in">std</span>::max(ans, h[tot][j]);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> MonoQueue &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt; data, aux;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span> </span>&#123;</div><div class="line">        data.push_back(x);</div><div class="line">        <span class="keyword">while</span> (!aux.empty() &amp;&amp; aux.back() &lt; x) aux.pop_back();</div><div class="line">        aux.push_back(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (data.front() == aux.front()) aux.pop_front();</div><div class="line">        data.pop_front();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> data.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">T <span class="title">max</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> aux.front();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> f[MAX_M + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">multiplePack</span><span class="params">(<span class="keyword">int</span> cost, <span class="keyword">int</span> w, <span class="keyword">int</span> cnt)</span> </span>&#123;</div><div class="line">    cnt = <span class="built_in">std</span>::min(cnt, m / cost);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; cost; d++) &#123;</div><div class="line">        MonoQueue&lt;<span class="keyword">int</span>&gt; q;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k * cost + d &lt;= m; k++) &#123;</div><div class="line">            q.push(f[k * cost + d] - k * w);</div><div class="line">            <span class="keyword">if</span> (q.size() == cnt + <span class="number">2</span>) q.pop();</div><div class="line">            f[k * cost + d] = q.max() + k * w;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solveMultiplePack</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        multiplePack(N[i].cost, N[i].p, N[i].cnt);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> ans = INT_MIN;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</div><div class="line">        ans = <span class="built_in">std</span>::max(ans, f[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N[i].p);</div><div class="line">        <span class="keyword">char</span> ch[<span class="number">5</span>];</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, ch);</div><div class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>] == <span class="string">'B'</span>) &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N[i].cost, &amp;N[i].cnt);</div><div class="line">            N[i].basic = <span class="literal">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> c;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</div><div class="line">            <span class="keyword">while</span> (c--) &#123;</div><div class="line">                <span class="keyword">int</span> v, w;</div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;v, &amp;w);</div><div class="line">                addEdge(i, v, w);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (N[i].d) flag = <span class="literal">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (flag) solveTree();</div><div class="line">    <span class="keyword">else</span> solveMultiplePack();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定 $ n $ 件物品，$ m $ 个金币，每个物品有自己的价值。低级物品可以直接购买，高级物品需要若干件较低级的物品来合成，并且具有合成的数量限制，求能够获得的最大价值。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="单调队列" scheme="http://sulfur6.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="树形DP" scheme="http://sulfur6.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="多重背包" scheme="http://sulfur6.github.io/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>「JSOI2008」最小生成树计数 - 状压，kruskal</title>
    <link href="http://sulfur6.github.io/bzoj-1016/"/>
    <id>http://sulfur6.github.io/bzoj-1016/</id>
    <published>2017-05-29T07:01:31.000Z</published>
    <updated>2017-06-04T09:31:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个无向图，求其最小生成树个数。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>尝试证明一个奇奇怪怪的定理：一个无向图的所有最小生成树中某种权值的边的数目相同。</p>
<p>按照 <code>kruskal</code> 算法的流程，我们会在对边排序之后尝试从小到大尝试加入某种权值的所有边，我们设权值最小的边的权值为 $ w $，原图中权值为 $ w $ 的边有 $ c $ 条，出现在最小生成树中的权值为 $ w $ 的边有 $ a $ 条。那么任何一个加入 $ a $ 条边权为 $ w $ 的边而不使图成环的方案都可以使原图到达相同的连通性。</p>
<p>假设加入能够加入的 $ a $ 条边以后得到若干个连通块，记其中一个连通块为 $ G $，其余连通块同理，那么去掉 $ G $ 中一条边，得到两个连通块 $ A, B $，现在尝试添加一条不同于原来在 $ G $ 中任意一条边的边，那么此时这条边 $ (u, v) $ 有两种情况：</p>
<ol>
<li>$ u \in A, v \in B $，那么添加这条边后仍然得到连通块 $ G $。</li>
<li>$ (u \in A, v \in A) \wedge (u \in B, v \in B) $ 那么添加这条边势必成环，此时不允许添加这条边。</li>
</ol>
<p>在添加第二小的边的时候，将添加最小的边之后得到的若干个连通块缩点，这时已经没有可以加进最小生成树的权值最小的边，所以权值最第二小的边变成新的权值最小的边，此时尝试加边之后得到的图的连通性的性质同上述情况。</p>
<p>以添加进最小生成树的边的权值划分阶段，那么每个阶段中添加的边的数量是固定的，这也就意味着某种权值的边的数目是完全相同的。</p>
<p>以上内容借鉴如下博客。。<br><a href="http://blog.csdn.net/wyfcyx_forever/article/details/40182739" target="_blank" rel="external">BZOJ1016 [JSOI2008]最小生成树计数</a></p>
<p>贴上 sengxian 更加严谨的证明：<br><a href="https://blog.sengxian.com/solutions/bzoj-1016" target="_blank" rel="external">BZOJ 1016 - [JSOI2008]最小生成树计数</a></p>
<p>得到了这个结论以后，就可以枚举选择每种边权的边了，如果在节点间连上枚举到的边不成环，那么这就是一种可行的最小生成树方案。利用状压枚举，统计每种边权的方案数，最后乘法原理即可。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">1000</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">31011</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Edge &#123;</div><div class="line">    <span class="keyword">int</span> u, v, w;</div><div class="line">    <span class="keyword">bool</span> vis;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge &amp;other) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">return</span> w &lt; other.w;</div><div class="line">    &#125;</div><div class="line">&#125; E[MAX_M + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="keyword">struct</span> UFS &#123;</div><div class="line">    <span class="keyword">int</span> fa[MAX_N + <span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) fa[i] = i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> x == fa[x] ? fa[x] : fa[x] = find(fa[x]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> f1 = find(x), f2 = find(y);</div><div class="line">        fa[f1] = f2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> find(x) == find(y);</div><div class="line">    &#125;</div><div class="line">&#125; ufs;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> EdgeGroup &#123;</div><div class="line">    <span class="keyword">int</span> cnt;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; e;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, m;</div><div class="line"><span class="keyword">bool</span> g[MAX_N + <span class="number">1</span>][MAX_N + <span class="number">1</span>];</div><div class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, EdgeGroup&gt; groups;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::sort(E, E + m);</div><div class="line">    ufs.init(n);</div><div class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!ufs.check(E[i].u, E[i].v)) &#123;</div><div class="line">            E[i].vis = <span class="literal">true</span>;</div><div class="line">            ufs.merge(E[i].u, E[i].v);</div><div class="line">            groups[E[i].w].cnt++;</div><div class="line">            cnt++;</div><div class="line">        &#125;</div><div class="line">        groups[E[i].w].e.push_back(E[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cnt == n - <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;E[i].u, &amp;E[i].v, &amp;E[i].w);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!kruskal()) &#123;</div><div class="line">        <span class="built_in">puts</span>(<span class="string">"0"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="keyword">if</span> (E[i].vis) g[E[i].u][E[i].v] = g[E[i].v][E[i].u] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, EdgeGroup&gt;::const_iterator it = groups.begin(); it != groups.end(); it++) &#123;</div><div class="line">            <span class="keyword">if</span> (it-&gt;second.cnt == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; it-&gt;second.e.size()); s++) &#123;</div><div class="line">                <span class="keyword">int</span> tot = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; it-&gt;second.e.size(); i++) <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; i)) tot++;</div><div class="line">                <span class="keyword">if</span> (tot != it-&gt;second.cnt) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;::const_iterator e = it-&gt;second.e.begin(); e != it-&gt;second.e.end(); e++) &#123;</div><div class="line">                    g[e-&gt;u][e-&gt;v] = g[e-&gt;v][e-&gt;u] = <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; it-&gt;second.e.size(); i++) &#123;</div><div class="line">                    <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; i)) g[it-&gt;second.e[i].u][it-&gt;second.e[i].v] = g[it-&gt;second.e[i].v][it-&gt;second.e[i].u] = <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ufs.init(n);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</div><div class="line">                        <span class="keyword">if</span> (g[i][j]) &#123;</div><div class="line">                            <span class="keyword">if</span> (ufs.check(i, j)) <span class="keyword">goto</span> Continue;</div><div class="line">                            ufs.merge(i, j);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                t++;</div><div class="line"></div><div class="line">Continue:;</div><div class="line">            &#125;</div><div class="line"></div><div class="line"><span class="comment">//			printf("t = %d\n", t);</span></div><div class="line">            (ans *= t) %= MOD;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;::const_iterator e = it-&gt;second.e.begin(); e != it-&gt;second.e.end(); e++) &#123;</div><div class="line">                g[e-&gt;u][e-&gt;v] = g[e-&gt;v][e-&gt;u] = e-&gt;vis;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个无向图，求其最小生成树个数。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="搜索" scheme="http://sulfur6.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces Round 416 (Div. 2)」 C - DP</title>
    <link href="http://sulfur6.github.io/cf811c/"/>
    <id>http://sulfur6.github.io/cf811c/</id>
    <published>2017-05-28T03:05:48.000Z</published>
    <updated>2017-06-02T13:41:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个序列，每个位置上有一种颜色，要求把这个序列分成可以不连续的若干段，所有颜色相同的要么全部不选要么全部分到一段中，最终选取出的每一段的价值等于段中不同颜色编号的异或和，求最大价值。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一开始我想处理区间之间的嵌套关系和交集关系，然后根据最终区间的嵌套关系来做树形DP，但是处理着处理着我发现区间的嵌套盒交集有一万种关系。</p>
<p>绝望的我选择去翻AC代码，发现了一种新奇的DP思路。</p>
<p>记原序列为 $ a $，设 $ f(i) $ 为处理到前 $ i $ 位的最大价值。 </p>
<p>$ f(i) $ 可以从两种方式转移来，一种是 $ f(i) = f(i - 1) $，表示 $ a_i $ 所在的段目前不可选，或不选 $ a_i $ 颜色所在的段，另一种是考虑合并后的 $ a_i $ 所在的区间，记其左端点为 $ j $，有 $ f(i) = f(j - 1) + \texttt{XORsum}(j, i) $。</p>
<p>区间的合并可以在转移 $ f(i) $ 时，从 $ i $ 到 $ 1 $ 枚举 $ j $ 的过程中动态转移。注意一种颜色只需要被异或一次。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">5000</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> a[MAX_N + <span class="number">1</span>], l[MAX_N + <span class="number">1</span>], r[MAX_N + <span class="number">1</span>], dp[MAX_N + <span class="number">1</span>], vis[MAX_N + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MAX_N; i++) &#123;</div><div class="line">        l[i] = n + <span class="number">1</span>;</div><div class="line">        r[i] = <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</div><div class="line">        a[i] = x;</div><div class="line">        l[x] = <span class="built_in">std</span>::min(l[x], i);</div><div class="line">        r[x] = <span class="built_in">std</span>::max(r[x], i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, lb = n;</div><div class="line">        dp[i] = dp[i - <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--) &#123;</div><div class="line">            lb = <span class="built_in">std</span>::min(lb, j);</div><div class="line">            <span class="keyword">int</span> x = a[j];</div><div class="line">            <span class="keyword">if</span> (r[x] &gt; i) <span class="keyword">break</span>;</div><div class="line">            lb = <span class="built_in">std</span>::min(lb, l[x]);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (vis[x] != i) &#123;</div><div class="line">                vis[x] = i;</div><div class="line">                sum ^= x;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (lb == j) &#123;</div><div class="line">                dp[i] = <span class="built_in">std</span>::max(dp[i], dp[j - <span class="number">1</span>] + sum);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n]);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个序列，每个位置上有一种颜色，要求把这个序列分成可以不连续的若干段，所有颜色相同的要么全部不选要么全部分到一段中，最终选取出的每一段的价值等于段中不同颜色编号的异或和，求最大价值。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://sulfur6.github.io/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>「JSOI2008」火星人Prefix - Splay，Hash</title>
    <link href="http://sulfur6.github.io/bzoj1014/"/>
    <id>http://sulfur6.github.io/bzoj1014/</id>
    <published>2017-05-28T02:47:01.000Z</published>
    <updated>2017-06-02T13:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串，要求支持修改串中某个字符，在指定位置添加字符，以及求指定两个后缀的 $ LCP $ 长度。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>提到LCP当然会想到后缀家族，不过我才疏学浅，并不知道后缀家族怎么支持修改和插入。</p>
<p>所以，Hash 大法好！</p>
<p>话说回来当时在长乐的时候写字符串哈希的暴力，可能是我姿势不太对？模数一直取不对。。这道题没有卡自然溢出，感觉还是很良心的。</p>
<p>好啦言归正传，对这个字符串建立一棵Splay，保证其中序遍历结果为原字符串。这样每一个Splay的节点都可以代表一个字串。如果要获得某个指定字串的哈希值，用Splay提区间就可以了。。</p>
<p>合并左右子树信息的时候，不知诸君喜欢以左为高位还是右为高位啊。。这里就不引战啦哈哈。</p>
<p>提示一个细节，这里为了Splay操作方便引入的左右端点节点会对某些节点的哈希值产生影响，但是由于Splay提取区间以后提取出来的区间对应的子树不会包括左右端点节点，而且这道题只需要用到提取区间，所以这样写没有错误。如果要让它的哈希值是正确的特判一下就好啦。</p>
<p>还有讲实话哈希那一套理论我真的是不怎么懂啊 T^T</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100000</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">150000</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> BASE = <span class="number">233</span>;</div><div class="line"></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> base[MAX_N + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Splay &#123;</div><div class="line">    <span class="keyword">struct</span> Node &#123;</div><div class="line">        Node *fa, *c[<span class="number">2</span>], **root;</div><div class="line">        <span class="keyword">int</span> size;</div><div class="line">        <span class="keyword">char</span> val;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> hash;</div><div class="line"></div><div class="line">        Node(Node *fa, Node **root, <span class="keyword">char</span> val) : fa(fa), root(root), size(<span class="number">1</span>), val(val), hash(val) &#123;</div><div class="line">            c[<span class="number">0</span>] = c[<span class="number">1</span>] = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</div><div class="line">            size = (c[<span class="number">0</span>] ? c[<span class="number">0</span>]-&gt;size : <span class="number">0</span>) + (c[<span class="number">1</span>] ? c[<span class="number">1</span>]-&gt;size : <span class="number">0</span>) + <span class="number">1</span>;</div><div class="line"></div><div class="line">            hash = val;</div><div class="line">            <span class="keyword">if</span> (c[<span class="number">1</span>]) hash += c[<span class="number">1</span>]-&gt;hash * BASE;</div><div class="line">            <span class="keyword">if</span> (c[<span class="number">0</span>]) hash = hash * base[c[<span class="number">0</span>]-&gt;size] + c[<span class="number">0</span>]-&gt;hash;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">lsize</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> c[<span class="number">0</span>] ? c[<span class="number">0</span>]-&gt;size : <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">relation</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span> == fa-&gt;c[<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">()</span> </span>&#123;</div><div class="line">            Node *old = fa;</div><div class="line">            <span class="keyword">int</span> x = relation();</div><div class="line"></div><div class="line">            fa = old-&gt;fa;</div><div class="line">            <span class="keyword">if</span> (old-&gt;fa) old-&gt;fa-&gt;c[old-&gt;relation()] = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">            old-&gt;c[x] = c[x ^ <span class="number">1</span>];</div><div class="line">            <span class="keyword">if</span> (c[x ^ <span class="number">1</span>]) c[x ^ <span class="number">1</span>]-&gt;fa = old;</div><div class="line"></div><div class="line">            c[x ^ <span class="number">1</span>] = old;</div><div class="line">            old-&gt;fa = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">            old-&gt;maintain(), maintain();</div><div class="line">            <span class="keyword">if</span> (!fa) *root = <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function">Node *<span class="title">splay</span><span class="params">(Node *target = <span class="literal">NULL</span>)</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span> (fa != target) &#123;</div><div class="line">                <span class="keyword">if</span> (fa-&gt;fa == target) rotate();</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (fa-&gt;relation() == relation()) fa-&gt;rotate(), rotate();</div><div class="line">                <span class="keyword">else</span> rotate(), rotate();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; *root;</div><div class="line"></div><div class="line">    Splay() : root(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line"></div><div class="line">    <span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *begin, <span class="keyword">const</span> <span class="keyword">char</span> *end, Node *par)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (begin &gt; end) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (begin == end) <span class="keyword">return</span> <span class="keyword">new</span> Node(par, &amp;root, *begin);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *mid = begin + (end - begin) / <span class="number">2</span>;</div><div class="line">            Node *v = <span class="keyword">new</span> Node(par, &amp;root, *mid);</div><div class="line">            v-&gt;c[<span class="number">0</span>] = build(begin, mid - <span class="number">1</span>, v);</div><div class="line">            v-&gt;c[<span class="number">1</span>] = build(mid + <span class="number">1</span>, end, v);</div><div class="line">            v-&gt;maintain();</div><div class="line">            <span class="keyword">return</span> v;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildBound</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        Node *v = root;</div><div class="line">        <span class="keyword">while</span> (v-&gt;c[x]) v = v-&gt;c[x];</div><div class="line">        v-&gt;c[x] = <span class="keyword">new</span> Node(v, &amp;root, <span class="number">0</span>);</div><div class="line">        Node *u = v;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            u-&gt;maintain();</div><div class="line">            u = u-&gt;fa;</div><div class="line">        &#125; <span class="keyword">while</span> (u);</div><div class="line">        v-&gt;c[x]-&gt;splay();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *begin, <span class="keyword">const</span> <span class="keyword">char</span> *end)</span> </span>&#123;</div><div class="line">        root = build(begin, end, <span class="literal">NULL</span>);</div><div class="line">        buildBound(<span class="number">0</span>);</div><div class="line">        buildBound(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">Node *<span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> x = k + <span class="number">1</span>;</div><div class="line">        Node *v = root;</div><div class="line">        <span class="keyword">while</span> (x != v-&gt;lsize() + <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (x &lt;= v-&gt;lsize()) v = v-&gt;c[<span class="number">0</span>];</div><div class="line">            <span class="keyword">else</span> x -= v-&gt;lsize() + <span class="number">1</span>, v = v-&gt;c[<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> v-&gt;splay();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">Node *<span class="title">select</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</div><div class="line">        Node *u = select(l - <span class="number">1</span>), *v = select(r + <span class="number">1</span>);</div><div class="line">        u-&gt;splay();</div><div class="line">        v-&gt;splay(u);</div><div class="line">        <span class="keyword">return</span> v-&gt;c[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">Node *<span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">char</span> val)</span> </span>&#123;</div><div class="line">        Node *u = select(pos), *v = select(pos + <span class="number">1</span>);</div><div class="line">        u-&gt;splay();</div><div class="line">        v-&gt;splay(u);</div><div class="line">        v-&gt;c[<span class="number">0</span>] = <span class="keyword">new</span> Node(v, &amp;root, val);</div><div class="line">        Node *q = v-&gt;c[<span class="number">0</span>];</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            q-&gt;maintain();</div><div class="line">            q = q-&gt;fa;</div><div class="line">        &#125; <span class="keyword">while</span> (q);</div><div class="line">        <span class="keyword">return</span> v-&gt;c[<span class="number">0</span>]-&gt;splay();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">char</span> val)</span> </span>&#123;</div><div class="line">        Node *v = select(pos);</div><div class="line">        v-&gt;val = val;</div><div class="line">        v-&gt;maintain();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> select(l, r)-&gt;hash;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> root-&gt;size - <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125; splay;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="built_in">std</span>::min(splay.size() - a + <span class="number">1</span>, splay.size() - b + <span class="number">1</span>);</div><div class="line">    <span class="keyword">while</span> (l != r) &#123;</div><div class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (splay.query(a, a + mid - <span class="number">1</span>) == splay.query(b, b + mid - <span class="number">1</span>))</div><div class="line">            l = mid;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            r = mid - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> l;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">char</span> s[MAX_N + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    base[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX_N; i++) base[i] = base[i - <span class="number">1</span>] * BASE;</div><div class="line"></div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</div><div class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</div><div class="line">    splay.build(s, s + n - <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> m;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">        <span class="keyword">char</span> cmd[<span class="number">2</span>];</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</div><div class="line">        <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'Q'</span>) &#123;</div><div class="line">            <span class="keyword">int</span> a, b;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lcp(a, b));</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'R'</span>) &#123;</div><div class="line">            <span class="keyword">int</span> pos;</div><div class="line">            <span class="keyword">char</span> val[<span class="number">2</span>];</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %s"</span>, &amp;pos, val);</div><div class="line">            splay.modify(pos, val[<span class="number">0</span>]);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'I'</span>) &#123;</div><div class="line">            <span class="keyword">int</span> pos;</div><div class="line">            <span class="keyword">char</span> val[<span class="number">2</span>];</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %s"</span>, &amp;pos, val);</div><div class="line">            splay.insert(pos, val[<span class="number">0</span>]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个字符串，要求支持修改串中某个字符，在指定位置添加字符，以及求指定两个后缀的 $ LCP $ 长度。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="Splay" scheme="http://sulfur6.github.io/tags/Splay/"/>
    
      <category term="Hash" scheme="http://sulfur6.github.io/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>「HNOI2008」GT考试 - DP，矩阵乘法，KMP</title>
    <link href="http://sulfur6.github.io/bzoj1009/"/>
    <id>http://sulfur6.github.io/bzoj1009/</id>
    <published>2017-05-27T13:20:05.000Z</published>
    <updated>2017-06-02T13:39:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>阿申准备报名参加GT考试，准考证号为 $ N $ 位数 $ X_1X_2 \dots X_n (0 \leq X_i \leq 9) $，他不希望准考证号上出现不吉利的数字。他的不吉利数字 $ A_1A_2 \dots A_m(0 \leq A_i \leq 9) $ 有 $ M $ 位，不出现是指 $ X_1X_2 \dots X_n $ 中没有恰好一段等于 $ A_1 A_2 \dots Am.  $， 特别地 $ A_1 $ 和 $ x_1 $ 可以为 $ 0 $</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先这题数据范围非常可爱， $ 1 \leq N \leq 10 ^ 9, 1 \leq m \leq 20 $，这个数据范围会让人不自觉的想起矩乘。</p>
<p>设 $ f(i, j) $ 表示已经确定了准考证号的前 $ i $ 位，在这 $ i $ 位的末尾出现了不吉利数字的 $ j $ 个。</p>
<p>枚举 $ 0 \sim 9 $ 转移，考虑在第 $ i + 1 $ 位上添上某一个数字，可能转移到 $ f(i + 1, j + 1), f(i + 1, \text{next}[j] + 1), f(i + 1, \text{next[next}[j]]) \dots $。</p>
<p>用语言来描述的话，就是新添加的这个数字可能会让最后的不吉利数字延长，或者让末位的某几位变为原来出现的连续不吉利数字的前缀。</p>
<p>其实这个东西随便暴力啦，毕竟 $ m $ 只有 $ 20 $。。</p>
<p>剩下的事情就是构造转移矩阵了，由于每次转移只和 $ j $ 有关，所以可以轻松预处理转移矩阵。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1e9</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Matrix &#123;</div><div class="line">    <span class="keyword">int</span> a[MAX_M + <span class="number">5</span>][MAX_M + <span class="number">5</span>];</div><div class="line">    <span class="keyword">int</span> n, m;</div><div class="line"></div><div class="line">    Matrix(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">bool</span> unit = <span class="literal">false</span>) &#123;</div><div class="line">        <span class="keyword">this</span>-&gt;n = n;</div><div class="line">        <span class="keyword">this</span>-&gt;m = m;</div><div class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</div><div class="line">        <span class="keyword">if</span> (unit) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) a[i][i] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, m, mod;</div><div class="line"><span class="keyword">char</span> s[MAX_M + <span class="number">1</span>];</div><div class="line"><span class="keyword">int</span> next[MAX_M + <span class="number">1</span>];</div><div class="line"></div><div class="line">Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix &amp;a, <span class="keyword">const</span> Matrix &amp;b) &#123;</div><div class="line">    <span class="function">Matrix <span class="title">res</span><span class="params">(a.n, b.m, <span class="literal">false</span>)</span></span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.n; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.m; j++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.m; k++) &#123;</div><div class="line">                (res.a[i][j] += a.a[i][k] * b.a[k][j]) %= mod;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Matrix <span class="title">pow</span><span class="params">(Matrix a, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="function">Matrix <span class="title">res</span><span class="params">(a.n, a.n, <span class="literal">true</span>)</span></span>;</div><div class="line">    <span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, a = a * a) <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = res * a;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getNext</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</div><div class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[j + <span class="number">1</span>] != s[i]) j = next[j];</div><div class="line">        <span class="keyword">if</span> (s[j + <span class="number">1</span>] == s[i]) j++;</div><div class="line">        next[i] = j;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;mod);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</div><div class="line">    getNext();</div><div class="line"></div><div class="line">    <span class="function">Matrix <span class="title">shift</span><span class="params">(m, m, <span class="literal">false</span>)</span></span>;</div><div class="line">    <span class="function">Matrix <span class="title">origin</span><span class="params">(m, <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</div><div class="line">            <span class="keyword">int</span> k = i;</div><div class="line">            <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; s[k + <span class="number">1</span>] - <span class="string">'0'</span> != j) k = next[k];</div><div class="line">            <span class="keyword">if</span> (s[k + <span class="number">1</span>] - <span class="string">'0'</span> == j) k++;</div><div class="line">            (shift.a[k][i] += <span class="number">1</span>) %= mod;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    origin.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    Matrix res = <span class="built_in">pow</span>(shift, n) * origin;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) (ans += res.a[i][<span class="number">0</span>]) %= mod;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阿申准备报名参加GT考试，准考证号为 $ N $ 位数 $ X_1X_2 \dots X_n (0 \leq X_i \leq 9) $，他不希望准考证号上出现不吉利的数字。他的不吉利数字 $ A_1A_2 \dots A_m(0 \leq A_i \leq 9) $ 有 $ M $ 位，不出现是指 $ X_1X_2 \dots X_n $ 中没有恰好一段等于 $ A_1 A_2 \dots Am.  $， 特别地 $ A_1 $ 和 $ x_1 $ 可以为 $ 0 $&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="DP" scheme="http://sulfur6.github.io/tags/DP/"/>
    
      <category term="KMP" scheme="http://sulfur6.github.io/tags/KMP/"/>
    
      <category term="矩阵乘法" scheme="http://sulfur6.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>英雄难度「卡拉赞之夜」通关记</title>
    <link href="http://sulfur6.github.io/HearthStone-Karazhan/"/>
    <id>http://sulfur6.github.io/HearthStone-Karazhan/</id>
    <published>2017-05-27T07:03:30.000Z</published>
    <updated>2017-05-27T08:47:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>团长通关卡拉赞辣！</p>
<p><img src="/img/Karazhan/Over.PNG" alt="Over"></p>
<a id="more"></a>
<h1 id="宴会厅"><a href="#宴会厅" class="headerlink" title="宴会厅"></a>宴会厅</h1><h2 id="镀银魔像-amp-魔镜"><a href="#镀银魔像-amp-魔镜" class="headerlink" title="镀银魔像&amp;魔镜"></a>镀银魔像&amp;魔镜</h2><p><img src="/img/Karazhan/镀银魔像&amp;魔镜.png" alt="镀银魔像&amp;魔镜"></p>
<p>第一关镀银魔像，起手要找AOE，保证二费的时候能够清掉四个盘子，这里推荐前期AOE用复仇打击（如果带的话），因为对面抢血飞快，等到养奴隶主的时候如果复仇打击黄了就GG了。<br>起手最好有小斧子，手里有解有过牌就很舒服。</p>
<p>尽量能够尽早上奴隶主，奴隶主上去以后镀银魔像不怎么会主动来解，生一场奴隶主跟他耗就是。不过暴乱狂现在已经不能斩杀了，所以他对我来说是一个极高攻击力的嘲讽，哈哈。</p>
<p>第二关能用奴隶战的原因主要是BOSS复制出来的随从全部是 $ 1/1 $，这套奴隶战一血的AOE能够很好的解决那些复制的小杂毛。</p>
<p>魔镜手里还有不少法术的，他召出来的随从一般都是带法强的。BOSS的奥秘我记得有法反镜像和复制，复制不怕，复制进去的东西，像科学家哀绿和狗头一般我们都解的掉，注意不要复制到什么大法师就好了。我记得BOSS还有个安东尼达斯，要留解牌。镜像的话，这套卡组里面的随从好像没有什么复制到就崩盘的。。不过能试还是尽量试一下，毕竟对面场上多个暴乱狂你也不舒服。最讨厌的应该是法反，可能也和我过牌量不足有关，手里没有合适的能够破法反的法术，有好几次AOE或者斩杀这样的关键法术被反掉导致我重开。。</p>
<p>这里要做一个补充说明，这套卡组并不是当时我用来通关的卡组，当时的卡组和现在的卡组的区别在于两张战斗怒火被我换成了一张凶暴猿猴一张腐肉食尸鬼，因为因为缺少过牌，所以我有几个回合只能靠右手第一张。。</p>
<h2 id="国际象棋"><a href="#国际象棋" class="headerlink" title="国际象棋"></a>国际象棋</h2><p>象棋应该是我打的时间最长的一关，一开始看攻略，想不清楚就瞎打，卡关卡了几个小时。。那天真的是打吐了。说说我的体会吧。</p>
<p>其实这关并不是很难，找一个比较好的起手，想清楚一点打得贪一点肯定能赢。</p>
<p>我是用的网上说的那种「一费不下子，二费下一个，三费接城堡」的套路，然后四费下骑士，配合城堡吃掉主教，后面的就以清掉黑棋的场然后等皇后来为主。核心思想在于皇后在场的时候尽量多的让皇后抢血，因为后面你没有子了，而对面还有，还可以作弊。打不到脸的时候就输了。想的细一点，一回合想两回合的东西，别瞎打，就能过。</p>
<h1 id="歌剧院"><a href="#歌剧院" class="headerlink" title="歌剧院"></a>歌剧院</h1><p>歌剧院，确实是非常戏剧性的一层。。</p>
<h2 id="朱丽叶"><a href="#朱丽叶" class="headerlink" title="朱丽叶"></a>朱丽叶</h2><p><img src="/img/Karazhan/朱丽叶.png" alt="朱丽叶"></p>
<p>这关其实我利用了一个AI上的缺陷，就是在朱丽叶场功比你高时一般不会主动解你的随从，所以两只复活的铠甲帮我把对面的几十点场功降到七点，带烈焰喷涌其实是因为我玩的比较晚没有奥冲，我们的任务就是要解决掉罗密欧这只两血随从。。</p>
<h2 id="大灰狼"><a href="#大灰狼" class="headerlink" title="大灰狼"></a>大灰狼</h2><p><img src="/img/Karazhan/大灰狼.png" alt="大灰狼"></p>
<p>这一关赢得惊心动魄，我一开始就把三个慈祥的外婆破了，如果不是伊瑟拉给了我张苏醒那一局就打不过去了。总之这一关的BOSS的特点就是只有你手牌中的随从才是 $ 1/1/1 $，所有召唤出的东西，或者是从牌库中直接召唤的随从（比如亚煞极拉出来），都是原身材，所以我才有了用青玉的想法，不过前期BOSS铺的场到底怎么解决我也没想好。</p>
<h2 id="巫婆"><a href="#巫婆" class="headerlink" title="巫婆"></a>巫婆</h2><p><img src="/img/Karazhan/巫婆.png" alt="巫婆"></p>
<p>几乎是最简单的一关。。这一套是我上个月组起来在天梯上玩的猎人，本来想去看看战场是什么样子结果就打过了。一费雄斑虎二费土狼，很开心的是对面解不了土狼，然后被我土狼一脚一脚踢死了。。</p>
<p>其实最简单的打法是用心火牧，起手翻倍心火，对面是怎么死的都不知道。。</p>
<h1 id="展览馆"><a href="#展览馆" class="headerlink" title="展览馆"></a>展览馆</h1><h2 id="馆长"><a href="#馆长" class="headerlink" title="馆长"></a>馆长</h2><p><img src="/img/Karazhan/馆长.png" alt="馆长"></p>
<p>这一关主要是馆长的嘲讽使得他的随从能够躲在后面输出。单说一费的尘魔就有很多职业解起来很麻烦，这个时候就要挑解场能力比较强的职业了。我比较推荐法师，这一关火冲的补刀真的特别特别好用。</p>
<h2 id="夜之魇"><a href="#夜之魇" class="headerlink" title="夜之魇"></a>夜之魇</h2><p>没什么好说的，自动星界。全带大哥，跟他拼大哥就是了。我的牌表不是很壕就不放上来丢人了qwq。</p>
<p>不过如果他第一个回合上大螺丝解了你的怪或者拍大表哥你还解不掉可能就GG了。。</p>
<h2 id="邪蹄"><a href="#邪蹄" class="headerlink" title="邪蹄"></a>邪蹄</h2><p><img src="/img/Karazhan/邪蹄.png" alt="邪蹄"></p>
<p>我是加基森出了挺长时间以后才开始玩的。那个时候已经有可以摩擦邪蹄的「疯狂药水」了。</p>
<p>起手找两张疯狂药水，你拉过来的粗鄙小鬼死了给你生小鬼还掉邪蹄的血。暗影狂乱白富美都可以带，反正是一个随随便便过的BOSS。</p>
<h1 id="上层塔"><a href="#上层塔" class="headerlink" title="上层塔"></a>上层塔</h1><h2 id="埃兰之影"><a href="#埃兰之影" class="headerlink" title="埃兰之影"></a>埃兰之影</h2><p><img src="/img/Karazhan/埃兰之影.png" alt="埃兰之影"></p>
<p>多带点法术砸死他，好像也没什么可说的。享受蓝龙加成的快感吧！</p>
<p>注意埃兰的那个全场打 $ 10 $ 的奥秘就好，不用随从打他，用法术轰他。</p>
<p>而且这个BOSS有法反，注意一下就好。</p>
<h2 id="虚空幽龙"><a href="#虚空幽龙" class="headerlink" title="虚空幽龙"></a>虚空幽龙</h2><p><img src="/img/Karazhan/虚空幽龙.png" alt="虚空幽龙"></p>
<p>把大屁股嘲讽放在右边，高攻击冲锋放在左边。可能是AI有问题，一费我在右边放了一个虚空行者，然后BOSS就和失了智一样，前四个回合什么都没干。。然后就被我碾压了。。</p>
<h2 id="营救麦迪文"><a href="#营救麦迪文" class="headerlink" title="营救麦迪文"></a>营救麦迪文</h2><p><img src="/img/Karazhan/营救麦迪文.png" alt="营救麦迪文"></p>
<p>常见的思路，要么是王子出来接着斩了他，要么是法反掉扭曲虚空，还有就是克总转生城墙萨。这里我选择了这一套克苏恩牧。</p>
<p>能赢的契机在于，我发现如果一费北婊，那么BOSS有很大的概率会上监工，这样二费奶一口前期就没有压力了，后期两个兜帽侍僧两个目光尊者两个奶泉足够把克苏恩叠到 $ 72 $ 攻了。</p>
<p>不要控BOSS血，把她打到一血，让她的斧子不敢砍你的墙。</p>
<p>贴一下当时斩杀王子的图，哈哈。</p>
<p><img src="/img/Karazhan/Kthun.PNG" alt="Kthun"></p>
<p><img src="/img/Karazhan/DeathOfPrinces.PNG" alt="DeathOfPrinces"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;团长通关卡拉赞辣！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/Karazhan/Over.PNG&quot; alt=&quot;Over&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日常生活" scheme="http://sulfur6.github.io/categories/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="炉石传说" scheme="http://sulfur6.github.io/tags/%E7%82%89%E7%9F%B3%E4%BC%A0%E8%AF%B4/"/>
    
      <category term="冒险模式" scheme="http://sulfur6.github.io/tags/%E5%86%92%E9%99%A9%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>「HNOI2008」水平可见直线 - 计算几何，单调栈</title>
    <link href="http://sulfur6.github.io/bzoj1007/"/>
    <id>http://sulfur6.github.io/bzoj1007/</id>
    <published>2017-05-24T07:11:44.000Z</published>
    <updated>2017-06-02T13:39:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>有 $ n $ 条直线，在正无穷处往下看，如果一条直线的某一部分没有被其他任何直线覆盖，则我们认为这条直线是可见的，输出所有可见直线的编号。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我先描述一下算法。</p>
<p>首先对所有直线按照斜率从小到大，截距从大到小排序。然后把最小的两条斜率不想等的直线放到一个栈里，每次向栈中加入一条直线时检查即将加入的直线和栈顶直线的交点和栈顶直线和栈第二位直线的交点的位置关系，若新直线与栈顶直线的交点在栈顶直线和栈第二位直线的交点左边，则将栈顶元素弹出，若在右边，则将新直线入栈。最后栈中的直线就是答案。</p>
<p>下面形象的解释一下它的正确性。</p>
<p>首先，我们要维护的应该是一个下凸壳（就是说起来形象一点）。。</p>
<p>假设这是栈中的两条直线，则 $ F $ 为栈顶直线，$ G $ 为栈第二位直线。绿色部分就是目前合法的下凸壳。</p>
<p><img src="/img/BZOJ1007/Original.png" alt="Original"></p>
<p>现在插入直线 $ L $，交点在右侧，此时凸壳变成了蓝色部分，此时栈顶直线 $ F $ 已经变为不可见的，就把它出栈。</p>
<p><img src="/img/BZOJ1007/Left.png" alt="Left"></p>
<p>若直线 $ L $ 和栈顶直线的交点在左侧，凸壳就变成下图状态，此时原栈顶直线仍然可见，则直接将直线 $ L $ 入栈。</p>
<p><img src="/img/BZOJ1007/Right.png" alt="Right"></p>
<p>其实用语言来描述就是，排序以后保证栈顶元素下面的元素一定可以覆盖住它的一半，而只有一条斜率更大的直线才能覆盖住它的另一半，所以只需要检查新加入的斜率更大的直线是否能够完全覆盖未被覆盖的部分就可以了。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfloat&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">50000</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-8</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Line &#123;</div><div class="line">    <span class="keyword">double</span> k, b;</div><div class="line">    <span class="keyword">int</span> id;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Line &amp;other) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(k - other.k) &lt; EPS) <span class="keyword">return</span> b &gt; other.b;</div><div class="line">        <span class="keyword">return</span> k &lt; other.k;</div><div class="line">    &#125;</div><div class="line">&#125; l[MAX_N + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"></div><div class="line"><span class="keyword">int</span> s[MAX_N + <span class="number">1</span>], top = <span class="number">1</span>;</div><div class="line"><span class="keyword">bool</span> ans[MAX_N + <span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(Line a, Line b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (b.b - a.b) / (a.k - b.k);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</div><div class="line">    <span class="built_in">std</span>::sort(l + <span class="number">1</span>, l + n + <span class="number">1</span>);</div><div class="line">    s[top] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(l[i].k - l[i - <span class="number">1</span>].k) &lt; EPS) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; calc(l[i], l[s[top]]) &lt;= calc(l[s[top]], l[s[top - <span class="number">1</span>]])) top--;</div><div class="line">        s[++top] = i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; i++) &#123;</div><div class="line">        ans[l[s[i]].id] = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (ans[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>, &amp;l[i].k, &amp;l[i].b);</div><div class="line">        l[i].id = i;</div><div class="line">    &#125;</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有 $ n $ 条直线，在正无穷处往下看，如果一条直线的某一部分没有被其他任何直线覆盖，则我们认为这条直线是可见的，输出所有可见直线的编号。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://sulfur6.github.io/categories/OI/"/>
    
    
      <category term="计算几何" scheme="http://sulfur6.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
      <category term="单调栈" scheme="http://sulfur6.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
</feed>
